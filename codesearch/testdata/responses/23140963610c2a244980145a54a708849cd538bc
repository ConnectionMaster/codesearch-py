{"file_info_response":[{"return_code":1,"file_info":{"name":"src/base/at_exit.h","lines":"81","size":"2600","language":"c++","type":1,"md5":"b94c2a5d38a41bc0c22bfe8d4f4e5ea2","changelist_num":"5fc67636bc053f254c152913b85d845fcae1d525","mime_type":"text/plain","generated":false,"package_name":"chromium","content":{"text":"// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef BASE_AT_EXIT_H_\n#define BASE_AT_EXIT_H_\n\n#include \u003cstack\u003e\n\n#include \"base/base_export.h\"\n#include \"base/callback.h\"\n#include \"base/macros.h\"\n#include \"base/synchronization/lock.h\"\n\nnamespace base {\n\n// This class provides a facility similar to the CRT atexit(), except that\n// we control when the callbacks are executed. Under Windows for a DLL they\n// happen at a really bad time and under the loader lock. This facility is\n// mostly used by base::Singleton.\n//\n// The usage is simple. Early in the main() or WinMain() scope create an\n// AtExitManager object on the stack:\n// int main(...) {\n//    base::AtExitManager exit_manager;\n//\n// }\n// When the exit_manager object goes out of scope, all the registered\n// callbacks and singleton destructors will be called.\n\nclass BASE_EXPORT AtExitManager {\n public:\n  typedef void (*AtExitCallbackType)(void*);\n\n  AtExitManager();\n\n  // The dtor calls all the registered callbacks. Do not try to register more\n  // callbacks after this point.\n  ~AtExitManager();\n\n  // Registers the specified function to be called at exit. The prototype of\n  // the callback function is void func(void*).\n  static void RegisterCallback(AtExitCallbackType func, void* param);\n\n  // Registers the specified task to be called at exit.\n  static void RegisterTask(base::Closure task);\n\n  // Calls the functions registered with RegisterCallback in LIFO order. It\n  // is possible to register new callbacks after calling this function.\n  static void ProcessCallbacksNow();\n\n  // Disable all registered at-exit callbacks. This is used only in a single-\n  // process mode.\n  static void DisableAllAtExitManagers();\n\n protected:\n  // This constructor will allow this instance of AtExitManager to be created\n  // even if one already exists.  This should only be used for testing!\n  // AtExitManagers are kept on a global stack, and it will be removed during\n  // destruction.  This allows you to shadow another AtExitManager.\n  explicit AtExitManager(bool shadow);\n\n private:\n  base::Lock lock_;\n  std::stack\u003cbase::Closure\u003e stack_;\n  bool processing_callbacks_;\n  AtExitManager* next_manager_;  // Stack of managers to allow shadowing.\n\n  DISALLOW_COPY_AND_ASSIGN(AtExitManager);\n};\n\n#if defined(UNIT_TEST)\nclass ShadowingAtExitManager : public AtExitManager {\n public:\n  ShadowingAtExitManager() : AtExitManager(true) {}\n};\n#endif  // defined(UNIT_TEST)\n\n}  // namespace base\n\n#endif  // BASE_AT_EXIT_H_\n"},"gob_info":{"repo":"chromium/chromium/src","commit":"5fc67636bc053f254c152913b85d845fcae1d525","path":"base/at_exit.h"}}}],"elapsed_ms":14}