{
  "elapsed_ms": 81, 
  "file_info_response": [
    {
      "file_info": {
        "gob_info": {
          "repo": "chromium/chromium/src", 
          "commit": "5fff84af92ec0ebc40e51fd723191dfc5e4aace2", 
          "path": "net/http/http_network_transaction.cc"
        }, 
        "name": "src/net/http/http_network_transaction.cc", 
        "language": "c++", 
        "changelist_num": "5fff84af92ec0ebc40e51fd723191dfc5e4aace2", 
        "package_name": "chromium", 
        "lines": "1856", 
        "content": {
          "text": "// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"net/http/http_network_transaction.h\"\n\n#include <set>\n#include <utility>\n#include <vector>\n\n#include \"base/base64url.h\"\n#include \"base/bind.h\"\n#include \"base/bind_helpers.h\"\n#include \"base/callback_helpers.h\"\n#include \"base/compiler_specific.h\"\n#include \"base/format_macros.h\"\n#include \"base/metrics/field_trial.h\"\n#include \"base/metrics/histogram_functions.h\"\n#include \"base/metrics/histogram_macros.h\"\n#include \"base/metrics/sparse_histogram.h\"\n#include \"base/stl_util.h\"\n#include \"base/strings/string_number_conversions.h\"\n#include \"base/strings/string_util.h\"\n#include \"base/time/time.h\"\n#include \"base/values.h\"\n#include \"build/build_config.h\"\n#include \"net/base/auth.h\"\n#include \"net/base/host_port_pair.h\"\n#include \"net/base/io_buffer.h\"\n#include \"net/base/load_flags.h\"\n#include \"net/base/load_timing_info.h\"\n#include \"net/base/net_errors.h\"\n#include \"net/base/proxy_server.h\"\n#include \"net/base/upload_data_stream.h\"\n#include \"net/base/url_util.h\"\n#include \"net/cert/cert_status_flags.h\"\n#include \"net/filter/filter_source_stream.h\"\n#include \"net/http/bidirectional_stream_impl.h\"\n#include \"net/http/http_auth.h\"\n#include \"net/http/http_auth_handler.h\"\n#include \"net/http/http_auth_handler_factory.h\"\n#include \"net/http/http_basic_stream.h\"\n#include \"net/http/http_chunked_decoder.h\"\n#include \"net/http/http_network_session.h\"\n#include \"net/http/http_proxy_client_socket.h\"\n#include \"net/http/http_proxy_client_socket_pool.h\"\n#include \"net/http/http_request_headers.h\"\n#include \"net/http/http_request_info.h\"\n#include \"net/http/http_response_headers.h\"\n#include \"net/http/http_response_info.h\"\n#include \"net/http/http_server_properties.h\"\n#include \"net/http/http_status_code.h\"\n#include \"net/http/http_stream.h\"\n#include \"net/http/http_stream_factory.h\"\n#include \"net/http/http_util.h\"\n#include \"net/http/transport_security_state.h\"\n#include \"net/http/url_security_manager.h\"\n#include \"net/log/net_log_event_type.h\"\n#include \"net/socket/client_socket_factory.h\"\n#include \"net/socket/next_proto.h\"\n#include \"net/socket/socks_client_socket_pool.h\"\n#include \"net/socket/transport_client_socket_pool.h\"\n#include \"net/spdy/spdy_http_stream.h\"\n#include \"net/spdy/spdy_session.h\"\n#include \"net/spdy/spdy_session_pool.h\"\n#include \"net/ssl/ssl_cert_request_info.h\"\n#include \"net/ssl/ssl_connection_status_flags.h\"\n#include \"net/ssl/ssl_info.h\"\n#include \"net/ssl/ssl_private_key.h\"\n#include \"net/ssl/token_binding.h\"\n#include \"url/gurl.h\"\n#include \"url/url_canon.h\"\n\nnamespace {\n\n// Max number of |retry_attempts| (excluding the initial request) after which\n// we give up and show an error page.\nconst size_t kMaxRetryAttempts = 2;\n\n// Max number of calls to RestartWith* allowed for a single connection. A single\n// HttpNetworkTransaction should not signal very many restartable errors, but it\n// may occur due to a bug (e.g. https://crbug.com/823387 or\n// https://crbug.com/488043) or simply if the server or proxy requests\n// authentication repeatedly. Although these calls are often associated with a\n// user prompt, in other scenarios (remembered preferences, extensions,\n// multi-leg authentication), they may be triggered automatically. To avoid\n// looping forever, bound the number of restarts.\nconst size_t kMaxRestarts = 32;\n\n}  // namespace\n\nnamespace net {\n\nHttpNetworkTransaction::HttpNetworkTransaction(RequestPriority priority,\n                                               HttpNetworkSession* session)\n    : pending_auth_target_(HttpAuth::AUTH_NONE),\n      io_callback_(base::BindRepeating(&HttpNetworkTransaction::OnIOComplete,\n                                       base::Unretained(this))),\n      session_(session),\n      request_(NULL),\n      priority_(priority),\n      headers_valid_(false),\n      can_send_early_data_(false),\n      server_ssl_client_cert_was_cached_(false),\n      request_headers_(),\n      read_buf_len_(0),\n      total_received_bytes_(0),\n      total_sent_bytes_(0),\n      next_state_(STATE_NONE),\n      establishing_tunnel_(false),\n      enable_ip_based_pooling_(true),\n      enable_alternative_services_(true),\n      websocket_handshake_stream_base_create_helper_(NULL),\n      net_error_details_(),\n      retry_attempts_(0),\n      num_restarts_(0),\n      ssl_version_interference_error_(OK) {}\n\nHttpNetworkTransaction::~HttpNetworkTransaction() {\n  if (stream_.get()) {\n    // TODO(mbelshe): The stream_ should be able to compute whether or not the\n    //                stream should be kept alive.  No reason to compute here\n    //                and pass it in.\n    if (!stream_->CanReuseConnection() || next_state_ != STATE_NONE) {\n      stream_->Close(true /* not reusable */);\n    } else if (stream_->IsResponseBodyComplete()) {\n      // If the response body is complete, we can just reuse the socket.\n      stream_->Close(false /* reusable */);\n    } else {\n      // Otherwise, we try to drain the response body.\n      HttpStream* stream = stream_.release();\n      stream->Drain(session_);\n    }\n  }\n  if (request_ && request_->upload_data_stream)\n    request_->upload_data_stream->Reset();  // Invalidate pending callbacks.\n}\n\nint HttpNetworkTransaction::Start(const HttpRequestInfo* request_info,\n                                  const CompletionCallback& callback,\n                                  const NetLogWithSource& net_log) {\n  DCHECK(request_info->traffic_annotation.is_valid());\n  net_log_ = net_log;\n  request_ = request_info;\n  url_ = request_->url;\n\n  // Now that we have an HttpRequestInfo object, update server_ssl_config_.\n  session_->GetSSLConfig(*request_, &server_ssl_config_, &proxy_ssl_config_);\n\n  if (request_->load_flags & LOAD_DISABLE_CERT_REVOCATION_CHECKING) {\n    server_ssl_config_.rev_checking_enabled = false;\n    proxy_ssl_config_.rev_checking_enabled = false;\n  }\n\n  if (HttpUtil::IsMethodSafe(request_info->method)) {\n    can_send_early_data_ = true;\n  }\n\n  if (request_->load_flags & LOAD_PREFETCH)\n    response_.unused_since_prefetch = true;\n\n  next_state_ = STATE_NOTIFY_BEFORE_CREATE_STREAM;\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nint HttpNetworkTransaction::RestartIgnoringLastError(\n    const CompletionCallback& callback) {\n  DCHECK(!stream_.get());\n  DCHECK(!stream_request_.get());\n  DCHECK_EQ(STATE_NONE, next_state_);\n\n  if (!CheckMaxRestarts())\n    return ERR_TOO_MANY_RETRIES;\n\n  next_state_ = STATE_CREATE_STREAM;\n\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nint HttpNetworkTransaction::RestartWithCertificate(\n    scoped_refptr<X509Certificate> client_cert,\n    scoped_refptr<SSLPrivateKey> client_private_key,\n    const CompletionCallback& callback) {\n  // In HandleCertificateRequest(), we always tear down existing stream\n  // requests to force a new connection.  So we shouldn't have one here.\n  DCHECK(!stream_request_.get());\n  DCHECK(!stream_.get());\n  DCHECK_EQ(STATE_NONE, next_state_);\n\n  if (!CheckMaxRestarts())\n    return ERR_TOO_MANY_RETRIES;\n\n  SSLConfig* ssl_config = response_.cert_request_info->is_proxy ?\n      &proxy_ssl_config_ : &server_ssl_config_;\n  ssl_config->send_client_cert = true;\n  ssl_config->client_cert = client_cert;\n  ssl_config->client_private_key = client_private_key;\n  session_->ssl_client_auth_cache()->Add(\n      response_.cert_request_info->host_and_port, std::move(client_cert),\n      std::move(client_private_key));\n  // Reset the other member variables.\n  // Note: this is necessary only with SSL renegotiation.\n  ResetStateForRestart();\n  next_state_ = STATE_CREATE_STREAM;\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nint HttpNetworkTransaction::RestartWithAuth(\n    const AuthCredentials& credentials, const CompletionCallback& callback) {\n  if (!CheckMaxRestarts())\n    return ERR_TOO_MANY_RETRIES;\n\n  HttpAuth::Target target = pending_auth_target_;\n  if (target == HttpAuth::AUTH_NONE) {\n    NOTREACHED();\n    return ERR_UNEXPECTED;\n  }\n  pending_auth_target_ = HttpAuth::AUTH_NONE;\n\n  auth_controllers_[target]->ResetAuth(credentials);\n\n  DCHECK(callback_.is_null());\n\n  int rv = OK;\n  if (target == HttpAuth::AUTH_PROXY && establishing_tunnel_) {\n    // In this case, we've gathered credentials for use with proxy\n    // authentication of a tunnel.\n    DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n    DCHECK(stream_request_ != NULL);\n    auth_controllers_[target] = NULL;\n    ResetStateForRestart();\n    rv = stream_request_->RestartTunnelWithProxyAuth();\n  } else {\n    // In this case, we've gathered credentials for the server or the proxy\n    // but it is not during the tunneling phase.\n    DCHECK(stream_request_ == NULL);\n    PrepareForAuthRestart(target);\n    rv = DoLoop(OK);\n  }\n\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nvoid HttpNetworkTransaction::PrepareForAuthRestart(HttpAuth::Target target) {\n  DCHECK(HaveAuth(target));\n  DCHECK(!stream_request_.get());\n\n  // Authorization schemes incompatible with HTTP/2 are unsupported for proxies.\n  if (target == HttpAuth::AUTH_SERVER &&\n      auth_controllers_[target]->NeedsHTTP11()) {\n    session_->http_server_properties()->SetHTTP11Required(\n        HostPortPair::FromURL(request_->url));\n  }\n\n  bool keep_alive = false;\n  // Even if the server says the connection is keep-alive, we have to be\n  // able to find the end of each response in order to reuse the connection.\n  if (stream_->CanReuseConnection()) {\n    // If the response body hasn't been completely read, we need to drain\n    // it first.\n    if (!stream_->IsResponseBodyComplete()) {\n      next_state_ = STATE_DRAIN_BODY_FOR_AUTH_RESTART;\n      read_buf_ = new IOBuffer(kDrainBodyBufferSize);  // A bit bucket.\n      read_buf_len_ = kDrainBodyBufferSize;\n      return;\n    }\n    keep_alive = true;\n  }\n\n  // We don't need to drain the response body, so we act as if we had drained\n  // the response body.\n  DidDrainBodyForAuthRestart(keep_alive);\n}\n\nvoid HttpNetworkTransaction::DidDrainBodyForAuthRestart(bool keep_alive) {\n  DCHECK(!stream_request_.get());\n\n  if (stream_.get()) {\n    total_received_bytes_ += stream_->GetTotalReceivedBytes();\n    total_sent_bytes_ += stream_->GetTotalSentBytes();\n    HttpStream* new_stream = NULL;\n    if (keep_alive && stream_->CanReuseConnection()) {\n      // We should call connection_->set_idle_time(), but this doesn't occur\n      // often enough to be worth the trouble.\n      stream_->SetConnectionReused();\n      new_stream = stream_->RenewStreamForAuth();\n    }\n\n    if (!new_stream) {\n      // Close the stream and mark it as not_reusable.  Even in the\n      // keep_alive case, we've determined that the stream_ is not\n      // reusable if new_stream is NULL.\n      stream_->Close(true);\n      next_state_ = STATE_CREATE_STREAM;\n    } else {\n      // Renewed streams shouldn't carry over sent or received bytes.\n      DCHECK_EQ(0, new_stream->GetTotalReceivedBytes());\n      DCHECK_EQ(0, new_stream->GetTotalSentBytes());\n      next_state_ = STATE_INIT_STREAM;\n    }\n    stream_.reset(new_stream);\n  }\n\n  // Reset the other member variables.\n  ResetStateForAuthRestart();\n}\n\nbool HttpNetworkTransaction::IsReadyToRestartForAuth() {\n  return pending_auth_target_ != HttpAuth::AUTH_NONE &&\n      HaveAuth(pending_auth_target_);\n}\n\nint HttpNetworkTransaction::Read(IOBuffer* buf, int buf_len,\n                                 const CompletionCallback& callback) {\n  DCHECK(buf);\n  DCHECK_LT(0, buf_len);\n\n  scoped_refptr<HttpResponseHeaders> headers(GetResponseHeaders());\n  if (headers_valid_ && headers.get() && stream_request_.get()) {\n    // We're trying to read the body of the response but we're still trying\n    // to establish an SSL tunnel through an HTTP proxy.  We can't read these\n    // bytes when establishing a tunnel because they might be controlled by\n    // an active network attacker.  We don't worry about this for HTTP\n    // because an active network attacker can already control HTTP sessions.\n    // We reach this case when the user cancels a 407 proxy auth prompt.  We\n    // also don't worry about this for an HTTPS Proxy, because the\n    // communication with the proxy is secure.\n    // See http://crbug.com/8473.\n    DCHECK(proxy_info_.is_http() || proxy_info_.is_https() ||\n           proxy_info_.is_quic());\n    DCHECK_EQ(headers->response_code(), HTTP_PROXY_AUTHENTICATION_REQUIRED);\n    LOG(WARNING) << \"Blocked proxy response with status \"\n                 << headers->response_code() << \" to CONNECT request for \"\n                 << GetHostAndPort(url_) << \".\";\n    return ERR_TUNNEL_CONNECTION_FAILED;\n  }\n\n  // Are we using SPDY or HTTP?\n  next_state_ = STATE_READ_BODY;\n\n  read_buf_ = buf;\n  read_buf_len_ = buf_len;\n\n  int rv = DoLoop(OK);\n  if (rv == ERR_IO_PENDING)\n    callback_ = callback;\n  return rv;\n}\n\nvoid HttpNetworkTransaction::StopCaching() {}\n\nbool HttpNetworkTransaction::GetFullRequestHeaders(\n    HttpRequestHeaders* headers) const {\n  // TODO(juliatuttle): Make sure we've populated request_headers_.\n  *headers = request_headers_;\n  return true;\n}\n\nint64_t HttpNetworkTransaction::GetTotalReceivedBytes() const {\n  int64_t total_received_bytes = total_received_bytes_;\n  if (stream_)\n    total_received_bytes += stream_->GetTotalReceivedBytes();\n  return total_received_bytes;\n}\n\nint64_t HttpNetworkTransaction::GetTotalSentBytes() const {\n  int64_t total_sent_bytes = total_sent_bytes_;\n  if (stream_)\n    total_sent_bytes += stream_->GetTotalSentBytes();\n  return total_sent_bytes;\n}\n\nvoid HttpNetworkTransaction::DoneReading() {}\n\nconst HttpResponseInfo* HttpNetworkTransaction::GetResponseInfo() const {\n  return &response_;\n}\n\nLoadState HttpNetworkTransaction::GetLoadState() const {\n  // TODO(wtc): Define a new LoadState value for the\n  // STATE_INIT_CONNECTION_COMPLETE state, which delays the HTTP request.\n  switch (next_state_) {\n    case STATE_CREATE_STREAM:\n      return LOAD_STATE_WAITING_FOR_DELEGATE;\n    case STATE_CREATE_STREAM_COMPLETE:\n      return stream_request_->GetLoadState();\n    case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:\n    case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:\n    case STATE_SEND_REQUEST_COMPLETE:\n      return LOAD_STATE_SENDING_REQUEST;\n    case STATE_READ_HEADERS_COMPLETE:\n      return LOAD_STATE_WAITING_FOR_RESPONSE;\n    case STATE_READ_BODY_COMPLETE:\n      return LOAD_STATE_READING_RESPONSE;\n    default:\n      return LOAD_STATE_IDLE;\n  }\n}\n\nvoid HttpNetworkTransaction::SetQuicServerInfo(\n    QuicServerInfo* quic_server_info) {}\n\nbool HttpNetworkTransaction::GetLoadTimingInfo(\n    LoadTimingInfo* load_timing_info) const {\n  if (!stream_ || !stream_->GetLoadTimingInfo(load_timing_info))\n    return false;\n\n  load_timing_info->proxy_resolve_start =\n      proxy_info_.proxy_resolve_start_time();\n  load_timing_info->proxy_resolve_end = proxy_info_.proxy_resolve_end_time();\n  load_timing_info->send_start = send_start_time_;\n  load_timing_info->send_end = send_end_time_;\n  return true;\n}\n\nbool HttpNetworkTransaction::GetRemoteEndpoint(IPEndPoint* endpoint) const {\n  if (remote_endpoint_.address().empty())\n    return false;\n\n  *endpoint = remote_endpoint_;\n  return true;\n}\n\nvoid HttpNetworkTransaction::PopulateNetErrorDetails(\n    NetErrorDetails* details) const {\n  *details = net_error_details_;\n  if (stream_)\n    stream_->PopulateNetErrorDetails(details);\n}\n\nvoid HttpNetworkTransaction::SetPriority(RequestPriority priority) {\n  priority_ = priority;\n\n  if (stream_request_)\n    stream_request_->SetPriority(priority);\n  if (stream_)\n    stream_->SetPriority(priority);\n\n  // The above call may have resulted in deleting |*this|.\n}\n\nvoid HttpNetworkTransaction::SetWebSocketHandshakeStreamCreateHelper(\n    WebSocketHandshakeStreamBase::CreateHelper* create_helper) {\n  websocket_handshake_stream_base_create_helper_ = create_helper;\n}\n\nvoid HttpNetworkTransaction::SetBeforeNetworkStartCallback(\n    const BeforeNetworkStartCallback& callback) {\n  before_network_start_callback_ = callback;\n}\n\nvoid HttpNetworkTransaction::SetBeforeHeadersSentCallback(\n    const BeforeHeadersSentCallback& callback) {\n  before_headers_sent_callback_ = callback;\n}\n\nvoid HttpNetworkTransaction::SetRequestHeadersCallback(\n    RequestHeadersCallback callback) {\n  DCHECK(!stream_);\n  request_headers_callback_ = std::move(callback);\n}\n\nvoid HttpNetworkTransaction::SetResponseHeadersCallback(\n    ResponseHeadersCallback callback) {\n  DCHECK(!stream_);\n  response_headers_callback_ = std::move(callback);\n}\n\nint HttpNetworkTransaction::ResumeNetworkStart() {\n  DCHECK_EQ(next_state_, STATE_CREATE_STREAM);\n  return DoLoop(OK);\n}\n\nvoid HttpNetworkTransaction::OnStreamReady(const SSLConfig& used_ssl_config,\n                                           const ProxyInfo& used_proxy_info,\n                                           std::unique_ptr<HttpStream> stream) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n  DCHECK(stream_request_.get());\n\n  if (stream_) {\n    total_received_bytes_ += stream_->GetTotalReceivedBytes();\n    total_sent_bytes_ += stream_->GetTotalSentBytes();\n  }\n  stream_ = std::move(stream);\n  stream_->SetRequestHeadersCallback(request_headers_callback_);\n  server_ssl_config_ = used_ssl_config;\n  proxy_info_ = used_proxy_info;\n  response_.was_alpn_negotiated = stream_request_->was_alpn_negotiated();\n  response_.alpn_negotiated_protocol =\n      NextProtoToString(stream_request_->negotiated_protocol());\n  response_.was_fetched_via_spdy = stream_request_->using_spdy();\n  response_.was_fetched_via_proxy = !proxy_info_.is_direct();\n  if (response_.was_fetched_via_proxy && !proxy_info_.is_empty())\n    response_.proxy_server = proxy_info_.proxy_server();\n  else if (!response_.was_fetched_via_proxy && proxy_info_.is_direct())\n    response_.proxy_server = ProxyServer::Direct();\n  else\n    response_.proxy_server = ProxyServer();\n  OnIOComplete(OK);\n}\n\nvoid HttpNetworkTransaction::OnBidirectionalStreamImplReady(\n    const SSLConfig& used_ssl_config,\n    const ProxyInfo& used_proxy_info,\n    std::unique_ptr<BidirectionalStreamImpl> stream) {\n  NOTREACHED();\n}\n\nvoid HttpNetworkTransaction::OnWebSocketHandshakeStreamReady(\n    const SSLConfig& used_ssl_config,\n    const ProxyInfo& used_proxy_info,\n    std::unique_ptr<WebSocketHandshakeStreamBase> stream) {\n  OnStreamReady(used_ssl_config, used_proxy_info, std::move(stream));\n}\n\nvoid HttpNetworkTransaction::OnStreamFailed(\n    int result,\n    const NetErrorDetails& net_error_details,\n    const SSLConfig& used_ssl_config) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n  DCHECK_NE(OK, result);\n  DCHECK(stream_request_.get());\n  DCHECK(!stream_.get());\n  server_ssl_config_ = used_ssl_config;\n  net_error_details_ = net_error_details;\n\n  OnIOComplete(result);\n}\n\nvoid HttpNetworkTransaction::OnCertificateError(\n    int result,\n    const SSLConfig& used_ssl_config,\n    const SSLInfo& ssl_info) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n  DCHECK_NE(OK, result);\n  DCHECK(stream_request_.get());\n  DCHECK(!stream_.get());\n\n  response_.ssl_info = ssl_info;\n  server_ssl_config_ = used_ssl_config;\n\n  // TODO(mbelshe):  For now, we're going to pass the error through, and that\n  // will close the stream_request in all cases.  This means that we're always\n  // going to restart an entire STATE_CREATE_STREAM, even if the connection is\n  // good and the user chooses to ignore the error.  This is not ideal, but not\n  // the end of the world either.\n\n  OnIOComplete(result);\n}\n\nvoid HttpNetworkTransaction::OnNeedsProxyAuth(\n    const HttpResponseInfo& proxy_response,\n    const SSLConfig& used_ssl_config,\n    const ProxyInfo& used_proxy_info,\n    HttpAuthController* auth_controller) {\n  DCHECK(stream_request_.get());\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n\n  establishing_tunnel_ = true;\n  response_.headers = proxy_response.headers;\n  response_.auth_challenge = proxy_response.auth_challenge;\n\n  if (response_.headers.get() && !ContentEncodingsValid()) {\n    DoCallback(ERR_CONTENT_DECODING_FAILED);\n    return;\n  }\n\n  headers_valid_ = true;\n  server_ssl_config_ = used_ssl_config;\n  proxy_info_ = used_proxy_info;\n\n  auth_controllers_[HttpAuth::AUTH_PROXY] = auth_controller;\n  pending_auth_target_ = HttpAuth::AUTH_PROXY;\n\n  DoCallback(OK);\n}\n\nvoid HttpNetworkTransaction::OnNeedsClientAuth(\n    const SSLConfig& used_ssl_config,\n    SSLCertRequestInfo* cert_info) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n\n  server_ssl_config_ = used_ssl_config;\n  response_.cert_request_info = cert_info;\n  OnIOComplete(ERR_SSL_CLIENT_AUTH_CERT_NEEDED);\n}\n\nvoid HttpNetworkTransaction::OnHttpsProxyTunnelResponse(\n    const HttpResponseInfo& response_info,\n    const SSLConfig& used_ssl_config,\n    const ProxyInfo& used_proxy_info,\n    std::unique_ptr<HttpStream> stream) {\n  DCHECK_EQ(STATE_CREATE_STREAM_COMPLETE, next_state_);\n\n  CopyConnectionAttemptsFromStreamRequest();\n\n  headers_valid_ = true;\n  response_ = response_info;\n  server_ssl_config_ = used_ssl_config;\n  proxy_info_ = used_proxy_info;\n  if (stream_) {\n    total_received_bytes_ += stream_->GetTotalReceivedBytes();\n    total_sent_bytes_ += stream_->GetTotalSentBytes();\n  }\n  stream_ = std::move(stream);\n  stream_->SetRequestHeadersCallback(request_headers_callback_);\n  stream_request_.reset();  // we're done with the stream request\n  OnIOComplete(ERR_HTTPS_PROXY_TUNNEL_RESPONSE);\n}\n\nvoid HttpNetworkTransaction::OnQuicBroken() {\n  net_error_details_.quic_broken = true;\n}\n\nvoid HttpNetworkTransaction::GetConnectionAttempts(\n    ConnectionAttempts* out) const {\n  *out = connection_attempts_;\n}\n\nbool HttpNetworkTransaction::IsSecureRequest() const {\n  return request_->url.SchemeIsCryptographic();\n}\n\nbool HttpNetworkTransaction::IsTokenBindingEnabled() const {\n  if (!IsSecureRequest())\n    return false;\n  SSLInfo ssl_info;\n  stream_->GetSSLInfo(&ssl_info);\n  return ssl_info.token_binding_negotiated &&\n         ssl_info.token_binding_key_param == TB_PARAM_ECDSAP256 &&\n         session_->context().channel_id_service;\n}\n\nvoid HttpNetworkTransaction::RecordTokenBindingSupport() const {\n  // This enum is used for an UMA histogram - do not change or re-use values.\n  enum {\n    DISABLED = 0,\n    CLIENT_ONLY = 1,\n    CLIENT_AND_SERVER = 2,\n    CLIENT_NO_CHANNEL_ID_SERVICE = 3,\n    TOKEN_BINDING_SUPPORT_MAX\n  } supported;\n  if (!IsSecureRequest())\n    return;\n  SSLInfo ssl_info;\n  stream_->GetSSLInfo(&ssl_info);\n  if (!session_->params().enable_token_binding) {\n    supported = DISABLED;\n  } else if (!session_->context().channel_id_service) {\n    supported = CLIENT_NO_CHANNEL_ID_SERVICE;\n  } else if (ssl_info.token_binding_negotiated) {\n    supported = CLIENT_AND_SERVER;\n  } else {\n    supported = CLIENT_ONLY;\n  }\n  UMA_HISTOGRAM_ENUMERATION(\"Net.TokenBinding.Support\", supported,\n                            TOKEN_BINDING_SUPPORT_MAX);\n}\n\nbool HttpNetworkTransaction::UsingHttpProxyWithoutTunnel() const {\n  return (proxy_info_.is_http() || proxy_info_.is_https() ||\n          proxy_info_.is_quic()) &&\n         !(request_->url.SchemeIs(\"https\") || request_->url.SchemeIsWSOrWSS());\n}\n\nvoid HttpNetworkTransaction::DoCallback(int rv) {\n  DCHECK_NE(rv, ERR_IO_PENDING);\n  DCHECK(!callback_.is_null());\n\n  // Since Run may result in Read being called, clear user_callback_ up front.\n  base::ResetAndReturn(&callback_).Run(rv);\n}\n\nvoid HttpNetworkTransaction::OnIOComplete(int result) {\n  int rv = DoLoop(result);\n  if (rv != ERR_IO_PENDING)\n    DoCallback(rv);\n}\n\nint HttpNetworkTransaction::DoLoop(int result) {\n  DCHECK(next_state_ != STATE_NONE);\n\n  int rv = result;\n  do {\n    State state = next_state_;\n    next_state_ = STATE_NONE;\n    switch (state) {\n      case STATE_NOTIFY_BEFORE_CREATE_STREAM:\n        DCHECK_EQ(OK, rv);\n        rv = DoNotifyBeforeCreateStream();\n        break;\n      case STATE_CREATE_STREAM:\n        DCHECK_EQ(OK, rv);\n        rv = DoCreateStream();\n        break;\n      case STATE_CREATE_STREAM_COMPLETE:\n        // TODO(zhongyi): remove liveness checks when crbug.com/652868 is\n        // solved.\n        net_log_.CrashIfInvalid();\n        rv = DoCreateStreamComplete(rv);\n        net_log_.CrashIfInvalid();\n        break;\n      case STATE_INIT_STREAM:\n        DCHECK_EQ(OK, rv);\n        rv = DoInitStream();\n        break;\n      case STATE_INIT_STREAM_COMPLETE:\n        rv = DoInitStreamComplete(rv);\n        break;\n      case STATE_GENERATE_PROXY_AUTH_TOKEN:\n        DCHECK_EQ(OK, rv);\n        rv = DoGenerateProxyAuthToken();\n        break;\n      case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:\n        rv = DoGenerateProxyAuthTokenComplete(rv);\n        break;\n      case STATE_GENERATE_SERVER_AUTH_TOKEN:\n        DCHECK_EQ(OK, rv);\n        rv = DoGenerateServerAuthToken();\n        break;\n      case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE:\n        rv = DoGenerateServerAuthTokenComplete(rv);\n        break;\n      case STATE_GET_PROVIDED_TOKEN_BINDING_KEY:\n        DCHECK_EQ(OK, rv);\n        rv = DoGetProvidedTokenBindingKey();\n        break;\n      case STATE_GET_PROVIDED_TOKEN_BINDING_KEY_COMPLETE:\n        rv = DoGetProvidedTokenBindingKeyComplete(rv);\n        break;\n      case STATE_GET_REFERRED_TOKEN_BINDING_KEY:\n        DCHECK_EQ(OK, rv);\n        rv = DoGetReferredTokenBindingKey();\n        break;\n      case STATE_GET_REFERRED_TOKEN_BINDING_KEY_COMPLETE:\n        rv = DoGetReferredTokenBindingKeyComplete(rv);\n        break;\n      case STATE_INIT_REQUEST_BODY:\n        DCHECK_EQ(OK, rv);\n        rv = DoInitRequestBody();\n        break;\n      case STATE_INIT_REQUEST_BODY_COMPLETE:\n        rv = DoInitRequestBodyComplete(rv);\n        break;\n      case STATE_BUILD_REQUEST:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_SEND_REQUEST);\n        rv = DoBuildRequest();\n        break;\n      case STATE_BUILD_REQUEST_COMPLETE:\n        rv = DoBuildRequestComplete(rv);\n        break;\n      case STATE_SEND_REQUEST:\n        DCHECK_EQ(OK, rv);\n        rv = DoSendRequest();\n        break;\n      case STATE_SEND_REQUEST_COMPLETE:\n        rv = DoSendRequestComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_SEND_REQUEST, rv);\n        break;\n      case STATE_READ_HEADERS:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_READ_HEADERS);\n        rv = DoReadHeaders();\n        break;\n      case STATE_READ_HEADERS_COMPLETE:\n        rv = DoReadHeadersComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_READ_HEADERS, rv);\n        break;\n      case STATE_READ_BODY:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_READ_BODY);\n        rv = DoReadBody();\n        break;\n      case STATE_READ_BODY_COMPLETE:\n        rv = DoReadBodyComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_READ_BODY, rv);\n        break;\n      case STATE_DRAIN_BODY_FOR_AUTH_RESTART:\n        DCHECK_EQ(OK, rv);\n        net_log_.BeginEvent(\n            NetLogEventType::HTTP_TRANSACTION_DRAIN_BODY_FOR_AUTH_RESTART);\n        rv = DoDrainBodyForAuthRestart();\n        break;\n      case STATE_DRAIN_BODY_FOR_AUTH_RESTART_COMPLETE:\n        rv = DoDrainBodyForAuthRestartComplete(rv);\n        net_log_.EndEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_DRAIN_BODY_FOR_AUTH_RESTART, rv);\n        break;\n      default:\n        NOTREACHED() << \"bad state\";\n        rv = ERR_FAILED;\n        break;\n    }\n  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);\n\n  return rv;\n}\n\nint HttpNetworkTransaction::DoNotifyBeforeCreateStream() {\n  next_state_ = STATE_CREATE_STREAM;\n  bool defer = false;\n  if (!before_network_start_callback_.is_null())\n    before_network_start_callback_.Run(&defer);\n  if (!defer)\n    return OK;\n  return ERR_IO_PENDING;\n}\n\nint HttpNetworkTransaction::DoCreateStream() {\n  response_.network_accessed = true;\n\n  next_state_ = STATE_CREATE_STREAM_COMPLETE;\n  // IP based pooling is only enabled on a retry after 421 Misdirected Request\n  // is received. Alternative Services are also disabled in this case (though\n  // they can also be disabled when retrying after a QUIC error).\n  if (!enable_ip_based_pooling_)\n    DCHECK(!enable_alternative_services_);\n  if (ForWebSocketHandshake()) {\n    stream_request_ =\n        session_->http_stream_factory()->RequestWebSocketHandshakeStream(\n            *request_, priority_, server_ssl_config_, proxy_ssl_config_, this,\n            websocket_handshake_stream_base_create_helper_,\n            enable_ip_based_pooling_, enable_alternative_services_, net_log_);\n  } else {\n    stream_request_ = session_->http_stream_factory()->RequestStream(\n        *request_, priority_, server_ssl_config_, proxy_ssl_config_, this,\n        enable_ip_based_pooling_, enable_alternative_services_, net_log_);\n  }\n  DCHECK(stream_request_.get());\n  return ERR_IO_PENDING;\n}\n\nint HttpNetworkTransaction::DoCreateStreamComplete(int result) {\n  // Version interference probes should not result in success.\n  DCHECK(!server_ssl_config_.version_interference_probe || result != OK);\n\n  // If |result| is ERR_HTTPS_PROXY_TUNNEL_RESPONSE, then\n  // DoCreateStreamComplete is being called from OnHttpsProxyTunnelResponse,\n  // which resets the stream request first. Therefore, we have to grab the\n  // connection attempts in *that* function instead of here in that case.\n  if (result != ERR_HTTPS_PROXY_TUNNEL_RESPONSE)\n    CopyConnectionAttemptsFromStreamRequest();\n\n  if (result == OK) {\n    next_state_ = STATE_INIT_STREAM;\n    DCHECK(stream_.get());\n  } else if (result == ERR_SSL_CLIENT_AUTH_CERT_NEEDED) {\n    result = HandleCertificateRequest(result);\n  } else if (result == ERR_HTTPS_PROXY_TUNNEL_RESPONSE) {\n    // Return OK and let the caller read the proxy's error page\n    next_state_ = STATE_NONE;\n    return OK;\n  } else if (result == ERR_HTTP_1_1_REQUIRED ||\n             result == ERR_PROXY_HTTP_1_1_REQUIRED) {\n    return HandleHttp11Required(result);\n  }\n\n  // Perform a TLS 1.3 version interference probe on various connection\n  // errors. The retry will never produce a successful connection but may map\n  // errors to ERR_SSL_VERSION_INTERFERENCE, which signals a probable\n  // version-interfering middlebox.\n  if (IsSecureRequest() && !HasExceededMaxRetries() &&\n      server_ssl_config_.version_max == SSL_PROTOCOL_VERSION_TLS1_3 &&\n      !server_ssl_config_.version_interference_probe) {\n    if (result == ERR_CONNECTION_CLOSED || result == ERR_SSL_PROTOCOL_ERROR ||\n        result == ERR_SSL_VERSION_OR_CIPHER_MISMATCH ||\n        result == ERR_CONNECTION_RESET ||\n        result == ERR_SSL_BAD_RECORD_MAC_ALERT) {\n      // Report the error code for each time a version interference probe is\n      // triggered.\n      base::UmaHistogramSparse(\"Net.SSLVersionInterferenceProbeTrigger\",\n                               std::abs(result));\n      net_log_.AddEventWithNetErrorCode(\n          NetLogEventType::SSL_VERSION_INTERFERENCE_PROBE, result);\n\n      retry_attempts_++;\n      server_ssl_config_.version_interference_probe = true;\n      server_ssl_config_.version_max = SSL_PROTOCOL_VERSION_TLS1_2;\n      ssl_version_interference_error_ = result;\n      ResetConnectionAndRequestForResend();\n      return OK;\n    }\n  }\n\n  if (result == ERR_SSL_VERSION_INTERFERENCE) {\n    // Record the error code version interference was detected at.\n    DCHECK(server_ssl_config_.version_interference_probe);\n    DCHECK_NE(OK, ssl_version_interference_error_);\n    base::UmaHistogramSparse(\"Net.SSLVersionInterferenceError\",\n                             std::abs(ssl_version_interference_error_));\n  }\n\n  // Handle possible client certificate errors that may have occurred if the\n  // stream used SSL for one or more of the layers.\n  result = HandleSSLClientAuthError(result);\n\n  // At this point we are done with the stream_request_.\n  stream_request_.reset();\n  return result;\n}\n\nint HttpNetworkTransaction::DoInitStream() {\n  DCHECK(stream_.get());\n  next_state_ = STATE_INIT_STREAM_COMPLETE;\n\n  stream_->GetRemoteEndpoint(&remote_endpoint_);\n\n  return stream_->InitializeStream(request_, can_send_early_data_, priority_,\n                                   net_log_, io_callback_);\n}\n\nint HttpNetworkTransaction::DoInitStreamComplete(int result) {\n  if (result == OK) {\n    next_state_ = STATE_GENERATE_PROXY_AUTH_TOKEN;\n  } else {\n    if (result < 0)\n      result = HandleIOError(result);\n\n    // The stream initialization failed, so this stream will never be useful.\n    if (stream_) {\n      total_received_bytes_ += stream_->GetTotalReceivedBytes();\n      total_sent_bytes_ += stream_->GetTotalSentBytes();\n    }\n    CacheNetErrorDetailsAndResetStream();\n  }\n\n  return result;\n}\n\nint HttpNetworkTransaction::DoGenerateProxyAuthToken() {\n  next_state_ = STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE;\n  if (!ShouldApplyProxyAuth())\n    return OK;\n  HttpAuth::Target target = HttpAuth::AUTH_PROXY;\n  if (!auth_controllers_[target].get())\n    auth_controllers_[target] =\n        new HttpAuthController(target,\n                               AuthURL(target),\n                               session_->http_auth_cache(),\n                               session_->http_auth_handler_factory());\n  return auth_controllers_[target]->MaybeGenerateAuthToken(request_,\n                                                           io_callback_,\n                                                           net_log_);\n}\n\nint HttpNetworkTransaction::DoGenerateProxyAuthTokenComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (rv == OK)\n    next_state_ = STATE_GENERATE_SERVER_AUTH_TOKEN;\n  return rv;\n}\n\nint HttpNetworkTransaction::DoGenerateServerAuthToken() {\n  next_state_ = STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE;\n  HttpAuth::Target target = HttpAuth::AUTH_SERVER;\n  if (!auth_controllers_[target].get()) {\n    auth_controllers_[target] =\n        new HttpAuthController(target,\n                               AuthURL(target),\n                               session_->http_auth_cache(),\n                               session_->http_auth_handler_factory());\n    if (request_->load_flags & LOAD_DO_NOT_USE_EMBEDDED_IDENTITY)\n      auth_controllers_[target]->DisableEmbeddedIdentity();\n  }\n  if (!ShouldApplyServerAuth())\n    return OK;\n  return auth_controllers_[target]->MaybeGenerateAuthToken(request_,\n                                                           io_callback_,\n                                                           net_log_);\n}\n\nint HttpNetworkTransaction::DoGenerateServerAuthTokenComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (rv == OK)\n    next_state_ = STATE_GET_PROVIDED_TOKEN_BINDING_KEY;\n  return rv;\n}\n\nint HttpNetworkTransaction::DoGetProvidedTokenBindingKey() {\n  next_state_ = STATE_GET_PROVIDED_TOKEN_BINDING_KEY_COMPLETE;\n  if (!IsTokenBindingEnabled())\n    return OK;\n\n  net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY);\n  ChannelIDService* channel_id_service = session_->context().channel_id_service;\n  return channel_id_service->GetOrCreateChannelID(\n      request_->url.host(), &provided_token_binding_key_, io_callback_,\n      &token_binding_request_);\n}\n\nint HttpNetworkTransaction::DoGetProvidedTokenBindingKeyComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (IsTokenBindingEnabled()) {\n    net_log_.EndEventWithNetErrorCode(\n        NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY, rv);\n  }\n\n  if (rv == OK)\n    next_state_ = STATE_GET_REFERRED_TOKEN_BINDING_KEY;\n  return rv;\n}\n\nint HttpNetworkTransaction::DoGetReferredTokenBindingKey() {\n  next_state_ = STATE_GET_REFERRED_TOKEN_BINDING_KEY_COMPLETE;\n  if (!IsTokenBindingEnabled() || request_->token_binding_referrer.empty())\n    return OK;\n\n  net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY);\n  ChannelIDService* channel_id_service = session_->context().channel_id_service;\n  return channel_id_service->GetOrCreateChannelID(\n      request_->token_binding_referrer, &referred_token_binding_key_,\n      io_callback_, &token_binding_request_);\n}\n\nint HttpNetworkTransaction::DoGetReferredTokenBindingKeyComplete(int rv) {\n  DCHECK_NE(ERR_IO_PENDING, rv);\n  if (IsTokenBindingEnabled() && !request_->token_binding_referrer.empty()) {\n    net_log_.EndEventWithNetErrorCode(\n        NetLogEventType::HTTP_TRANSACTION_GET_TOKEN_BINDING_KEY, rv);\n  }\n  if (rv == OK)\n    next_state_ = STATE_INIT_REQUEST_BODY;\n  return rv;\n}\n\nint HttpNetworkTransaction::BuildRequestHeaders(\n    bool using_http_proxy_without_tunnel) {\n  request_headers_.SetHeader(HttpRequestHeaders::kHost,\n                             GetHostAndOptionalPort(request_->url));\n\n  // For compat with HTTP/1.0 servers and proxies:\n  if (using_http_proxy_without_tunnel) {\n    request_headers_.SetHeader(HttpRequestHeaders::kProxyConnection,\n                               \"keep-alive\");\n  } else {\n    request_headers_.SetHeader(HttpRequestHeaders::kConnection, \"keep-alive\");\n  }\n\n  // Add a content length header?\n  if (request_->upload_data_stream) {\n    if (request_->upload_data_stream->is_chunked()) {\n      request_headers_.SetHeader(\n          HttpRequestHeaders::kTransferEncoding, \"chunked\");\n    } else {\n      request_headers_.SetHeader(\n          HttpRequestHeaders::kContentLength,\n          base::NumberToString(request_->upload_data_stream->size()));\n    }\n  } else if (request_->method == \"POST\" || request_->method == \"PUT\") {\n    // An empty POST/PUT request still needs a content length.  As for HEAD,\n    // IE and Safari also add a content length header.  Presumably it is to\n    // support sending a HEAD request to an URL that only expects to be sent a\n    // POST or some other method that normally would have a message body.\n    // Firefox (40.0) does not send the header, and RFC 7230 & 7231\n    // specify that it should not be sent due to undefined behavior.\n    request_headers_.SetHeader(HttpRequestHeaders::kContentLength, \"0\");\n  }\n\n  RecordTokenBindingSupport();\n  if (provided_token_binding_key_) {\n    std::string token_binding_header;\n    int rv = BuildTokenBindingHeader(&token_binding_header);\n    if (rv != OK)\n      return rv;\n    request_headers_.SetHeader(HttpRequestHeaders::kTokenBinding,\n                               token_binding_header);\n  }\n\n  // Honor load flags that impact proxy caches.\n  if (request_->load_flags & LOAD_BYPASS_CACHE) {\n    request_headers_.SetHeader(HttpRequestHeaders::kPragma, \"no-cache\");\n    request_headers_.SetHeader(HttpRequestHeaders::kCacheControl, \"no-cache\");\n  } else if (request_->load_flags & LOAD_VALIDATE_CACHE) {\n    request_headers_.SetHeader(HttpRequestHeaders::kCacheControl, \"max-age=0\");\n  }\n\n  if (ShouldApplyProxyAuth() && HaveAuth(HttpAuth::AUTH_PROXY))\n    auth_controllers_[HttpAuth::AUTH_PROXY]->AddAuthorizationHeader(\n        &request_headers_);\n  if (ShouldApplyServerAuth() && HaveAuth(HttpAuth::AUTH_SERVER))\n    auth_controllers_[HttpAuth::AUTH_SERVER]->AddAuthorizationHeader(\n        &request_headers_);\n\n  request_headers_.MergeFrom(request_->extra_headers);\n\n  if (!before_headers_sent_callback_.is_null())\n    before_headers_sent_callback_.Run(proxy_info_, &request_headers_);\n\n  response_.did_use_http_auth =\n      request_headers_.HasHeader(HttpRequestHeaders::kAuthorization) ||\n      request_headers_.HasHeader(HttpRequestHeaders::kProxyAuthorization);\n  return OK;\n}\n\nint HttpNetworkTransaction::BuildTokenBindingHeader(std::string* out) {\n  base::TimeTicks start = base::TimeTicks::Now();\n  std::vector<uint8_t> signed_ekm;\n  int rv = stream_->GetTokenBindingSignature(provided_token_binding_key_.get(),\n                                             TokenBindingType::PROVIDED,\n                                             &signed_ekm);\n  if (rv != OK)\n    return rv;\n  std::string provided_token_binding;\n  rv = BuildTokenBinding(TokenBindingType::PROVIDED,\n                         provided_token_binding_key_.get(), signed_ekm,\n                         &provided_token_binding);\n  if (rv != OK)\n    return rv;\n\n  std::vector<base::StringPiece> token_bindings;\n  token_bindings.push_back(provided_token_binding);\n\n  std::string referred_token_binding;\n  if (referred_token_binding_key_) {\n    std::vector<uint8_t> referred_signed_ekm;\n    int rv = stream_->GetTokenBindingSignature(\n        referred_token_binding_key_.get(), TokenBindingType::REFERRED,\n        &referred_signed_ekm);\n    if (rv != OK)\n      return rv;\n    rv = BuildTokenBinding(TokenBindingType::REFERRED,\n                           referred_token_binding_key_.get(),\n                           referred_signed_ekm, &referred_token_binding);\n    if (rv != OK)\n      return rv;\n    token_bindings.push_back(referred_token_binding);\n  }\n  std::string header;\n  rv = BuildTokenBindingMessageFromTokenBindings(token_bindings, &header);\n  if (rv != OK)\n    return rv;\n  base::Base64UrlEncode(header, base::Base64UrlEncodePolicy::OMIT_PADDING, out);\n  base::TimeDelta header_creation_time = base::TimeTicks::Now() - start;\n  UMA_HISTOGRAM_CUSTOM_TIMES(\"Net.TokenBinding.HeaderCreationTime\",\n                             header_creation_time,\n                             base::TimeDelta::FromMilliseconds(1),\n                             base::TimeDelta::FromMinutes(1), 50);\n  return OK;\n}\n\nint HttpNetworkTransaction::DoInitRequestBody() {\n  next_state_ = STATE_INIT_REQUEST_BODY_COMPLETE;\n  int rv = OK;\n  if (request_->upload_data_stream)\n    rv = request_->upload_data_stream->Init(\n        base::BindOnce(&HttpNetworkTransaction::OnIOComplete,\n                       base::Unretained(this)),\n        net_log_);\n  return rv;\n}\n\nint HttpNetworkTransaction::DoInitRequestBodyComplete(int result) {\n  if (result == OK)\n    next_state_ = STATE_BUILD_REQUEST;\n  return result;\n}\n\nint HttpNetworkTransaction::DoBuildRequest() {\n  next_state_ = STATE_BUILD_REQUEST_COMPLETE;\n  headers_valid_ = false;\n\n  // This is constructed lazily (instead of within our Start method), so that\n  // we have proxy info available.\n  if (request_headers_.IsEmpty()) {\n    bool using_http_proxy_without_tunnel = UsingHttpProxyWithoutTunnel();\n    return BuildRequestHeaders(using_http_proxy_without_tunnel);\n  }\n\n  return OK;\n}\n\nint HttpNetworkTransaction::DoBuildRequestComplete(int result) {\n  if (result == OK)\n    next_state_ = STATE_SEND_REQUEST;\n  return result;\n}\n\nint HttpNetworkTransaction::DoSendRequest() {\n  send_start_time_ = base::TimeTicks::Now();\n  next_state_ = STATE_SEND_REQUEST_COMPLETE;\n\n  return stream_->SendRequest(request_headers_, &response_, io_callback_);\n}\n\nint HttpNetworkTransaction::DoSendRequestComplete(int result) {\n  send_end_time_ = base::TimeTicks::Now();\n\n  if (result == ERR_HTTP_1_1_REQUIRED ||\n      result == ERR_PROXY_HTTP_1_1_REQUIRED) {\n    return HandleHttp11Required(result);\n  }\n\n  if (result < 0)\n    return HandleIOError(result);\n  next_state_ = STATE_READ_HEADERS;\n  return OK;\n}\n\nint HttpNetworkTransaction::DoReadHeaders() {\n  next_state_ = STATE_READ_HEADERS_COMPLETE;\n  return stream_->ReadResponseHeaders(io_callback_);\n}\n\nint HttpNetworkTransaction::DoReadHeadersComplete(int result) {\n  // We can get a certificate error or ERR_SSL_CLIENT_AUTH_CERT_NEEDED here\n  // due to SSL renegotiation.\n  if (IsCertificateError(result)) {\n    // We don't handle a certificate error during SSL renegotiation, so we\n    // have to return an error that's not in the certificate error range\n    // (-2xx).\n    LOG(ERROR) << \"Got a server certificate with error \" << result\n               << \" during SSL renegotiation\";\n    result = ERR_CERT_ERROR_IN_SSL_RENEGOTIATION;\n  } else if (result == ERR_SSL_CLIENT_AUTH_CERT_NEEDED) {\n    // TODO(wtc): Need a test case for this code path!\n    DCHECK(stream_.get());\n    DCHECK(IsSecureRequest());\n    response_.cert_request_info = new SSLCertRequestInfo;\n    stream_->GetSSLCertRequestInfo(response_.cert_request_info.get());\n    result = HandleCertificateRequest(result);\n    if (result == OK)\n      return result;\n  }\n\n  if (result == ERR_HTTP_1_1_REQUIRED ||\n      result == ERR_PROXY_HTTP_1_1_REQUIRED) {\n    return HandleHttp11Required(result);\n  }\n\n  // ERR_CONNECTION_CLOSED is treated differently at this point; if partial\n  // response headers were received, we do the best we can to make sense of it\n  // and send it back up the stack.\n  //\n  // TODO(davidben): Consider moving this to HttpBasicStream, It's a little\n  // bizarre for SPDY. Assuming this logic is useful at all.\n  // TODO(davidben): Bubble the error code up so we do not cache?\n  if (result == ERR_CONNECTION_CLOSED && response_.headers.get())\n    result = OK;\n\n  if (result < 0)\n    return HandleIOError(result);\n\n  DCHECK(response_.headers.get());\n\n  if (response_.headers.get() && !ContentEncodingsValid())\n    return ERR_CONTENT_DECODING_FAILED;\n\n  // On a 408 response from the server (\"Request Timeout\") on a stale socket,\n  // retry the request.\n  // Headers can be NULL because of http://crbug.com/384554.\n  if (response_.headers.get() &&\n      response_.headers->response_code() == HTTP_REQUEST_TIMEOUT &&\n      stream_->IsConnectionReused()) {\n    net_log_.AddEventWithNetErrorCode(\n        NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR,\n        response_.headers->response_code());\n    // This will close the socket - it would be weird to try and reuse it, even\n    // if the server doesn't actually close it.\n    ResetConnectionAndRequestForResend();\n    return OK;\n  }\n\n  // Like Net.HttpResponseCode, but only for MAIN_FRAME loads.\n  if (request_->load_flags & LOAD_MAIN_FRAME_DEPRECATED) {\n    const int response_code = response_.headers->response_code();\n    UMA_HISTOGRAM_ENUMERATION(\n        \"Net.HttpResponseCode_Nxx_MainFrame\", response_code/100, 10);\n  }\n\n  net_log_.AddEvent(\n      NetLogEventType::HTTP_TRANSACTION_READ_RESPONSE_HEADERS,\n      base::Bind(&HttpResponseHeaders::NetLogCallback, response_.headers));\n  if (response_headers_callback_)\n    response_headers_callback_.Run(response_.headers);\n\n  if (response_.headers->GetHttpVersion() < HttpVersion(1, 0)) {\n    // HTTP/0.9 doesn't support the PUT method, so lack of response headers\n    // indicates a buggy server.  See:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=193921\n    if (request_->method == \"PUT\")\n      return ERR_METHOD_NOT_SUPPORTED;\n  }\n\n  // Check for an intermediate 100 Continue response.  An origin server is\n  // allowed to send this response even if we didn't ask for it, so we just\n  // need to skip over it.\n  // We treat any other 1xx in this same way (although in practice getting\n  // a 1xx that isn't a 100 is rare).\n  // Unless this is a WebSocket request, in which case we pass it on up.\n  if (response_.headers->response_code() / 100 == 1 &&\n      !ForWebSocketHandshake()) {\n    response_.headers = new HttpResponseHeaders(std::string());\n    next_state_ = STATE_READ_HEADERS;\n    return OK;\n  }\n\n  if (response_.headers->response_code() == 421 &&\n      (enable_ip_based_pooling_ || enable_alternative_services_)) {\n    // Retry the request with both IP based pooling and Alternative Services\n    // disabled.\n    enable_ip_based_pooling_ = false;\n    enable_alternative_services_ = false;\n    net_log_.AddEvent(\n        NetLogEventType::HTTP_TRANSACTION_RESTART_MISDIRECTED_REQUEST);\n    ResetConnectionAndRequestForResend();\n    return OK;\n  }\n\n  if (IsSecureRequest()) {\n    stream_->GetSSLInfo(&response_.ssl_info);\n    if (response_.ssl_info.is_valid() &&\n        !IsCertStatusError(response_.ssl_info.cert_status)) {\n      session_->http_stream_factory()->ProcessAlternativeServices(\n          session_, response_.headers.get(),\n          url::SchemeHostPort(request_->url));\n    }\n  }\n\n  int rv = HandleAuthChallenge();\n  if (rv != OK)\n    return rv;\n\n  headers_valid_ = true;\n\n  // We have reached the end of Start state machine, set the RequestInfo to\n  // null.\n  // RequestInfo is a member of the HttpTransaction's consumer and is useful\n  // only until the final response headers are received. Clearing it will ensure\n  // that HttpRequestInfo is only used up until final response headers are\n  // received. Clearing is allowed so that the transaction can be disassociated\n  // from its creating consumer in cases where it is shared for writing to the\n  // cache. It is also safe to set it to null at this point since\n  // upload_data_stream is also not used in the Read state machine.\n  if (pending_auth_target_ == HttpAuth::AUTH_NONE)\n    request_ = nullptr;\n\n  return OK;\n}\n\nint HttpNetworkTransaction::DoReadBody() {\n  DCHECK(read_buf_.get());\n  DCHECK_GT(read_buf_len_, 0);\n  DCHECK(stream_ != NULL);\n\n  next_state_ = STATE_READ_BODY_COMPLETE;\n  return stream_->ReadResponseBody(\n      read_buf_.get(), read_buf_len_, io_callback_);\n}\n\nint HttpNetworkTransaction::DoReadBodyComplete(int result) {\n  // We are done with the Read call.\n  bool done = false;\n  if (result <= 0) {\n    DCHECK_NE(ERR_IO_PENDING, result);\n    done = true;\n  }\n\n  // Clean up connection if we are done.\n  if (done) {\n    // Note: Just because IsResponseBodyComplete is true, we're not\n    // necessarily \"done\".  We're only \"done\" when it is the last\n    // read on this HttpNetworkTransaction, which will be signified\n    // by a zero-length read.\n    // TODO(mbelshe): The keep-alive property is really a property of\n    //    the stream.  No need to compute it here just to pass back\n    //    to the stream's Close function.\n    bool keep_alive =\n        stream_->IsResponseBodyComplete() && stream_->CanReuseConnection();\n\n    stream_->Close(!keep_alive);\n    // Note: we don't reset the stream here.  We've closed it, but we still\n    // need it around so that callers can call methods such as\n    // GetUploadProgress() and have them be meaningful.\n    // TODO(mbelshe): This means we closed the stream here, and we close it\n    // again in ~HttpNetworkTransaction.  Clean that up.\n\n    // The next Read call will return 0 (EOF).\n\n    // This transaction was successful. If it had been retried because of an\n    // error with an alternative service, mark that alternative service broken.\n    if (!enable_alternative_services_ &&\n        retried_alternative_service_.protocol != kProtoUnknown) {\n      session_->http_server_properties()->MarkAlternativeServiceBroken(\n          retried_alternative_service_);\n    }\n  }\n\n  // Clear these to avoid leaving around old state.\n  read_buf_ = NULL;\n  read_buf_len_ = 0;\n\n  return result;\n}\n\nint HttpNetworkTransaction::DoDrainBodyForAuthRestart() {\n  // This method differs from DoReadBody only in the next_state_.  So we just\n  // call DoReadBody and override the next_state_.  Perhaps there is a more\n  // elegant way for these two methods to share code.\n  int rv = DoReadBody();\n  DCHECK(next_state_ == STATE_READ_BODY_COMPLETE);\n  next_state_ = STATE_DRAIN_BODY_FOR_AUTH_RESTART_COMPLETE;\n  return rv;\n}\n\n// TODO(wtc): This method and the DoReadBodyComplete method are almost\n// the same.  Figure out a good way for these two methods to share code.\nint HttpNetworkTransaction::DoDrainBodyForAuthRestartComplete(int result) {\n  // keep_alive defaults to true because the very reason we're draining the\n  // response body is to reuse the connection for auth restart.\n  bool done = false, keep_alive = true;\n  if (result < 0) {\n    // Error or closed connection while reading the socket.\n    done = true;\n    keep_alive = false;\n  } else if (stream_->IsResponseBodyComplete()) {\n    done = true;\n  }\n\n  if (done) {\n    DidDrainBodyForAuthRestart(keep_alive);\n  } else {\n    // Keep draining.\n    next_state_ = STATE_DRAIN_BODY_FOR_AUTH_RESTART;\n  }\n\n  return OK;\n}\n\nint HttpNetworkTransaction::HandleCertificateRequest(int error) {\n  // There are two paths through which the server can request a certificate\n  // from us.  The first is during the initial handshake, the second is\n  // during SSL renegotiation.\n  //\n  // In both cases, we want to close the connection before proceeding.\n  // We do this for two reasons:\n  //   First, we don't want to keep the connection to the server hung for a\n  //   long time while the user selects a certificate.\n  //   Second, even if we did keep the connection open, NSS has a bug where\n  //   restarting the handshake for ClientAuth is currently broken.\n  DCHECK_EQ(error, ERR_SSL_CLIENT_AUTH_CERT_NEEDED);\n\n  if (stream_.get()) {\n    // Since we already have a stream, we're being called as part of SSL\n    // renegotiation.\n    DCHECK(!stream_request_.get());\n    total_received_bytes_ += stream_->GetTotalReceivedBytes();\n    total_sent_bytes_ += stream_->GetTotalSentBytes();\n    stream_->Close(true);\n    CacheNetErrorDetailsAndResetStream();\n  }\n\n  // The server is asking for a client certificate during the initial\n  // handshake.\n  stream_request_.reset();\n\n  // If the user selected one of the certificates in client_certs or declined\n  // to provide one for this server before, use the past decision\n  // automatically.\n  scoped_refptr<X509Certificate> client_cert;\n  scoped_refptr<SSLPrivateKey> client_private_key;\n  bool found_cached_cert = session_->ssl_client_auth_cache()->Lookup(\n      response_.cert_request_info->host_and_port, &client_cert,\n      &client_private_key);\n  if (!found_cached_cert)\n    return error;\n\n  // Check that the certificate selected is still a certificate the server\n  // is likely to accept, based on the criteria supplied in the\n  // CertificateRequest message.\n  if (client_cert.get()) {\n    const std::vector<std::string>& cert_authorities =\n        response_.cert_request_info->cert_authorities;\n\n    bool cert_still_valid = cert_authorities.empty() ||\n        client_cert->IsIssuedByEncoded(cert_authorities);\n    if (!cert_still_valid)\n      return error;\n  }\n\n  if (!response_.cert_request_info->is_proxy) {\n    server_ssl_client_cert_was_cached_ = true;\n  }\n\n  // TODO(davidben): Add a unit test which covers this path; we need to be\n  // able to send a legitimate certificate and also bypass/clear the\n  // SSL session cache.\n  SSLConfig* ssl_config = response_.cert_request_info->is_proxy ?\n      &proxy_ssl_config_ : &server_ssl_config_;\n  ssl_config->send_client_cert = true;\n  ssl_config->client_cert = client_cert;\n  ssl_config->client_private_key = client_private_key;\n  next_state_ = STATE_CREATE_STREAM;\n  // Reset the other member variables.\n  // Note: this is necessary only with SSL renegotiation.\n  ResetStateForRestart();\n  return OK;\n}\n\nint HttpNetworkTransaction::HandleHttp11Required(int error) {\n  DCHECK(error == ERR_HTTP_1_1_REQUIRED ||\n         error == ERR_PROXY_HTTP_1_1_REQUIRED);\n\n  if (error == ERR_HTTP_1_1_REQUIRED) {\n    HttpServerProperties::ForceHTTP11(&server_ssl_config_);\n  } else {\n    HttpServerProperties::ForceHTTP11(&proxy_ssl_config_);\n  }\n  ResetConnectionAndRequestForResend();\n  return OK;\n}\n\nint HttpNetworkTransaction::HandleSSLClientAuthError(int error) {\n  // TODO(davidben): This does handle client certificate errors from the\n  // proxy. https://crbug.com/814911.\n  if (server_ssl_config_.send_client_cert &&\n      (error == ERR_SSL_PROTOCOL_ERROR || IsClientCertificateError(error))) {\n    session_->ssl_client_auth_cache()->Remove(\n        HostPortPair::FromURL(request_->url));\n\n    // The private key handle may have gone stale due to, e.g., the user\n    // unplugging their smartcard. Operating systems do not provide reliable\n    // notifications for this, so if the signature failed and the private key\n    // came from SSLClientAuthCache, retry to ask the user for a new one.\n    if (error == ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED &&\n        server_ssl_client_cert_was_cached_ && !HasExceededMaxRetries()) {\n      server_ssl_client_cert_was_cached_ = false;\n      server_ssl_config_.send_client_cert = false;\n      server_ssl_config_.client_cert = nullptr;\n      server_ssl_config_.client_private_key = nullptr;\n      retry_attempts_++;\n      net_log_.AddEventWithNetErrorCode(\n          NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n      ResetConnectionAndRequestForResend();\n      return OK;\n    }\n  }\n  return error;\n}\n\n// This method determines whether it is safe to resend the request after an\n// IO error.  It can only be called in response to request header or body\n// write errors or response header read errors.  It should not be used in\n// other cases, such as a Connect error.\nint HttpNetworkTransaction::HandleIOError(int error) {\n  // Because the peer may request renegotiation with client authentication at\n  // any time, check and handle client authentication errors.\n  error = HandleSSLClientAuthError(error);\n\n  switch (error) {\n    // If we try to reuse a connection that the server is in the process of\n    // closing, we may end up successfully writing out our request (or a\n    // portion of our request) only to find a connection error when we try to\n    // read from (or finish writing to) the socket.\n    case ERR_CONNECTION_RESET:\n    case ERR_CONNECTION_CLOSED:\n    case ERR_CONNECTION_ABORTED:\n    // There can be a race between the socket pool checking checking whether a\n    // socket is still connected, receiving the FIN, and sending/reading data\n    // on a reused socket.  If we receive the FIN between the connectedness\n    // check and writing/reading from the socket, we may first learn the socket\n    // is disconnected when we get a ERR_SOCKET_NOT_CONNECTED.  This will most\n    // likely happen when trying to retrieve its IP address.\n    // See http://crbug.com/105824 for more details.\n    case ERR_SOCKET_NOT_CONNECTED:\n    // If a socket is closed on its initial request, HttpStreamParser returns\n    // ERR_EMPTY_RESPONSE. This may still be close/reuse race if the socket was\n    // preconnected but failed to be used before the server timed it out.\n    case ERR_EMPTY_RESPONSE:\n      if (ShouldResendRequest()) {\n        net_log_.AddEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n        ResetConnectionAndRequestForResend();\n        error = OK;\n      }\n      break;\n    case ERR_SPDY_PING_FAILED:\n    case ERR_SPDY_SERVER_REFUSED_STREAM:\n    case ERR_SPDY_PUSHED_STREAM_NOT_AVAILABLE:\n    case ERR_SPDY_CLAIMED_PUSHED_STREAM_RESET_BY_SERVER:\n    case ERR_SPDY_PUSHED_RESPONSE_DOES_NOT_MATCH:\n    case ERR_QUIC_HANDSHAKE_FAILED:\n      if (HasExceededMaxRetries())\n        break;\n      net_log_.AddEventWithNetErrorCode(\n          NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n      retry_attempts_++;\n      ResetConnectionAndRequestForResend();\n      error = OK;\n      break;\n    case ERR_QUIC_PROTOCOL_ERROR:\n      if (GetResponseHeaders() != nullptr ||\n          !stream_->GetAlternativeService(&retried_alternative_service_)) {\n        // If the response headers have already been recieved and passed up\n        // then the request can not be retried. Also, if there was no\n        // alternative service used for this request, then there is no\n        // alternative service to be disabled.\n        break;\n      }\n      if (HasExceededMaxRetries())\n        break;\n      if (session_->http_server_properties()->IsAlternativeServiceBroken(\n              retried_alternative_service_)) {\n        // If the alternative service was marked as broken while the request\n        // was in flight, retry the request which will not use the broken\n        // alternative service.\n        net_log_.AddEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n        retry_attempts_++;\n        ResetConnectionAndRequestForResend();\n        error = OK;\n      } else if (session_->params().retry_without_alt_svc_on_quic_errors) {\n        // Disable alternative services for this request and retry it. If the\n        // retry succeeds, then the alternative service will be marked as\n        // broken then.\n        enable_alternative_services_ = false;\n        net_log_.AddEventWithNetErrorCode(\n            NetLogEventType::HTTP_TRANSACTION_RESTART_AFTER_ERROR, error);\n        retry_attempts_++;\n        ResetConnectionAndRequestForResend();\n        error = OK;\n      }\n      break;\n  }\n  return error;\n}\n\nvoid HttpNetworkTransaction::ResetStateForRestart() {\n  ResetStateForAuthRestart();\n  if (stream_) {\n    total_received_bytes_ += stream_->GetTotalReceivedBytes();\n    total_sent_bytes_ += stream_->GetTotalSentBytes();\n  }\n  CacheNetErrorDetailsAndResetStream();\n}\n\nvoid HttpNetworkTransaction::ResetStateForAuthRestart() {\n  send_start_time_ = base::TimeTicks();\n  send_end_time_ = base::TimeTicks();\n\n  pending_auth_target_ = HttpAuth::AUTH_NONE;\n  read_buf_ = NULL;\n  read_buf_len_ = 0;\n  headers_valid_ = false;\n  request_headers_.Clear();\n  response_ = HttpResponseInfo();\n  establishing_tunnel_ = false;\n  remote_endpoint_ = IPEndPoint();\n  net_error_details_.quic_broken = false;\n  net_error_details_.quic_connection_error = quic::QUIC_NO_ERROR;\n  provided_token_binding_key_.reset();\n  referred_token_binding_key_.reset();\n}\n\nvoid HttpNetworkTransaction::CacheNetErrorDetailsAndResetStream() {\n  if (stream_)\n    stream_->PopulateNetErrorDetails(&net_error_details_);\n  stream_.reset();\n}\n\nHttpResponseHeaders* HttpNetworkTransaction::GetResponseHeaders() const {\n  return response_.headers.get();\n}\n\nbool HttpNetworkTransaction::ShouldResendRequest() const {\n  bool connection_is_proven = stream_->IsConnectionReused();\n  bool has_received_headers = GetResponseHeaders() != NULL;\n\n  // NOTE: we resend a request only if we reused a keep-alive connection.\n  // This automatically prevents an infinite resend loop because we'll run\n  // out of the cached keep-alive connections eventually.\n  if (connection_is_proven && !has_received_headers)\n    return true;\n  return false;\n}\n\nbool HttpNetworkTransaction::HasExceededMaxRetries() const {\n  return (retry_attempts_ >= kMaxRetryAttempts);\n}\n\nbool HttpNetworkTransaction::CheckMaxRestarts() {\n  num_restarts_++;\n  return num_restarts_ < kMaxRestarts;\n}\n\nvoid HttpNetworkTransaction::ResetConnectionAndRequestForResend() {\n  if (stream_.get()) {\n    stream_->Close(true);\n    CacheNetErrorDetailsAndResetStream();\n  }\n\n  // We need to clear request_headers_ because it contains the real request\n  // headers, but we may need to resend the CONNECT request first to recreate\n  // the SSL tunnel.\n  request_headers_.Clear();\n  next_state_ = STATE_CREATE_STREAM;  // Resend the request.\n}\n\nbool HttpNetworkTransaction::ShouldApplyProxyAuth() const {\n  return UsingHttpProxyWithoutTunnel();\n}\n\nbool HttpNetworkTransaction::ShouldApplyServerAuth() const {\n  return !(request_->load_flags & LOAD_DO_NOT_SEND_AUTH_DATA);\n}\n\nint HttpNetworkTransaction::HandleAuthChallenge() {\n  scoped_refptr<HttpResponseHeaders> headers(GetResponseHeaders());\n  DCHECK(headers.get());\n\n  int status = headers->response_code();\n  if (status != HTTP_UNAUTHORIZED &&\n      status != HTTP_PROXY_AUTHENTICATION_REQUIRED)\n    return OK;\n  HttpAuth::Target target = status == HTTP_PROXY_AUTHENTICATION_REQUIRED ?\n                            HttpAuth::AUTH_PROXY : HttpAuth::AUTH_SERVER;\n  if (target == HttpAuth::AUTH_PROXY && proxy_info_.is_direct())\n    return ERR_UNEXPECTED_PROXY_AUTH;\n\n  // This case can trigger when an HTTPS server responds with a \"Proxy\n  // authentication required\" status code through a non-authenticating\n  // proxy.\n  if (!auth_controllers_[target].get())\n    return ERR_UNEXPECTED_PROXY_AUTH;\n\n  int rv = auth_controllers_[target]->HandleAuthChallenge(\n      headers, response_.ssl_info,\n      (request_->load_flags & LOAD_DO_NOT_SEND_AUTH_DATA) != 0, false,\n      net_log_);\n  if (auth_controllers_[target]->HaveAuthHandler())\n    pending_auth_target_ = target;\n\n  scoped_refptr<AuthChallengeInfo> auth_info =\n      auth_controllers_[target]->auth_info();\n  if (auth_info.get())\n      response_.auth_challenge = auth_info;\n\n  return rv;\n}\n\nbool HttpNetworkTransaction::HaveAuth(HttpAuth::Target target) const {\n  return auth_controllers_[target].get() &&\n      auth_controllers_[target]->HaveAuth();\n}\n\nGURL HttpNetworkTransaction::AuthURL(HttpAuth::Target target) const {\n  switch (target) {\n    case HttpAuth::AUTH_PROXY: {\n      if (!proxy_info_.proxy_server().is_valid() ||\n          proxy_info_.proxy_server().is_direct()) {\n        return GURL();  // There is no proxy server.\n      }\n      const char* scheme = proxy_info_.is_https() ? \"https://\" : \"http://\";\n      return GURL(scheme +\n                  proxy_info_.proxy_server().host_port_pair().ToString());\n    }\n    case HttpAuth::AUTH_SERVER:\n      if (ForWebSocketHandshake()) {\n        const GURL& url = request_->url;\n        url::Replacements<char> ws_to_http;\n        if (url.SchemeIs(\"ws\")) {\n          ws_to_http.SetScheme(\"http\", url::Component(0, 4));\n        } else {\n          DCHECK(url.SchemeIs(\"wss\"));\n          ws_to_http.SetScheme(\"https\", url::Component(0, 5));\n        }\n        return url.ReplaceComponents(ws_to_http);\n      }\n      return request_->url;\n    default:\n     return GURL();\n  }\n}\n\nbool HttpNetworkTransaction::ForWebSocketHandshake() const {\n  return websocket_handshake_stream_base_create_helper_ &&\n         request_->url.SchemeIsWSOrWSS();\n}\n\nvoid HttpNetworkTransaction::CopyConnectionAttemptsFromStreamRequest() {\n  DCHECK(stream_request_);\n\n  // Since the transaction can restart with auth credentials, it may create a\n  // stream more than once. Accumulate all of the connection attempts across\n  // those streams by appending them to the vector:\n  for (const auto& attempt : stream_request_->connection_attempts())\n    connection_attempts_.push_back(attempt);\n}\n\nbool HttpNetworkTransaction::ContentEncodingsValid() const {\n  HttpResponseHeaders* headers = GetResponseHeaders();\n  DCHECK(headers);\n\n  std::string accept_encoding;\n  request_headers_.GetHeader(HttpRequestHeaders::kAcceptEncoding,\n                             &accept_encoding);\n  std::set<std::string> allowed_encodings;\n  if (!HttpUtil::ParseAcceptEncoding(accept_encoding, &allowed_encodings)) {\n    FilterSourceStream::ReportContentDecodingFailed(SourceStream::TYPE_INVALID);\n    return false;\n  }\n\n  std::string content_encoding;\n  headers->GetNormalizedHeader(\"Content-Encoding\", &content_encoding);\n  std::set<std::string> used_encodings;\n  if (!HttpUtil::ParseContentEncoding(content_encoding, &used_encodings)) {\n    FilterSourceStream::ReportContentDecodingFailed(SourceStream::TYPE_INVALID);\n    return false;\n  }\n\n  // When \"Accept-Encoding\" is not specified, it is parsed as \"*\".\n  // If \"*\" encoding is advertised, then any encoding should be \"accepted\".\n  // This does not mean, that it will be successfully decoded.\n  if (allowed_encodings.find(\"*\") != allowed_encodings.end())\n    return true;\n\n  bool result = true;\n  for (auto const& encoding : used_encodings) {\n    SourceStream::SourceType source_type =\n        FilterSourceStream::ParseEncodingType(encoding);\n    // We don't reject encodings we are not aware. They just will not decode.\n    if (source_type == SourceStream::TYPE_UNKNOWN)\n      continue;\n    if (allowed_encodings.find(encoding) == allowed_encodings.end()) {\n      FilterSourceStream::ReportContentDecodingFailed(\n          SourceStream::TYPE_REJECTED);\n      result = false;\n      break;\n    }\n  }\n\n  // Temporary workaround for http://crbug.com/714514\n  if (headers->IsRedirect(nullptr)) {\n    UMA_HISTOGRAM_BOOLEAN(\"Net.RedirectWithUnadvertisedContentEncoding\",\n                          !result);\n    return true;\n  }\n\n  return result;\n}\n\n}  // namespace net\n"
        }, 
        "generated": false, 
        "mime_type": "text/plain", 
        "size": "67450", 
        "type": 1, 
        "md5": "5a2e2c218050c24841603faa4a6d7a7c", 
        "codeblock": [
          {
            "child": [
              {
                "name_prefix": "", 
                "type": 9, 
                "name": "kMaxRetryAttempts", 
                "text_range": {
                  "start_line": 78, 
                  "end_line": 78, 
                  "start_column": 1, 
                  "end_column": 36
                }, 
                "signature": ""
              }, 
              {
                "name_prefix": "", 
                "type": 9, 
                "name": "kMaxRestarts", 
                "text_range": {
                  "start_line": 88, 
                  "end_line": 88, 
                  "start_column": 1, 
                  "end_column": 32
                }, 
                "signature": ""
              }
            ], 
            "type": 11, 
            "name": "", 
            "text_range": {
              "start_line": 74, 
              "end_line": 90, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": ""
          }, 
          {
            "child": [
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HttpNetworkTransaction", 
                "text_range": {
                  "start_line": 94, 
                  "end_line": 117, 
                  "start_column": 1, 
                  "end_column": 45
                }, 
                "signature": "(RequestPriority priority, HttpNetworkSession* session)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "~HttpNetworkTransaction", 
                "text_range": {
                  "start_line": 119, 
                  "end_line": 137, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "Start", 
                "text_range": {
                  "start_line": 139, 
                  "end_line": 167, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const HttpRequestInfo* request_info, const CompletionCallback& callback, const NetLogWithSource& net_log)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "RestartIgnoringLastError", 
                "text_range": {
                  "start_line": 169, 
                  "end_line": 184, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const CompletionCallback& callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "RestartWithCertificate", 
                "text_range": {
                  "start_line": 186, 
                  "end_line": 215, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(scoped_refptr<X509Certificate> client_cert, scoped_refptr<SSLPrivateKey> client_private_key, const CompletionCallback& callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "RestartWithAuth", 
                "text_range": {
                  "start_line": 217, 
                  "end_line": 253, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const AuthCredentials& credentials, const CompletionCallback& callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "PrepareForAuthRestart", 
                "text_range": {
                  "start_line": 255, 
                  "end_line": 284, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(HttpAuth::Target target)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DidDrainBodyForAuthRestart", 
                "text_range": {
                  "start_line": 286, 
                  "end_line": 317, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(bool keep_alive)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "IsReadyToRestartForAuth", 
                "text_range": {
                  "start_line": 319, 
                  "end_line": 322, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "Read", 
                "text_range": {
                  "start_line": 324, 
                  "end_line": 359, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(IOBuffer* buf, int buf_len, const CompletionCallback& callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "StopCaching", 
                "text_range": {
                  "start_line": 361, 
                  "end_line": 361, 
                  "start_column": 1, 
                  "end_column": 46
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetFullRequestHeaders", 
                "text_range": {
                  "start_line": 363, 
                  "end_line": 368, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(HttpRequestHeaders* headers)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetTotalReceivedBytes", 
                "text_range": {
                  "start_line": 370, 
                  "end_line": 375, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetTotalSentBytes", 
                "text_range": {
                  "start_line": 377, 
                  "end_line": 382, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoneReading", 
                "text_range": {
                  "start_line": 384, 
                  "end_line": 384, 
                  "start_column": 1, 
                  "end_column": 46
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetResponseInfo", 
                "text_range": {
                  "start_line": 386, 
                  "end_line": 388, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetLoadState", 
                "text_range": {
                  "start_line": 390, 
                  "end_line": 409, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "SetQuicServerInfo", 
                "text_range": {
                  "start_line": 411, 
                  "end_line": 412, 
                  "start_column": 1, 
                  "end_column": 41
                }, 
                "signature": "(QuicServerInfo* quic_server_info)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetLoadTimingInfo", 
                "text_range": {
                  "start_line": 414, 
                  "end_line": 425, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(LoadTimingInfo* load_timing_info)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetRemoteEndpoint", 
                "text_range": {
                  "start_line": 427, 
                  "end_line": 433, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(IPEndPoint* endpoint)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "PopulateNetErrorDetails", 
                "text_range": {
                  "start_line": 435, 
                  "end_line": 440, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(NetErrorDetails* details)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "SetPriority", 
                "text_range": {
                  "start_line": 442, 
                  "end_line": 451, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(RequestPriority priority)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "SetWebSocketHandshakeStreamCreateHelper", 
                "text_range": {
                  "start_line": 453, 
                  "end_line": 456, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(WebSocketHandshakeStreamBase::CreateHelper* create_helper)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "SetBeforeNetworkStartCallback", 
                "text_range": {
                  "start_line": 458, 
                  "end_line": 461, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const BeforeNetworkStartCallback& callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "SetBeforeHeadersSentCallback", 
                "text_range": {
                  "start_line": 463, 
                  "end_line": 466, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const BeforeHeadersSentCallback& callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "SetRequestHeadersCallback", 
                "text_range": {
                  "start_line": 468, 
                  "end_line": 472, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(RequestHeadersCallback callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "SetResponseHeadersCallback", 
                "text_range": {
                  "start_line": 474, 
                  "end_line": 478, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(ResponseHeadersCallback callback)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ResumeNetworkStart", 
                "text_range": {
                  "start_line": 480, 
                  "end_line": 483, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnStreamReady", 
                "text_range": {
                  "start_line": 485, 
                  "end_line": 511, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const SSLConfig& used_ssl_config, const ProxyInfo& used_proxy_info, std::unique_ptr<HttpStream> stream)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnBidirectionalStreamImplReady", 
                "text_range": {
                  "start_line": 513, 
                  "end_line": 518, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const SSLConfig& used_ssl_config, const ProxyInfo& used_proxy_info, std::unique_ptr<BidirectionalStreamImpl> stream)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnWebSocketHandshakeStreamReady", 
                "text_range": {
                  "start_line": 520, 
                  "end_line": 525, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const SSLConfig& used_ssl_config, const ProxyInfo& used_proxy_info, std::unique_ptr<WebSocketHandshakeStreamBase> stream)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnStreamFailed", 
                "text_range": {
                  "start_line": 527, 
                  "end_line": 539, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result, const NetErrorDetails& net_error_details, const SSLConfig& used_ssl_config)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnCertificateError", 
                "text_range": {
                  "start_line": 541, 
                  "end_line": 560, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result, const SSLConfig& used_ssl_config, const SSLInfo& ssl_info)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnNeedsProxyAuth", 
                "text_range": {
                  "start_line": 562, 
                  "end_line": 587, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const HttpResponseInfo& proxy_response, const SSLConfig& used_ssl_config, const ProxyInfo& used_proxy_info, HttpAuthController* auth_controller)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnNeedsClientAuth", 
                "text_range": {
                  "start_line": 589, 
                  "end_line": 597, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const SSLConfig& used_ssl_config, SSLCertRequestInfo* cert_info)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnHttpsProxyTunnelResponse", 
                "text_range": {
                  "start_line": 599, 
                  "end_line": 620, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const HttpResponseInfo& response_info, const SSLConfig& used_ssl_config, const ProxyInfo& used_proxy_info, std::unique_ptr<HttpStream> stream)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnQuicBroken", 
                "text_range": {
                  "start_line": 622, 
                  "end_line": 624, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetConnectionAttempts", 
                "text_range": {
                  "start_line": 626, 
                  "end_line": 629, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(ConnectionAttempts* out)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "IsSecureRequest", 
                "text_range": {
                  "start_line": 631, 
                  "end_line": 633, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "IsTokenBindingEnabled", 
                "text_range": {
                  "start_line": 635, 
                  "end_line": 643, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "RecordTokenBindingSupport", 
                "text_range": {
                  "start_line": 645, 
                  "end_line": 669, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "UsingHttpProxyWithoutTunnel", 
                "text_range": {
                  "start_line": 671, 
                  "end_line": 675, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoCallback", 
                "text_range": {
                  "start_line": 677, 
                  "end_line": 683, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int rv)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "OnIOComplete", 
                "text_range": {
                  "start_line": 685, 
                  "end_line": 689, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoLoop", 
                "text_range": {
                  "start_line": 691, 
                  "end_line": 812, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoNotifyBeforeCreateStream", 
                "text_range": {
                  "start_line": 814, 
                  "end_line": 822, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoCreateStream", 
                "text_range": {
                  "start_line": 824, 
                  "end_line": 846, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoCreateStreamComplete", 
                "text_range": {
                  "start_line": 848, 
                  "end_line": 915, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoInitStream", 
                "text_range": {
                  "start_line": 917, 
                  "end_line": 925, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoInitStreamComplete", 
                "text_range": {
                  "start_line": 927, 
                  "end_line": 943, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGenerateProxyAuthToken", 
                "text_range": {
                  "start_line": 945, 
                  "end_line": 959, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGenerateProxyAuthTokenComplete", 
                "text_range": {
                  "start_line": 961, 
                  "end_line": 966, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int rv)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGenerateServerAuthToken", 
                "text_range": {
                  "start_line": 968, 
                  "end_line": 985, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGenerateServerAuthTokenComplete", 
                "text_range": {
                  "start_line": 987, 
                  "end_line": 992, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int rv)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGetProvidedTokenBindingKey", 
                "text_range": {
                  "start_line": 994, 
                  "end_line": 1004, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGetProvidedTokenBindingKeyComplete", 
                "text_range": {
                  "start_line": 1006, 
                  "end_line": 1016, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int rv)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGetReferredTokenBindingKey", 
                "text_range": {
                  "start_line": 1018, 
                  "end_line": 1028, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoGetReferredTokenBindingKeyComplete", 
                "text_range": {
                  "start_line": 1030, 
                  "end_line": 1039, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int rv)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "BuildRequestHeaders", 
                "text_range": {
                  "start_line": 1041, 
                  "end_line": 1108, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(bool using_http_proxy_without_tunnel)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "BuildTokenBindingHeader", 
                "text_range": {
                  "start_line": 1110, 
                  "end_line": 1154, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(std::string* out)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoInitRequestBody", 
                "text_range": {
                  "start_line": 1156, 
                  "end_line": 1165, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoInitRequestBodyComplete", 
                "text_range": {
                  "start_line": 1167, 
                  "end_line": 1171, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoBuildRequest", 
                "text_range": {
                  "start_line": 1173, 
                  "end_line": 1185, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoBuildRequestComplete", 
                "text_range": {
                  "start_line": 1187, 
                  "end_line": 1191, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoSendRequest", 
                "text_range": {
                  "start_line": 1193, 
                  "end_line": 1198, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoSendRequestComplete", 
                "text_range": {
                  "start_line": 1200, 
                  "end_line": 1212, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoReadHeaders", 
                "text_range": {
                  "start_line": 1214, 
                  "end_line": 1217, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoReadHeadersComplete", 
                "text_range": {
                  "start_line": 1219, 
                  "end_line": 1353, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoReadBody", 
                "text_range": {
                  "start_line": 1355, 
                  "end_line": 1363, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoReadBodyComplete", 
                "text_range": {
                  "start_line": 1365, 
                  "end_line": 1408, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoDrainBodyForAuthRestart", 
                "text_range": {
                  "start_line": 1410, 
                  "end_line": 1418, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "DoDrainBodyForAuthRestartComplete", 
                "text_range": {
                  "start_line": 1422, 
                  "end_line": 1442, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int result)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HandleCertificateRequest", 
                "text_range": {
                  "start_line": 1444, 
                  "end_line": 1512, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int error)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HandleHttp11Required", 
                "text_range": {
                  "start_line": 1514, 
                  "end_line": 1525, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int error)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HandleSSLClientAuthError", 
                "text_range": {
                  "start_line": 1527, 
                  "end_line": 1553, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int error)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HandleIOError", 
                "text_range": {
                  "start_line": 1559, 
                  "end_line": 1640, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int error)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ResetStateForRestart", 
                "text_range": {
                  "start_line": 1642, 
                  "end_line": 1649, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ResetStateForAuthRestart", 
                "text_range": {
                  "start_line": 1651, 
                  "end_line": 1667, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "CacheNetErrorDetailsAndResetStream", 
                "text_range": {
                  "start_line": 1669, 
                  "end_line": 1673, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "GetResponseHeaders", 
                "text_range": {
                  "start_line": 1675, 
                  "end_line": 1677, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ShouldResendRequest", 
                "text_range": {
                  "start_line": 1679, 
                  "end_line": 1689, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HasExceededMaxRetries", 
                "text_range": {
                  "start_line": 1691, 
                  "end_line": 1693, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "CheckMaxRestarts", 
                "text_range": {
                  "start_line": 1695, 
                  "end_line": 1698, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ResetConnectionAndRequestForResend", 
                "text_range": {
                  "start_line": 1700, 
                  "end_line": 1711, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ShouldApplyProxyAuth", 
                "text_range": {
                  "start_line": 1713, 
                  "end_line": 1715, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ShouldApplyServerAuth", 
                "text_range": {
                  "start_line": 1717, 
                  "end_line": 1719, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HandleAuthChallenge", 
                "text_range": {
                  "start_line": 1721, 
                  "end_line": 1753, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "HaveAuth", 
                "text_range": {
                  "start_line": 1755, 
                  "end_line": 1758, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(HttpAuth::Target target)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "AuthURL", 
                "text_range": {
                  "start_line": 1760, 
                  "end_line": 1787, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(HttpAuth::Target target)"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ForWebSocketHandshake", 
                "text_range": {
                  "start_line": 1789, 
                  "end_line": 1792, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "CopyConnectionAttemptsFromStreamRequest", 
                "text_range": {
                  "start_line": 1794, 
                  "end_line": 1802, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "HttpNetworkTransaction::", 
                "type": 8, 
                "name": "ContentEncodingsValid", 
                "text_range": {
                  "start_line": 1804, 
                  "end_line": 1854, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }
            ], 
            "type": 11, 
            "name": "net", 
            "text_range": {
              "start_line": 92, 
              "end_line": 1856, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": ""
          }
        ]
      }, 
      "return_code": 1
    }
  ]
}