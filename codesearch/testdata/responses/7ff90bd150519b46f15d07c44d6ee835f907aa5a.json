{
  "elapsed_ms": 44, 
  "file_info_response": [
    {
      "file_info": {
        "gob_info": {
          "repo": "chromium/chromium/src", 
          "commit": "14d133d46eaaeea62d68c1cc215dd529145de72b", 
          "path": "chrome/browser/chrome_content_browser_client.cc"
        }, 
        "name": "src/chrome/browser/chrome_content_browser_client.cc", 
        "language": "c++", 
        "changelist_num": "14d133d46eaaeea62d68c1cc215dd529145de72b", 
        "package_name": "chromium", 
        "lines": "4536", 
        "content": {
          "text": "// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"chrome/browser/chrome_content_browser_client.h\"\n\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n\n#include \"base/base_switches.h\"\n#include \"base/bind.h\"\n#include \"base/bind_helpers.h\"\n#include \"base/command_line.h\"\n#include \"base/files/scoped_file.h\"\n#include \"base/i18n/base_i18n_switches.h\"\n#include \"base/i18n/character_encoding.h\"\n#include \"base/json/json_reader.h\"\n#include \"base/lazy_instance.h\"\n#include \"base/macros.h\"\n#include \"base/metrics/field_trial_params.h\"\n#include \"base/metrics/histogram_macros.h\"\n#include \"base/path_service.h\"\n#include \"base/strings/string_number_conversions.h\"\n#include \"base/strings/string_split.h\"\n#include \"base/strings/string_util.h\"\n#include \"base/strings/stringprintf.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"base/sys_info.h\"\n#include \"base/threading/thread_task_runner_handle.h\"\n#include \"build/build_config.h\"\n#include \"chrome/browser/after_startup_task_utils.h\"\n#include \"chrome/browser/browser_about_handler.h\"\n#include \"chrome/browser/browser_process.h\"\n#include \"chrome/browser/browsing_data/browsing_data_helper.h\"\n#include \"chrome/browser/browsing_data/chrome_browsing_data_remover_delegate.h\"\n#include \"chrome/browser/budget_service/budget_service_impl.h\"\n#include \"chrome/browser/cache_stats_recorder.h\"\n#include \"chrome/browser/chrome_content_browser_client_parts.h\"\n#include \"chrome/browser/chrome_quota_permission_context.h\"\n#include \"chrome/browser/client_hints/client_hints.h\"\n#include \"chrome/browser/content_settings/cookie_settings_factory.h\"\n#include \"chrome/browser/content_settings/host_content_settings_map_factory.h\"\n#include \"chrome/browser/content_settings/tab_specific_content_settings.h\"\n#include \"chrome/browser/defaults.h\"\n#include \"chrome/browser/download/download_prefs.h\"\n#include \"chrome/browser/external_protocol/external_protocol_handler.h\"\n#include \"chrome/browser/font_family_cache.h\"\n#include \"chrome/browser/language/chrome_language_detection_tab_helper.h\"\n#include \"chrome/browser/lifetime/browser_shutdown.h\"\n#include \"chrome/browser/media/platform_verification_impl.h\"\n#include \"chrome/browser/media/router/media_router_feature.h\"\n#include \"chrome/browser/media/router/presentation/presentation_service_delegate_impl.h\"\n#include \"chrome/browser/media/router/presentation/receiver_presentation_service_delegate_impl.h\"\n#include \"chrome/browser/media/webrtc/audio_debug_recordings_handler.h\"\n#include \"chrome/browser/media/webrtc/media_capture_devices_dispatcher.h\"\n#include \"chrome/browser/media/webrtc/webrtc_logging_handler_host.h\"\n#include \"chrome/browser/memory/chrome_memory_coordinator_delegate.h\"\n#include \"chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.h\"\n#include \"chrome/browser/nacl_host/nacl_browser_delegate_impl.h\"\n#include \"chrome/browser/net/predictor.h\"\n#include \"chrome/browser/net/profile_network_context_service.h\"\n#include \"chrome/browser/net/profile_network_context_service_factory.h\"\n#include \"chrome/browser/net/system_network_context_manager.h\"\n#include \"chrome/browser/net_benchmarking.h\"\n#include \"chrome/browser/notifications/platform_notification_service_impl.h\"\n#include \"chrome/browser/page_load_metrics/metrics_navigation_throttle.h\"\n#include \"chrome/browser/page_load_metrics/page_load_metrics_util.h\"\n#include \"chrome/browser/password_manager/chrome_password_manager_client.h\"\n#include \"chrome/browser/payments/payment_request_display_manager_factory.h\"\n#include \"chrome/browser/permissions/attestation_permission_request.h\"\n#include \"chrome/browser/permissions/permission_context_base.h\"\n#include \"chrome/browser/permissions/permission_request_manager.h\"\n#include \"chrome/browser/platform_util.h\"\n#include \"chrome/browser/plugins/pdf_iframe_navigation_throttle.h\"\n#include \"chrome/browser/predictors/loading_predictor.h\"\n#include \"chrome/browser/predictors/loading_predictor_factory.h\"\n#include \"chrome/browser/prerender/prerender_final_status.h\"\n#include \"chrome/browser/prerender/prerender_manager.h\"\n#include \"chrome/browser/prerender/prerender_manager_factory.h\"\n#include \"chrome/browser/prerender/prerender_message_filter.h\"\n#include \"chrome/browser/prerender/prerender_util.h\"\n#include \"chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h\"\n#include \"chrome/browser/profiles/profile.h\"\n#include \"chrome/browser/profiles/profile_io_data.h\"\n#include \"chrome/browser/profiling_host/chrome_browser_main_extra_parts_profiling.h\"\n#include \"chrome/browser/profiling_host/profiling_process_host.h\"\n#include \"chrome/browser/renderer_host/chrome_navigation_ui_data.h\"\n#include \"chrome/browser/renderer_host/chrome_render_message_filter.h\"\n#include \"chrome/browser/renderer_host/pepper/chrome_browser_pepper_host_factory.h\"\n#include \"chrome/browser/resource_coordinator/background_tab_navigation_throttle.h\"\n#include \"chrome/browser/resource_coordinator/chrome_browser_main_extra_parts_resource_coordinator.h\"\n#include \"chrome/browser/safe_browsing/certificate_reporting_service.h\"\n#include \"chrome/browser/safe_browsing/certificate_reporting_service_factory.h\"\n#include \"chrome/browser/safe_browsing/chrome_password_protection_service.h\"\n#include \"chrome/browser/safe_browsing/safe_browsing_service.h\"\n#include \"chrome/browser/safe_browsing/ui_manager.h\"\n#include \"chrome/browser/safe_browsing/url_checker_delegate_impl.h\"\n#include \"chrome/browser/search/search.h\"\n#include \"chrome/browser/sessions/session_tab_helper.h\"\n#include \"chrome/browser/speech/chrome_speech_recognition_manager_delegate.h\"\n#include \"chrome/browser/speech/tts_controller.h\"\n#include \"chrome/browser/speech/tts_message_filter.h\"\n#include \"chrome/browser/ssl/insecure_sensitive_input_driver_factory.h\"\n#include \"chrome/browser/ssl/ssl_blocking_page.h\"\n#include \"chrome/browser/ssl/ssl_cert_reporter.h\"\n#include \"chrome/browser/ssl/ssl_client_certificate_selector.h\"\n#include \"chrome/browser/ssl/ssl_error_handler.h\"\n#include \"chrome/browser/ssl/ssl_error_navigation_throttle.h\"\n#include \"chrome/browser/ssl/typed_navigation_timing_throttle.h\"\n#include \"chrome/browser/subresource_filter/chrome_subresource_filter_client.h\"\n#include \"chrome/browser/sync_file_system/local/sync_file_system_backend.h\"\n#include \"chrome/browser/tab_contents/tab_util.h\"\n#include \"chrome/browser/tracing/chrome_tracing_delegate.h\"\n#include \"chrome/browser/ui/blocked_content/blocked_window_params.h\"\n#include \"chrome/browser/ui/blocked_content/popup_blocker_tab_helper.h\"\n#include \"chrome/browser/ui/blocked_content/tab_under_navigation_throttle.h\"\n#include \"chrome/browser/ui/browser.h\"\n#include \"chrome/browser/ui/browser_finder.h\"\n#include \"chrome/browser/ui/browser_list.h\"\n#include \"chrome/browser/ui/browser_navigator.h\"\n#include \"chrome/browser/ui/browser_navigator_params.h\"\n#include \"chrome/browser/ui/browser_window.h\"\n#include \"chrome/browser/ui/chrome_select_file_policy.h\"\n#include \"chrome/browser/ui/login/login_handler.h\"\n#include \"chrome/browser/ui/sync/sync_promo_ui.h\"\n#include \"chrome/browser/ui/tab_contents/chrome_web_contents_view_delegate.h\"\n#include \"chrome/browser/ui/webui/chrome_web_ui_controller_factory.h\"\n#include \"chrome/browser/ui/webui/log_web_ui_url.h\"\n#include \"chrome/browser/usb/usb_tab_helper.h\"\n#include \"chrome/browser/vr/vr_tab_helper.h\"\n#include \"chrome/browser/webauthn/authenticator_request_scheduler.h\"\n#include \"chrome/browser/webauthn/chrome_authenticator_request_delegate.h\"\n#include \"chrome/common/buildflags.h\"\n#include \"chrome/common/channel_info.h\"\n#include \"chrome/common/chrome_constants.h\"\n#include \"chrome/common/chrome_features.h\"\n#include \"chrome/common/chrome_paths.h\"\n#include \"chrome/common/chrome_switches.h\"\n#include \"chrome/common/constants.mojom.h\"\n#include \"chrome/common/env_vars.h\"\n#include \"chrome/common/logging_chrome.h\"\n#include \"chrome/common/pepper_permission_util.h\"\n#include \"chrome/common/pref_names.h\"\n#include \"chrome/common/prerender_url_loader_throttle.h\"\n#include \"chrome/common/render_messages.h\"\n#include \"chrome/common/renderer_configuration.mojom.h\"\n#include \"chrome/common/secure_origin_whitelist.h\"\n#include \"chrome/common/stack_sampling_configuration.h\"\n#include \"chrome/common/url_constants.h\"\n#include \"chrome/common/variations_header_url_loader_throttle.h\"\n#include \"chrome/grit/browser_resources.h\"\n#include \"chrome/grit/generated_resources.h\"\n#include \"chrome/installer/util/google_update_settings.h\"\n#include \"components/autofill/content/browser/content_autofill_driver_factory.h\"\n#include \"components/autofill/core/common/autofill_switches.h\"\n#include \"components/browsing_data/core/browsing_data_utils.h\"\n#include \"components/cdm/browser/cdm_message_filter_android.h\"\n#include \"components/cloud_devices/common/cloud_devices_switches.h\"\n#include \"components/content_settings/core/browser/content_settings_utils.h\"\n#include \"components/content_settings/core/browser/cookie_settings.h\"\n#include \"components/content_settings/core/browser/host_content_settings_map.h\"\n#include \"components/content_settings/core/common/content_settings.h\"\n#include \"components/content_settings/core/common/content_settings_types.h\"\n#include \"components/content_settings/core/common/content_settings_utils.h\"\n#include \"components/content_settings/core/common/pref_names.h\"\n#include \"components/dom_distiller/core/dom_distiller_switches.h\"\n#include \"components/dom_distiller/core/url_constants.h\"\n#include \"components/error_page/common/error_page_switches.h\"\n#include \"components/feature_engagement/public/feature_constants.h\"\n#include \"components/feature_engagement/public/feature_list.h\"\n#include \"components/google/core/browser/google_util.h\"\n#include \"components/metrics/call_stack_profile_collector.h\"\n#include \"components/metrics/client_info.h\"\n#include \"components/nacl/common/buildflags.h\"\n#include \"components/nacl/common/nacl_constants.h\"\n#include \"components/net_log/chrome_net_log.h\"\n#include \"components/password_manager/content/browser/content_password_manager_driver_factory.h\"\n#include \"components/payments/content/payment_request_display_manager.h\"\n#include \"components/policy/content/policy_blacklist_navigation_throttle.h\"\n#include \"components/pref_registry/pref_registry_syncable.h\"\n#include \"components/prefs/pref_registry_simple.h\"\n#include \"components/prefs/pref_service.h\"\n#include \"components/prefs/scoped_user_pref_update.h\"\n#include \"components/rappor/public/rappor_utils.h\"\n#include \"components/rappor/rappor_recorder_impl.h\"\n#include \"components/rappor/rappor_service_impl.h\"\n#include \"components/safe_browsing/browser/browser_url_loader_throttle.h\"\n#include \"components/safe_browsing/browser/mojo_safe_browsing_impl.h\"\n#include \"components/safe_browsing/browser/url_checker_delegate.h\"\n#include \"components/safe_browsing/common/safe_browsing_prefs.h\"\n#include \"components/safe_browsing/db/database_manager.h\"\n#include \"components/safe_browsing/features.h\"\n#include \"components/safe_browsing/password_protection/password_protection_navigation_throttle.h\"\n#include \"components/services/heap_profiling/public/mojom/constants.mojom.h\"\n#include \"components/services/patch/public/interfaces/constants.mojom.h\"\n#include \"components/services/unzip/public/interfaces/constants.mojom.h\"\n#include \"components/signin/core/browser/profile_management_switches.h\"\n#include \"components/spellcheck/spellcheck_buildflags.h\"\n#include \"components/subresource_filter/content/browser/content_subresource_filter_throttle_manager.h\"\n#include \"components/task_scheduler_util/variations_util.h\"\n#include \"components/translate/core/common/translate_switches.h\"\n#include \"components/url_formatter/url_fixer.h\"\n#include \"components/variations/variations_associated_data.h\"\n#include \"components/variations/variations_switches.h\"\n#include \"components/version_info/version_info.h\"\n#include \"content/public/browser/browser_child_process_host.h\"\n#include \"content/public/browser/browser_main_parts.h\"\n#include \"content/public/browser/browser_ppapi_host.h\"\n#include \"content/public/browser/browser_thread.h\"\n#include \"content/public/browser/browser_url_handler.h\"\n#include \"content/public/browser/browsing_data_remover.h\"\n#include \"content/public/browser/certificate_request_result_type.h\"\n#include \"content/public/browser/child_process_data.h\"\n#include \"content/public/browser/child_process_security_policy.h\"\n#include \"content/public/browser/client_certificate_delegate.h\"\n#include \"content/public/browser/file_url_loader.h\"\n#include \"content/public/browser/navigation_handle.h\"\n#include \"content/public/browser/navigation_throttle.h\"\n#include \"content/public/browser/overlay_window.h\"\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/render_process_host.h\"\n#include \"content/public/browser/render_view_host.h\"\n#include \"content/public/browser/resource_context.h\"\n#include \"content/public/browser/site_instance.h\"\n#include \"content/public/browser/storage_partition.h\"\n#include \"content/public/browser/url_loader_request_interceptor.h\"\n#include \"content/public/browser/vpn_service_proxy.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/browser/web_ui_url_loader_factory.h\"\n#include \"content/public/common/child_process_host.h\"\n#include \"content/public/common/content_descriptors.h\"\n#include \"content/public/common/content_features.h\"\n#include \"content/public/common/content_switches.h\"\n#include \"content/public/common/service_manager_connection.h\"\n#include \"content/public/common/service_names.mojom.h\"\n#include \"content/public/common/url_constants.h\"\n#include \"content/public/common/url_loader_throttle.h\"\n#include \"content/public/common/url_utils.h\"\n#include \"content/public/common/web_preferences.h\"\n#include \"device/usb/public/mojom/chooser_service.mojom.h\"\n#include \"device/usb/public/mojom/device_manager.mojom.h\"\n#include \"extensions/buildflags/buildflags.h\"\n#include \"google_apis/gaia/gaia_urls.h\"\n#include \"google_apis/google_api_keys.h\"\n#include \"gpu/config/gpu_switches.h\"\n#include \"media/audio/audio_manager.h\"\n#include \"media/base/media_switches.h\"\n#include \"media/media_buildflags.h\"\n#include \"media/mojo/buildflags.h\"\n#include \"mojo/public/cpp/bindings/binding_set.h\"\n#include \"mojo/public/cpp/bindings/scoped_interface_endpoint_handle.h\"\n#include \"net/base/load_flags.h\"\n#include \"net/base/mime_util.h\"\n#include \"net/cookies/canonical_cookie.h\"\n#include \"net/cookies/cookie_options.h\"\n#include \"net/ssl/client_cert_store.h\"\n#include \"net/ssl/ssl_cert_request_info.h\"\n#include \"ppapi/buildflags/buildflags.h\"\n#include \"ppapi/host/ppapi_host.h\"\n#include \"printing/buildflags/buildflags.h\"\n#include \"services/network/public/cpp/features.h\"\n#include \"services/network/public/cpp/resource_request.h\"\n#include \"services/preferences/public/cpp/in_process_service_factory.h\"\n#include \"services/preferences/public/mojom/preferences.mojom.h\"\n#include \"services/proxy_resolver/public/mojom/proxy_resolver.mojom.h\"\n#include \"services/service_manager/embedder/switches.h\"\n#include \"services/service_manager/public/cpp/connector.h\"\n#include \"services/service_manager/public/mojom/connector.mojom.h\"\n#include \"services/service_manager/sandbox/sandbox_type.h\"\n#include \"storage/browser/fileapi/external_mount_points.h\"\n#include \"third_party/blink/public/mojom/page/page_visibility_state.mojom.h\"\n#include \"third_party/blink/public/platform/modules/installedapp/installed_app_provider.mojom.h\"\n#include \"third_party/blink/public/platform/modules/webshare/webshare.mojom.h\"\n#include \"ui/base/l10n/l10n_util.h\"\n#include \"ui/base/resource/resource_bundle.h\"\n#include \"ui/base/ui_base_features.h\"\n#include \"ui/base/ui_features.h\"\n#include \"ui/resources/grit/ui_resources.h\"\n#include \"url/gurl.h\"\n#include \"url/origin.h\"\n\n#if defined(OS_WIN)\n#include \"base/strings/string_tokenizer.h\"\n#include \"chrome/browser/chrome_browser_main_win.h\"\n#include \"chrome/browser/conflicts/module_database_win.h\"\n#include \"chrome/browser/conflicts/module_event_sink_impl_win.h\"\n#include \"chrome/services/util_win/public/mojom/constants.mojom.h\"\n#include \"chrome/services/wifi_util_win/public/mojom/constants.mojom.h\"\n#include \"sandbox/win/src/sandbox_policy.h\"\n#elif defined(OS_MACOSX)\n#include \"chrome/browser/chrome_browser_main_mac.h\"\n#include \"services/audio/public/mojom/constants.mojom.h\"\n#include \"services/video_capture/public/mojom/constants.mojom.h\"\n#elif defined(OS_CHROMEOS)\n#include \"ash/public/interfaces/constants.mojom.h\"\n#include \"chrome/browser/ash_service_registry.h\"\n#include \"chrome/browser/chromeos/apps/intent_helper/apps_navigation_throttle.h\"\n#include \"chrome/browser/chromeos/arc/fileapi/arc_content_file_system_backend_delegate.h\"\n#include \"chrome/browser/chromeos/arc/fileapi/arc_documents_provider_backend_delegate.h\"\n#include \"chrome/browser/chromeos/chrome_browser_main_chromeos.h\"\n#include \"chrome/browser/chromeos/chrome_content_browser_client_chromeos_part.h\"\n#include \"chrome/browser/chromeos/chrome_service_name.h\"\n#include \"chrome/browser/chromeos/drive/fileapi/file_system_backend_delegate.h\"\n#include \"chrome/browser/chromeos/file_manager/app_id.h\"\n#include \"chrome/browser/chromeos/file_system_provider/fileapi/backend_delegate.h\"\n#include \"chrome/browser/chromeos/fileapi/file_system_backend.h\"\n#include \"chrome/browser/chromeos/fileapi/mtp_file_system_backend_delegate.h\"\n#include \"chrome/browser/chromeos/login/signin/merge_session_navigation_throttle.h\"\n#include \"chrome/browser/chromeos/login/signin/merge_session_throttling_utils.h\"\n#include \"chrome/browser/chromeos/login/signin_partition_manager.h\"\n#include \"chrome/browser/chromeos/login/startup_utils.h\"\n#include \"chrome/browser/chromeos/policy/browser_policy_connector_chromeos.h\"\n#include \"chrome/browser/chromeos/profiles/profile_helper.h\"\n#include \"chrome/browser/chromeos/system/input_device_settings.h\"\n#include \"chrome/browser/ui/ash/chrome_browser_main_extra_parts_ash.h\"\n#include \"chrome/browser/ui/browser_dialogs.h\"\n#include \"chromeos/chromeos_constants.h\"\n#include \"chromeos/chromeos_switches.h\"\n#include \"components/user_manager/user_manager.h\"\n#include \"services/service_manager/public/mojom/interface_provider_spec.mojom.h\"\n#elif defined(OS_LINUX)\n#include \"chrome/browser/chrome_browser_main_linux.h\"\n#elif defined(OS_ANDROID)\n#include \"base/android/application_status_listener.h\"\n#include \"chrome/browser/android/app_hooks.h\"\n#include \"chrome/browser/android/chrome_context_util.h\"\n#include \"chrome/browser/android/devtools_manager_delegate_android.h\"\n#include \"chrome/browser/android/download/intercept_oma_download_navigation_throttle.h\"\n#include \"chrome/browser/android/ntp/new_tab_page_url_handler.h\"\n#include \"chrome/browser/android/service_tab_launcher.h\"\n#include \"chrome/browser/android/tab_android.h\"\n#include \"chrome/browser/android/webapps/single_tab_mode_tab_helper.h\"\n#include \"chrome/browser/chrome_browser_main_android.h\"\n#include \"chrome/common/descriptors_android.h\"\n#include \"chrome/services/media_gallery_util/public/mojom/constants.mojom.h\"\n#include \"components/crash/content/browser/crash_dump_observer_android.h\"\n#include \"components/navigation_interception/intercept_navigation_delegate.h\"\n#include \"content/public/browser/android/java_interfaces.h\"\n#include \"services/proxy_resolver/proxy_resolver_service.h\"\n#include \"services/service_manager/public/cpp/interface_provider.h\"\n#include \"third_party/blink/public/platform/modules/payments/payment_request.mojom.h\"\n#include \"third_party/blink/public/platform/modules/webauth/authenticator.mojom.h\"\n#include \"ui/base/resource/resource_bundle_android.h\"\n#include \"ui/base/ui_base_paths.h\"\n#elif defined(OS_POSIX)\n#include \"chrome/browser/chrome_browser_main_posix.h\"\n#endif\n\n#if !defined(OS_ANDROID)\n#include \"chrome/browser/devtools/chrome_devtools_manager_delegate.h\"\n#include \"chrome/browser/devtools/devtools_window.h\"\n#include \"chrome/browser/payments/payment_request_factory.h\"\n#include \"chrome/browser/search/instant_service.h\"\n#include \"chrome/browser/search/instant_service_factory.h\"\n#include \"chrome/browser/ui/search/new_tab_page_navigation_throttle.h\"\n#include \"chrome/common/importer/profile_import.mojom.h\"\n#endif\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n#include \"chrome/browser/webshare/share_service_impl.h\"\n#endif\n\n#if defined(OS_POSIX) && !defined(OS_MACOSX)\n#include \"base/debug/leak_annotations.h\"\n#include \"components/crash/content/app/breakpad_linux.h\"\n#include \"components/crash/content/browser/crash_handler_host_linux.h\"\n#endif\n\n#if defined(TOOLKIT_VIEWS)\n#include \"chrome/browser/ui/views/chrome_browser_main_extra_parts_views.h\"\n#endif\n\n#if defined(OS_LINUX) && !defined(OS_CHROMEOS)\n#include \"chrome/browser/ui/views/chrome_browser_main_extra_parts_views_linux.h\"\n#endif\n\n#if defined(USE_X11)\n#include \"chrome/browser/chrome_browser_main_extra_parts_x11.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_CAPTIVE_PORTAL_DETECTION)\n#include \"chrome/browser/captive_portal/captive_portal_tab_helper.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_NACL)\n#include \"components/nacl/browser/nacl_browser.h\"\n#include \"components/nacl/browser/nacl_host_message_filter.h\"\n#include \"components/nacl/browser/nacl_process_host.h\"\n#include \"components/nacl/common/nacl_process_type.h\"\n#include \"components/nacl/common/nacl_switches.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n#include \"chrome/browser/accessibility/animation_policy_prefs.h\"\n#include \"chrome/browser/apps/platform_app_navigation_redirector.h\"\n#include \"chrome/browser/extensions/bookmark_app_experimental_navigation_throttle.h\"\n#include \"chrome/browser/extensions/bookmark_app_navigation_throttle.h\"\n#include \"chrome/browser/extensions/chrome_content_browser_client_extensions_part.h\"\n#include \"chrome/browser/extensions/chrome_extension_web_contents_observer.h\"\n#include \"chrome/browser/speech/extension_api/tts_engine_extension_api.h\"\n#include \"chrome/browser/ui/extensions/hosted_app_browser_controller.h\"\n#include \"chrome/services/media_gallery_util/public/mojom/constants.mojom.h\"\n#include \"chrome/services/removable_storage_writer/public/mojom/constants.mojom.h\"\n#include \"components/guest_view/browser/guest_view_base.h\"\n#include \"components/guest_view/browser/guest_view_manager.h\"\n#include \"extensions/browser/api/web_request/web_request_api.h\"\n#include \"extensions/browser/extension_host.h\"\n#include \"extensions/browser/extension_navigation_throttle.h\"\n#include \"extensions/browser/extension_protocols.h\"\n#include \"extensions/browser/extension_registry.h\"\n#include \"extensions/browser/extension_system.h\"\n#include \"extensions/browser/extension_util.h\"\n#include \"extensions/browser/guest_view/web_view/web_view_guest.h\"\n#include \"extensions/browser/guest_view/web_view/web_view_permission_helper.h\"\n#include \"extensions/browser/guest_view/web_view/web_view_renderer_state.h\"\n#include \"extensions/browser/process_manager.h\"\n#include \"extensions/common/constants.h\"\n#include \"extensions/common/extension.h\"\n#include \"extensions/common/extension_set.h\"\n#include \"extensions/common/manifest_handlers/background_info.h\"\n#include \"extensions/common/manifest_handlers/shared_module_info.h\"\n#include \"extensions/common/permissions/permissions_data.h\"\n#include \"extensions/common/permissions/socket_permission.h\"\n#include \"extensions/common/switches.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n#include \"chrome/browser/media/cast_transport_host_filter.h\"\n#endif  // BUILDFLAG(ENABLE_EXTENSIONS)\n\n#if BUILDFLAG(ENABLE_MUS)\n#include \"services/ui/public/interfaces/constants.mojom.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n#include \"chrome/browser/plugins/chrome_content_browser_client_plugins_part.h\"\n#include \"chrome/browser/plugins/flash_download_interception.h\"\n#include \"chrome/browser/plugins/plugin_response_interceptor_url_loader_throttle.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n#include \"chrome/browser/supervised_user/supervised_user_google_auth_navigation_throttle.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_MEDIA_REMOTING)\n#include \"chrome/browser/media/cast_remoting_connector.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PRINTING)\n#include \"chrome/browser/printing/printing_message_filter.h\"\n#include \"components/services/pdf_compositor/public/interfaces/pdf_compositor.mojom.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PRINT_PREVIEW) || \\\n    (BUILDFLAG(ENABLE_PRINTING) && defined(OS_WIN))\n#include \"chrome/services/printing/public/mojom/constants.mojom.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_MOJO_MEDIA)\n#include \"chrome/browser/media/output_protection_impl.h\"\n#if BUILDFLAG(ENABLE_MOJO_CDM) && defined(OS_ANDROID)\n#include \"chrome/browser/media/android/cdm/media_drm_storage_factory.h\"\n#endif\n#endif\n\n#if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_BROWSER_PROCESS)\n#include \"media/mojo/interfaces/constants.mojom.h\"      // nogncheck\n#include \"media/mojo/services/media_service_factory.h\"  // nogncheck\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n#include \"chrome/browser/supervised_user/supervised_user_navigation_throttle.h\"\n#endif\n\n#if defined(FULL_SAFE_BROWSING) || defined(OS_CHROMEOS)\n#include \"chrome/services/file_util/public/mojom/constants.mojom.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_OFFLINE_PAGES)\n#include \"chrome/browser/offline_pages/offline_page_url_loader_request_interceptor.h\"\n#endif\n\nusing base::FileDescriptor;\nusing content::BrowserThread;\nusing content::BrowserURLHandler;\nusing content::BrowsingDataFilterBuilder;\nusing content::ChildProcessSecurityPolicy;\nusing content::QuotaPermissionContext;\nusing content::RenderFrameHost;\nusing content::RenderViewHost;\nusing content::ResourceType;\nusing content::SiteInstance;\nusing content::WebContents;\nusing content::WebPreferences;\nusing message_center::NotifierId;\n\n#if defined(OS_POSIX)\nusing content::PosixFileDescriptorInfo;\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\nusing extensions::APIPermission;\nusing extensions::ChromeContentBrowserClientExtensionsPart;\nusing extensions::Extension;\nusing extensions::Manifest;\n#endif\n\n#if BUILDFLAG(ENABLE_PLUGINS)\nusing plugins::ChromeContentBrowserClientPluginsPart;\n#endif\n\nnamespace {\n\n// Cached version of the locale so we can return the locale on the I/O\n// thread.\nbase::LazyInstance<std::string>::DestructorAtExit\n    g_io_thread_application_locale = LAZY_INSTANCE_INITIALIZER;\n\nconst storage::QuotaSettings* g_default_quota_settings;\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n// TODO(teravest): Add renderer-side API-specific checking for these APIs so\n// that blanket permission isn't granted to all dev channel APIs for these.\n// http://crbug.com/386743\nconst char* const kPredefinedAllowedDevChannelOrigins[] = {\n  \"6EAED1924DB611B6EEF2A664BD077BE7EAD33B8F\",  // see crbug.com/383937\n  \"4EB74897CB187C7633357C2FE832E0AD6A44883A\"   // see crbug.com/383937\n};\n\nconst char* const kPredefinedAllowedFileHandleOrigins[] = {\n  \"6EAED1924DB611B6EEF2A664BD077BE7EAD33B8F\",  // see crbug.com/234789\n  \"4EB74897CB187C7633357C2FE832E0AD6A44883A\"   // see crbug.com/234789\n};\n\nconst char* const kPredefinedAllowedSocketOrigins[] = {\n  \"okddffdblfhhnmhodogpojmfkjmhinfp\",  // Secure Shell App (dev)\n  \"pnhechapfaindjhompbnflcldabbghjo\",  // Secure Shell App (stable)\n  \"algkcnfjnajfhgimadimbjhmpaeohhln\",  // Secure Shell Extension (dev)\n  \"iodihamcpbpeioajjeobimgagajmlibd\",  // Secure Shell Extension (stable)\n  \"bglhmjfplikpjnfoegeomebmfnkjomhe\",  // see crbug.com/122126\n  \"gbchcmhmhahfdphkhkmpfmihenigjmpp\",  // Chrome Remote Desktop\n  \"kgngmbheleoaphbjbaiobfdepmghbfah\",  // Pre-release Chrome Remote Desktop\n  \"odkaodonbgfohohmklejpjiejmcipmib\",  // Dogfood Chrome Remote Desktop\n  \"ojoimpklfciegopdfgeenehpalipignm\",  // Chromoting canary\n  \"cbkkbcmdlboombapidmoeolnmdacpkch\",  // see crbug.com/129089\n  \"hhnbmknkdabfoieppbbljkhkfjcmcbjh\",  // see crbug.com/134099\n  \"mablfbjkhmhkmefkjjacnbaikjkipphg\",  // see crbug.com/134099\n  \"pdeelgamlgannhelgoegilelnnojegoh\",  // see crbug.com/134099\n  \"cabapfdbkniadpollkckdnedaanlciaj\",  // see crbug.com/134099\n  \"mapljbgnjledlpdmlchihnmeclmefbba\",  // see crbug.com/134099\n  \"ghbfeebgmiidnnmeobbbaiamklmpbpii\",  // see crbug.com/134099\n  \"jdfhpkjeckflbbleddjlpimecpbjdeep\",  // see crbug.com/142514\n  \"iabmpiboiopbgfabjmgeedhcmjenhbla\",  // see crbug.com/165080\n  \"B7CF8A292249681AF81771650BA4CEEAF19A4560\",  // see crbug.com/165080\n  \"7525AF4F66763A70A883C4700529F647B470E4D2\",  // see crbug.com/238084\n  \"0B549507088E1564D672F7942EB87CA4DAD73972\",  // see crbug.com/238084\n  \"864288364E239573E777D3E0E36864E590E95C74\"   // see crbug.com/238084\n};\n#endif\n\nenum AppLoadedInTabSource {\n  // A platform app page tried to load one of its own URLs in a tab.\n  APP_LOADED_IN_TAB_SOURCE_APP = 0,\n\n  // A platform app background page tried to load one of its own URLs in a tab.\n  APP_LOADED_IN_TAB_SOURCE_BACKGROUND_PAGE,\n\n  // An extension or app tried to load a resource of a different platform app in\n  // a tab.\n  APP_LOADED_IN_TAB_SOURCE_OTHER_EXTENSION,\n\n  // A non-app and non-extension page tried to load a platform app in a tab.\n  APP_LOADED_IN_TAB_SOURCE_OTHER,\n\n  APP_LOADED_IN_TAB_SOURCE_MAX\n};\n\n// Returns a copy of the given url with its host set to given host and path set\n// to given path. Other parts of the url will be the same.\nGURL ReplaceURLHostAndPath(const GURL& url,\n                           const std::string& host,\n                           const std::string& path) {\n  url::Replacements<char> replacements;\n  replacements.SetHost(host.c_str(), url::Component(0, host.length()));\n  replacements.SetPath(path.c_str(), url::Component(0, path.length()));\n  return url.ReplaceComponents(replacements);\n}\n\n// Handles the rewriting of the new tab page URL based on group policy.\nbool HandleNewTabPageLocationOverride(\n    GURL* url,\n    content::BrowserContext* browser_context) {\n  if (!url->SchemeIs(content::kChromeUIScheme) ||\n      url->host() != chrome::kChromeUINewTabHost)\n    return false;\n\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  std::string ntp_location =\n      profile->GetPrefs()->GetString(prefs::kNewTabPageLocationOverride);\n  if (ntp_location.empty())\n    return false;\n\n  *url = GURL(ntp_location);\n  return true;\n}\n\nbool CertMatchesFilter(const net::X509Certificate& cert,\n                       const base::DictionaryValue& filter) {\n  // TODO(markusheintz): This is the minimal required filter implementation.\n  // Implement a better matcher.\n\n  // An empty filter matches any client certificate since no requirements are\n  // specified at all.\n  if (filter.empty())\n    return true;\n\n  std::string common_name;\n  if (filter.GetString(\"ISSUER.CN\", &common_name) &&\n      (cert.issuer().common_name == common_name)) {\n    return true;\n  }\n  return false;\n}\n\n#if !defined(OS_ANDROID)\n// Check if the current url is whitelisted based on a list of whitelisted urls.\nbool IsURLWhitelisted(const GURL& current_url,\n                      const base::Value::ListStorage& whitelisted_urls) {\n  // Only check on HTTP and HTTPS pages.\n  if (!current_url.SchemeIsHTTPOrHTTPS())\n    return false;\n\n  for (auto const& value : whitelisted_urls) {\n    ContentSettingsPattern pattern =\n        ContentSettingsPattern::FromString(value.GetString());\n    if (pattern == ContentSettingsPattern::Wildcard() || !pattern.IsValid())\n      continue;\n    if (pattern.Matches(current_url))\n      return true;\n  }\n\n  return false;\n}\n\n// Check if autoplay is allowed by policy configuration.\nbool IsAutoplayAllowedByPolicy(content::WebContents* contents,\n                               PrefService* prefs) {\n  DCHECK(prefs);\n\n  // Check if we have globally allowed autoplay by policy.\n  if (prefs->GetBoolean(prefs::kAutoplayAllowed) &&\n      prefs->IsManagedPreference(prefs::kAutoplayAllowed)) {\n    return true;\n  }\n\n  if (!contents)\n    return false;\n\n  // Check if the current URL matches a URL pattern on the whitelist.\n  const base::ListValue* autoplay_whitelist =\n      prefs->GetList(prefs::kAutoplayWhitelist);\n  return autoplay_whitelist &&\n         prefs->IsManagedPreference(prefs::kAutoplayWhitelist) &&\n         IsURLWhitelisted(contents->GetURL(), autoplay_whitelist->GetList());\n}\n#endif\n\n#if defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MACOSX)\nbreakpad::CrashHandlerHostLinux* CreateCrashHandlerHost(\n    const std::string& process_type) {\n  base::FilePath dumps_path;\n  base::PathService::Get(chrome::DIR_CRASH_DUMPS, &dumps_path);\n  {\n    ANNOTATE_SCOPED_MEMORY_LEAK;\n    bool upload = (getenv(env_vars::kHeadless) == NULL);\n    breakpad::CrashHandlerHostLinux* crash_handler =\n        new breakpad::CrashHandlerHostLinux(process_type, dumps_path, upload);\n    crash_handler->StartUploaderThread();\n    return crash_handler;\n  }\n}\n\nint GetCrashSignalFD(const base::CommandLine& command_line) {\n  // Extensions have the same process type as renderers.\n  if (command_line.HasSwitch(extensions::switches::kExtensionProcess)) {\n    static breakpad::CrashHandlerHostLinux* crash_handler = NULL;\n    if (!crash_handler)\n      crash_handler = CreateCrashHandlerHost(\"extension\");\n    return crash_handler->GetDeathSignalSocket();\n  }\n\n#if defined(OS_CHROMEOS)\n  // Mash services are utility processes, but crashes are reported using the\n  // service name as the process type to make the crash console easier to read.\n  if (command_line.HasSwitch(switches::kMashServiceName)) {\n    static base::NoDestructor<\n        std::map<std::string, breakpad::CrashHandlerHostLinux*>>\n        crash_handlers;\n    std::string service_name =\n        command_line.GetSwitchValueASCII(switches::kMashServiceName);\n    auto it = crash_handlers->find(service_name);\n    if (it == crash_handlers->end()) {\n      crash_handlers->insert(\n          std::make_pair(service_name, CreateCrashHandlerHost(service_name)));\n    }\n    return crash_handlers->at(service_name)->GetDeathSignalSocket();\n  }\n#endif  // defined(OS_CHROMEOS)\n\n  std::string process_type =\n      command_line.GetSwitchValueASCII(switches::kProcessType);\n\n  if (process_type == switches::kRendererProcess) {\n    static breakpad::CrashHandlerHostLinux* crash_handler = NULL;\n    if (!crash_handler)\n      crash_handler = CreateCrashHandlerHost(process_type);\n    return crash_handler->GetDeathSignalSocket();\n  }\n\n  if (process_type == switches::kPpapiPluginProcess) {\n    static breakpad::CrashHandlerHostLinux* crash_handler = NULL;\n    if (!crash_handler)\n      crash_handler = CreateCrashHandlerHost(process_type);\n    return crash_handler->GetDeathSignalSocket();\n  }\n\n  if (process_type == switches::kGpuProcess) {\n    static breakpad::CrashHandlerHostLinux* crash_handler = NULL;\n    if (!crash_handler)\n      crash_handler = CreateCrashHandlerHost(process_type);\n    return crash_handler->GetDeathSignalSocket();\n  }\n\n  if (process_type == switches::kUtilityProcess) {\n    static breakpad::CrashHandlerHostLinux* crash_handler = nullptr;\n    if (!crash_handler)\n      crash_handler = CreateCrashHandlerHost(process_type);\n    return crash_handler->GetDeathSignalSocket();\n  }\n\n  return -1;\n}\n#endif  // defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MACOSX)\n\nvoid SetApplicationLocaleOnIOThread(const std::string& locale) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  g_io_thread_application_locale.Get() = locale;\n}\n\n// An implementation of the SSLCertReporter interface used by\n// SSLErrorHandler. Uses CertificateReportingService to send reports. The\n// service handles queueing and re-sending of failed reports. Each certificate\n// error creates a new instance of this class.\nclass CertificateReportingServiceCertReporter : public SSLCertReporter {\n public:\n  explicit CertificateReportingServiceCertReporter(\n      content::WebContents* web_contents)\n      : service_(CertificateReportingServiceFactory::GetForBrowserContext(\n            web_contents->GetBrowserContext())) {}\n  ~CertificateReportingServiceCertReporter() override {}\n\n  // SSLCertReporter implementation\n  void ReportInvalidCertificateChain(\n      const std::string& serialized_report) override {\n    service_->Send(serialized_report);\n  }\n\n private:\n  CertificateReportingService* service_;\n\n  DISALLOW_COPY_AND_ASSIGN(CertificateReportingServiceCertReporter);\n};\n\n#if defined(OS_ANDROID)\nfloat GetDeviceScaleAdjustment() {\n  static const float kMinFSM = 1.05f;\n  static const int kWidthForMinFSM = 320;\n  static const float kMaxFSM = 1.3f;\n  static const int kWidthForMaxFSM = 800;\n\n  int minWidth = chrome::android::ChromeContextUtil::GetSmallestDIPWidth();\n\n  if (minWidth <= kWidthForMinFSM)\n    return kMinFSM;\n  if (minWidth >= kWidthForMaxFSM)\n    return kMaxFSM;\n\n  // The font scale multiplier varies linearly between kMinFSM and kMaxFSM.\n  float ratio = static_cast<float>(minWidth - kWidthForMinFSM) /\n      (kWidthForMaxFSM - kWidthForMinFSM);\n  return ratio * (kMaxFSM - kMinFSM) + kMinFSM;\n}\n\n#endif  // defined(OS_ANDROID)\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n// By default, JavaScript, images and autoplay are enabled in guest content.\nvoid GetGuestViewDefaultContentSettingRules(\n    bool incognito,\n    RendererContentSettingRules* rules) {\n  rules->image_rules.push_back(ContentSettingPatternSource(\n      ContentSettingsPattern::Wildcard(), ContentSettingsPattern::Wildcard(),\n      base::Value::FromUniquePtrValue(\n          content_settings::ContentSettingToValue(CONTENT_SETTING_ALLOW)),\n      std::string(), incognito));\n\n  rules->script_rules.push_back(ContentSettingPatternSource(\n      ContentSettingsPattern::Wildcard(), ContentSettingsPattern::Wildcard(),\n      base::Value::FromUniquePtrValue(\n          content_settings::ContentSettingToValue(CONTENT_SETTING_ALLOW)),\n      std::string(), incognito));\n  rules->autoplay_rules.push_back(ContentSettingPatternSource(\n      ContentSettingsPattern::Wildcard(), ContentSettingsPattern::Wildcard(),\n      base::Value::FromUniquePtrValue(\n          content_settings::ContentSettingToValue(CONTENT_SETTING_ALLOW)),\n      std::string(), incognito));\n  rules->client_hints_rules.push_back(ContentSettingPatternSource(\n      ContentSettingsPattern::Wildcard(), ContentSettingsPattern::Wildcard(),\n      base::Value::FromUniquePtrValue(\n          content_settings::ContentSettingToValue(CONTENT_SETTING_BLOCK)),\n      std::string(), incognito));\n}\n\nAppLoadedInTabSource ClassifyAppLoadedInTabSource(\n    const GURL& opener_url,\n    const extensions::Extension* target_platform_app) {\n  if (opener_url.SchemeIs(extensions::kExtensionScheme)) {\n    if (opener_url.host_piece() == target_platform_app->id()) {\n      // This platform app was trying to window.open() one of its own URLs.\n      if (opener_url ==\n          extensions::BackgroundInfo::GetBackgroundURL(target_platform_app)) {\n        // Source was the background page.\n        return APP_LOADED_IN_TAB_SOURCE_BACKGROUND_PAGE;\n      } else {\n        // Source was a different page inside the app.\n        return APP_LOADED_IN_TAB_SOURCE_APP;\n      }\n    }\n    // The forbidden app URL was being opened by a different app or extension.\n    return APP_LOADED_IN_TAB_SOURCE_OTHER_EXTENSION;\n  }\n  // The forbidden app URL was being opened by a non-extension page (e.g. http).\n  return APP_LOADED_IN_TAB_SOURCE_OTHER;\n}\n#endif  // BUILDFLAG(ENABLE_EXTENSIONS)\n\nvoid CreateBudgetService(blink::mojom::BudgetServiceRequest request,\n                         content::RenderFrameHost* render_frame_host) {\n  BudgetServiceImpl::Create(std::move(request), render_frame_host->GetProcess(),\n                            render_frame_host->GetLastCommittedOrigin());\n}\n\nbool GetDataSaverEnabledPref(const PrefService* prefs) {\n  // Enable data saver only when data saver pref is enabled and not part of\n  // \"Disabled\" group of \"SaveDataHeader\" experiment.\n  return prefs->GetBoolean(prefs::kDataSaverEnabled) &&\n         base::FieldTrialList::FindFullName(\"SaveDataHeader\")\n             .compare(\"Disabled\");\n}\n\nWebContents* GetWebContents(int render_process_id, int render_frame_id) {\n  RenderFrameHost* rfh =\n      RenderFrameHost::FromID(render_process_id, render_frame_id);\n  return WebContents::FromRenderFrameHost(rfh);\n}\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n// Returns true if there is is an extension matching |url| in\n// |opener_render_process_id| with APIPermission::kBackground.\n//\n// Note that GetExtensionOrAppByURL requires a full URL in order to match with a\n// hosted app, even though normal extensions just use the host.\nbool URLHasExtensionBackgroundPermission(\n    extensions::ProcessMap* process_map,\n    extensions::ExtensionRegistry* registry,\n    const GURL& url,\n    int opener_render_process_id) {\n  // Note: includes web URLs that are part of an extension's web extent.\n  const Extension* extension =\n      registry->enabled_extensions().GetExtensionOrAppByURL(url);\n  return extension &&\n         extension->permissions_data()->HasAPIPermission(\n             APIPermission::kBackground) &&\n         process_map->Contains(extension->id(), opener_render_process_id);\n}\n\nvoid InvokeCallbackOnThread(\n    scoped_refptr<base::SequencedTaskRunner> task_runner,\n    base::Callback<void(bool)> callback,\n    bool result) {\n  task_runner->PostTask(FROM_HERE, base::Bind(std::move(callback), result));\n}\n#endif\n\n// Gets the URL request context getter for the browser process.\n// Must be called on the UI thread.\nscoped_refptr<net::URLRequestContextGetter>\nGetSystemRequestContextOnUIThread() {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  return scoped_refptr<net::URLRequestContextGetter>(\n      g_browser_process->system_request_context());\n}\n\nchrome::mojom::PrerenderCanceler* GetPrerenderCanceller(\n    const base::Callback<content::WebContents*()>& wc_getter) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  auto* web_contents = wc_getter.Run();\n  if (!web_contents)\n    return nullptr;\n\n  return prerender::PrerenderContents::FromWebContents(web_contents);\n}\n\nvoid LaunchURL(\n    const GURL& url,\n    const content::ResourceRequestInfo::WebContentsGetter& web_contents_getter,\n    ui::PageTransition page_transition,\n    bool has_user_gesture) {\n  // If there is no longer a WebContents, the request may have raced with tab\n  // closing. Don't fire the external request. (It may have been a prerender.)\n  content::WebContents* web_contents = web_contents_getter.Run();\n  if (!web_contents)\n    return;\n\n  // Do not launch external requests attached to unswapped prerenders.\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(web_contents);\n  if (prerender_contents) {\n    prerender_contents->Destroy(prerender::FINAL_STATUS_UNSUPPORTED_SCHEME);\n    prerender::ReportPrerenderExternalURL();\n    return;\n  }\n\n  bool is_whitelisted = false;\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  PolicyBlacklistService* service =\n      PolicyBlacklistFactory::GetForProfile(profile);\n  if (service) {\n    const policy::URLBlacklist::URLBlacklistState url_state =\n        service->GetURLBlacklistState(url);\n    is_whitelisted =\n        url_state == policy::URLBlacklist::URLBlacklistState::URL_IN_WHITELIST;\n  }\n\n  // If the URL is in whitelist, we launch it without asking the user and\n  // without any additional security checks. Since the URL is whitelisted,\n  // we assume it can be executed.\n  if (is_whitelisted) {\n    ExternalProtocolHandler::LaunchUrlWithoutSecurityCheck(url, web_contents);\n  } else {\n    ExternalProtocolHandler::LaunchUrl(\n        url, web_contents->GetRenderViewHost()->GetProcess()->GetID(),\n        web_contents->GetRenderViewHost()->GetRoutingID(), page_transition,\n        has_user_gesture);\n  }\n}\n\n}  // namespace\n\nChromeContentBrowserClient::ChromeContentBrowserClient(\n    std::unique_ptr<ui::DataPack> data_pack)\n    : weak_factory_(this) {\n#if BUILDFLAG(ENABLE_PLUGINS)\n  for (size_t i = 0; i < arraysize(kPredefinedAllowedDevChannelOrigins); ++i)\n    allowed_dev_channel_origins_.insert(kPredefinedAllowedDevChannelOrigins[i]);\n  for (size_t i = 0; i < arraysize(kPredefinedAllowedFileHandleOrigins); ++i)\n    allowed_file_handle_origins_.insert(kPredefinedAllowedFileHandleOrigins[i]);\n  for (size_t i = 0; i < arraysize(kPredefinedAllowedSocketOrigins); ++i)\n    allowed_socket_origins_.insert(kPredefinedAllowedSocketOrigins[i]);\n\n  extra_parts_.push_back(new ChromeContentBrowserClientPluginsPart);\n#endif\n\n#if !defined(OS_ANDROID)\n  TtsExtensionEngine* tts_extension_engine = TtsExtensionEngine::GetInstance();\n  TtsController::GetInstance()->SetTtsEngineDelegate(tts_extension_engine);\n#endif\n\n#if defined(OS_CHROMEOS)\n  extra_parts_.push_back(new ChromeContentBrowserClientChromeOsPart);\n#endif  // defined(OS_CHROMEOS)\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  extra_parts_.push_back(new ChromeContentBrowserClientExtensionsPart);\n#endif\n\n  gpu_binder_registry_.AddInterface(\n      base::Bind(&metrics::CallStackProfileCollector::Create,\n                 metrics::CallStackProfileParams::GPU_PROCESS));\n\n  service_manifest_data_pack_ = std::move(data_pack);\n}\n\nChromeContentBrowserClient::~ChromeContentBrowserClient() {\n  for (int i = static_cast<int>(extra_parts_.size()) - 1; i >= 0; --i)\n    delete extra_parts_[i];\n  extra_parts_.clear();\n}\n\n// static\nvoid ChromeContentBrowserClient::RegisterLocalStatePrefs(\n    PrefRegistrySimple* registry) {\n  registry->RegisterStringPref(prefs::kIsolateOrigins, std::string());\n  registry->RegisterBooleanPref(prefs::kSitePerProcess, false);\n  registry->RegisterBooleanPref(prefs::kWebDriverOverridesIncompatiblePolicies,\n                                false);\n}\n\n// static\nvoid ChromeContentBrowserClient::RegisterProfilePrefs(\n    user_prefs::PrefRegistrySyncable* registry) {\n  registry->RegisterBooleanPref(prefs::kDisable3DAPIs, false);\n  registry->RegisterBooleanPref(prefs::kEnableHyperlinkAuditing, true);\n  registry->RegisterListPref(prefs::kEnableDeprecatedWebPlatformFeatures);\n  // Register user prefs for mapping SitePerProcess and IsolateOrigins in\n  // user policy in addition to the same named ones in Local State (which are\n  // used for mapping the command-line flags).\n  registry->RegisterStringPref(prefs::kIsolateOrigins, std::string());\n  registry->RegisterBooleanPref(prefs::kSitePerProcess, false);\n#if !defined(OS_ANDROID)\n  registry->RegisterBooleanPref(prefs::kAutoplayAllowed, false);\n  registry->RegisterListPref(prefs::kAutoplayWhitelist);\n#endif\n}\n\n// static\nvoid ChromeContentBrowserClient::SetApplicationLocale(\n    const std::string& locale) {\n  // The common case is that this function is called early in Chrome startup\n  // before any threads are created or registered. When there are no threads,\n  // we can just set the string without worrying about threadsafety.\n  if (!BrowserThread::IsThreadInitialized(BrowserThread::IO)) {\n    g_io_thread_application_locale.Get() = locale;\n    return;\n  }\n\n  // Otherwise we're being called to change the locale. In this case set it on\n  // the IO thread.\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::BindOnce(&SetApplicationLocaleOnIOThread, locale));\n}\n\ncontent::BrowserMainParts* ChromeContentBrowserClient::CreateBrowserMainParts(\n    const content::MainFunctionParams& parameters) {\n  ChromeBrowserMainParts* main_parts;\n  // Construct the Main browser parts based on the OS type.\n#if defined(OS_WIN)\n  main_parts = new ChromeBrowserMainPartsWin(\n      parameters, std::move(service_manifest_data_pack_));\n#elif defined(OS_MACOSX)\n  main_parts = new ChromeBrowserMainPartsMac(\n      parameters, std::move(service_manifest_data_pack_));\n#elif defined(OS_CHROMEOS)\n  main_parts = new chromeos::ChromeBrowserMainPartsChromeos(\n      parameters, std::move(service_manifest_data_pack_));\n#elif defined(OS_LINUX)\n  main_parts = new ChromeBrowserMainPartsLinux(\n      parameters, std::move(service_manifest_data_pack_));\n#elif defined(OS_ANDROID)\n  main_parts = new ChromeBrowserMainPartsAndroid(\n      parameters, std::move(service_manifest_data_pack_));\n#elif defined(OS_POSIX)\n  main_parts = new ChromeBrowserMainPartsPosix(\n      parameters, std::move(service_manifest_data_pack_));\n#else\n  NOTREACHED();\n  main_parts = new ChromeBrowserMainParts(\n      parameters, std::move(service_manifest_data_pack_));\n#endif\n\n  chrome::AddProfilesExtraParts(main_parts);\n\n  // Construct additional browser parts. Stages are called in the order in\n  // which they are added.\n#if defined(TOOLKIT_VIEWS)\n#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)\n  main_parts->AddParts(new ChromeBrowserMainExtraPartsViewsLinux());\n#else\n  main_parts->AddParts(new ChromeBrowserMainExtraPartsViews());\n#endif\n#endif\n\n#if defined(OS_CHROMEOS)\n  // TODO(jamescook): Combine with ChromeBrowserMainPartsChromeos.\n  main_parts->AddParts(new ChromeBrowserMainExtraPartsAsh());\n#endif\n\n#if defined(USE_X11)\n  main_parts->AddParts(new ChromeBrowserMainExtraPartsX11());\n#endif\n\n  main_parts->AddParts(new ChromeBrowserMainExtraPartsResourceCoordinator);\n\n  main_parts->AddParts(new ChromeBrowserMainExtraPartsProfiling);\n\n  chrome::AddMetricsExtraParts(main_parts);\n\n  main_parts->AddParts(ChromeService::GetInstance()->CreateExtraParts());\n\n  return main_parts;\n}\n\nvoid ChromeContentBrowserClient::PostAfterStartupTask(\n    const base::Location& from_here,\n    const scoped_refptr<base::TaskRunner>& task_runner,\n    base::OnceClosure task) {\n  AfterStartupTaskUtils::PostTask(from_here, task_runner, std::move(task));\n}\n\nbool ChromeContentBrowserClient::IsBrowserStartupComplete() {\n  return AfterStartupTaskUtils::IsBrowserStartupComplete();\n}\n\nvoid ChromeContentBrowserClient::SetBrowserStartupIsCompleteForTesting() {\n  AfterStartupTaskUtils::SetBrowserStartupIsCompleteForTesting();\n}\n\nstd::string ChromeContentBrowserClient::GetStoragePartitionIdForSite(\n    content::BrowserContext* browser_context,\n    const GURL& site) {\n  std::string partition_id;\n\n  // The partition ID for webview guest processes is the string value of its\n  // SiteInstance URL - \"chrome-guest://app_id/persist?partition\".\n  if (site.SchemeIs(content::kGuestScheme))\n    partition_id = site.spec();\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // The partition ID for extensions with isolated storage is treated similarly\n  // to the above.\n  else if (site.SchemeIs(extensions::kExtensionScheme) &&\n           extensions::util::SiteHasIsolatedStorage(site, browser_context))\n    partition_id = site.spec();\n#endif\n\n  DCHECK(IsValidStoragePartitionId(browser_context, partition_id));\n  return partition_id;\n}\n\nbool ChromeContentBrowserClient::IsValidStoragePartitionId(\n    content::BrowserContext* browser_context,\n    const std::string& partition_id) {\n  // The default ID is empty and is always valid.\n  if (partition_id.empty())\n    return true;\n\n  return GURL(partition_id).is_valid();\n}\n\nvoid ChromeContentBrowserClient::GetStoragePartitionConfigForSite(\n    content::BrowserContext* browser_context,\n    const GURL& site,\n    bool can_be_default,\n    std::string* partition_domain,\n    std::string* partition_name,\n    bool* in_memory) {\n  // Default to the browser-wide storage partition and override based on |site|\n  // below.\n  partition_domain->clear();\n  partition_name->clear();\n  *in_memory = false;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  bool success = extensions::WebViewGuest::GetGuestPartitionConfigForSite(\n      site, partition_domain, partition_name, in_memory);\n\n  if (!success && site.SchemeIs(extensions::kExtensionScheme)) {\n    // If |can_be_default| is false, the caller is stating that the |site|\n    // should be parsed as if it had isolated storage. In particular it is\n    // important to NOT check ExtensionService for the is_storage_isolated()\n    // attribute because this code path is run during Extension uninstall\n    // to do cleanup after the Extension has already been unloaded from the\n    // ExtensionService.\n    bool is_isolated = !can_be_default;\n    if (can_be_default) {\n      if (extensions::util::SiteHasIsolatedStorage(site, browser_context))\n        is_isolated = true;\n    }\n\n    if (is_isolated) {\n      CHECK(site.has_host());\n      // For extensions with isolated storage, the the host of the |site| is\n      // the |partition_domain|. The |in_memory| and |partition_name| are only\n      // used in guest schemes so they are cleared here.\n      *partition_domain = site.host();\n      *in_memory = false;\n      partition_name->clear();\n    }\n    success = true;\n  }\n#endif\n\n  // Assert that if |can_be_default| is false, the code above must have found a\n  // non-default partition.  If this fails, the caller has a serious logic\n  // error about which StoragePartition they expect to be in and it is not\n  // safe to continue.\n  CHECK(can_be_default || !partition_domain->empty());\n}\n\ncontent::WebContentsViewDelegate*\n    ChromeContentBrowserClient::GetWebContentsViewDelegate(\n        content::WebContents* web_contents) {\n  return CreateWebContentsViewDelegate(web_contents);\n}\n\nbool ChromeContentBrowserClient::AllowGpuLaunchRetryOnIOThread() {\n#if defined(OS_ANDROID)\n  const base::android::ApplicationState app_state =\n      base::android::ApplicationStatusListener::GetState();\n  return base::android::APPLICATION_STATE_UNKNOWN == app_state ||\n         base::android::APPLICATION_STATE_HAS_RUNNING_ACTIVITIES == app_state ||\n         base::android::APPLICATION_STATE_HAS_PAUSED_ACTIVITIES == app_state;\n#else\n  return true;\n#endif\n}\n\nvoid ChromeContentBrowserClient::RenderProcessWillLaunch(\n    content::RenderProcessHost* host,\n    service_manager::mojom::ServiceRequest* service_request) {\n  int id = host->GetID();\n  Profile* profile = Profile::FromBrowserContext(host->GetBrowserContext());\n  host->AddFilter(new ChromeRenderMessageFilter(id, profile));\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  host->AddFilter(new cast::CastTransportHostFilter(profile));\n#endif\n#if BUILDFLAG(ENABLE_PRINTING)\n  host->AddFilter(new printing::PrintingMessageFilter(id, profile));\n#endif\n  host->AddFilter(new prerender::PrerenderMessageFilter(id, profile));\n  host->AddFilter(new TtsMessageFilter(host->GetBrowserContext()));\n  WebRtcLoggingHandlerHost* webrtc_logging_handler_host =\n      new WebRtcLoggingHandlerHost(id, profile,\n                                   g_browser_process->webrtc_log_uploader());\n  host->AddFilter(webrtc_logging_handler_host);\n  host->SetUserData(\n      WebRtcLoggingHandlerHost::kWebRtcLoggingHandlerHostKey,\n      std::make_unique<base::UserDataAdapter<WebRtcLoggingHandlerHost>>(\n          webrtc_logging_handler_host));\n\n  // The audio manager outlives the host, so it's safe to hand a raw pointer to\n  // it to the AudioDebugRecordingsHandler, which is owned by the host.\n  AudioDebugRecordingsHandler* audio_debug_recordings_handler =\n      new AudioDebugRecordingsHandler(profile);\n  host->SetUserData(\n      AudioDebugRecordingsHandler::kAudioDebugRecordingsHandlerKey,\n      std::make_unique<base::UserDataAdapter<AudioDebugRecordingsHandler>>(\n          audio_debug_recordings_handler));\n\n#if BUILDFLAG(ENABLE_NACL)\n  host->AddFilter(new nacl::NaClHostMessageFilter(id, profile->IsOffTheRecord(),\n                                                  profile->GetPath()));\n#endif\n\n  bool is_incognito_process = profile->IsOffTheRecord();\n\n#if defined(OS_ANDROID)\n  // Data cannot be persisted if the profile is off the record.\n  host->AddFilter(\n      new cdm::CdmMessageFilterAndroid(!is_incognito_process, false));\n#endif\n\n  chrome::mojom::RendererConfigurationAssociatedPtr rc_interface;\n  host->GetChannel()->GetRemoteAssociatedInterface(&rc_interface);\n  rc_interface->SetInitialConfiguration(is_incognito_process);\n\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->RenderProcessWillLaunch(host);\n\n  RendererContentSettingRules rules;\n  if (host->IsForGuestsOnly()) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n    GetGuestViewDefaultContentSettingRules(is_incognito_process, &rules);\n#else\n    NOTREACHED();\n#endif\n  } else {\n    GetRendererContentSettingRules(\n        HostContentSettingsMapFactory::GetForProfile(profile), &rules);\n  }\n  rc_interface->SetContentSettingRules(rules);\n\n  service_manager::mojom::ServicePtr service;\n  *service_request = mojo::MakeRequest(&service);\n  service_manager::mojom::PIDReceiverPtr pid_receiver;\n  service_manager::Identity renderer_identity = host->GetChildIdentity();\n  ChromeService::GetInstance()->connector()->StartService(\n      service_manager::Identity(chrome::mojom::kRendererServiceName,\n                                renderer_identity.user_id(),\n                                renderer_identity.instance()),\n      std::move(service), mojo::MakeRequest(&pid_receiver));\n}\n\nGURL ChromeContentBrowserClient::GetEffectiveURL(\n    content::BrowserContext* browser_context,\n    const GURL& url) {\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  if (!profile)\n    return url;\n\n#if !defined(OS_ANDROID)\n  // If the input |url| should be assigned to the Instant renderer, make its\n  // effective URL distinct from other URLs on the search provider's domain.\n  // This needs to happen even if |url| corresponds to an isolated origin; see\n  // https://crbug.com/755595.\n  if (search::ShouldAssignURLToInstantRenderer(url, profile))\n    return search::GetEffectiveURLForInstant(url, profile);\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::GetEffectiveURL(profile,\n                                                                   url);\n#else\n  return url;\n#endif\n}\n\nbool ChromeContentBrowserClient::ShouldUseProcessPerSite(\n    content::BrowserContext* browser_context, const GURL& effective_url) {\n  // Non-extension, non-Instant URLs should generally use\n  // process-per-site-instance.  Because we expect to use the effective URL,\n  // URLs for hosted apps (apart from bookmark apps) should have an extension\n  // scheme by now.\n\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  if (!profile)\n    return false;\n\n#if !defined(OS_ANDROID)\n  if (search::ShouldUseProcessPerSiteForInstantURL(effective_url, profile))\n    return true;\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::ShouldUseProcessPerSite(\n      profile, effective_url);\n#else\n  return false;\n#endif\n}\n\nbool ChromeContentBrowserClient::ShouldUseSpareRenderProcessHost(\n    content::BrowserContext* browser_context,\n    const GURL& site_url) {\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  if (!profile)\n    return false;\n\n#if !defined(OS_ANDROID)\n  // Instant renderers should not use a spare process, because they require\n  // passing switches::kInstantProcess to the renderer process when it\n  // launches.  A spare process is launched earlier, before it is known which\n  // navigation will use it, so it lacks this flag.\n  if (search::ShouldAssignURLToInstantRenderer(site_url, profile))\n    return false;\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::\n      ShouldUseSpareRenderProcessHost(profile, site_url);\n#else\n  return true;\n#endif\n}\n\nbool ChromeContentBrowserClient::DoesSiteRequireDedicatedProcess(\n    content::BrowserContext* browser_context,\n    const GURL& effective_site_url) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  if (ChromeContentBrowserClientExtensionsPart::DoesSiteRequireDedicatedProcess(\n          browser_context, effective_site_url)) {\n    return true;\n  }\n#endif\n  return false;\n}\n\n// TODO(creis, nick): https://crbug.com/160576 describes a weakness in our\n// origin-lock enforcement, where we don't have a way to efficiently know\n// effective URLs on the IO thread, and wind up killing processes that e.g.\n// request cookies for their actual URL. This whole function (and its\n// ExtensionsPart) should be removed once we add that ability to the IO thread.\nbool ChromeContentBrowserClient::ShouldLockToOrigin(\n    content::BrowserContext* browser_context,\n    const GURL& effective_site_url) {\n  // Origin lock to the search scheme would kill processes upon legitimate\n  // requests for cookies from the search engine's domain.\n  if (effective_site_url.SchemeIs(chrome::kChromeSearchScheme))\n    return false;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // Disable origin lock if this is an extension/app that applies effective URL\n  // mappings.\n  if (!ChromeContentBrowserClientExtensionsPart::ShouldLockToOrigin(\n          browser_context, effective_site_url)) {\n    return false;\n  }\n#endif\n  return true;\n}\n\nconst char*\nChromeContentBrowserClient::GetInitatorSchemeBypassingDocumentBlocking() {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // Don't block responses for extension processes or for content scripts.\n  // TODO(creis): When every extension fetch (including content scripts) has\n  // been made to go through an extension-specific URLLoaderFactory, this\n  // mechanism ought to work by enumerating the host permissions from the\n  // extension manifest, and forwarding them on to the network service while\n  // brokering the URLLoaderFactory.\n  return extensions::kExtensionScheme;\n#else\n  return nullptr;\n#endif\n}\n\n// These are treated as WebUI schemes but do not get WebUI bindings. Also,\n// view-source is allowed for these schemes.\nvoid ChromeContentBrowserClient::GetAdditionalWebUISchemes(\n    std::vector<std::string>* additional_schemes) {\n  additional_schemes->push_back(chrome::kChromeSearchScheme);\n  additional_schemes->push_back(dom_distiller::kDomDistillerScheme);\n  additional_schemes->push_back(content::kChromeDevToolsScheme);\n}\n\nvoid ChromeContentBrowserClient::GetAdditionalViewSourceSchemes(\n    std::vector<std::string>* additional_schemes) {\n  GetAdditionalWebUISchemes(additional_schemes);\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  additional_schemes->push_back(extensions::kExtensionScheme);\n#endif\n}\n\nbool ChromeContentBrowserClient::LogWebUIUrl(const GURL& web_ui_url) const {\n  return webui::LogWebUIUrl(web_ui_url);\n}\n\nbool ChromeContentBrowserClient::IsHandledURL(const GURL& url) {\n  return ProfileIOData::IsHandledURL(url);\n}\n\nbool ChromeContentBrowserClient::CanCommitURL(\n    content::RenderProcessHost* process_host,\n    const GURL& url) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::CanCommitURL(\n      process_host, url);\n#else\n  return true;\n#endif\n}\n\nbool ChromeContentBrowserClient::ShouldAllowOpenURL(\n    content::SiteInstance* site_instance, const GURL& url) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  bool result;\n  if (ChromeContentBrowserClientExtensionsPart::ShouldAllowOpenURL(\n          site_instance, url, &result))\n    return result;\n#endif\n\n  // Do not allow chrome://chrome-signin navigate to other chrome:// URLs, since\n  // the signin page may host untrusted web content.\n  GURL from_url = site_instance->GetSiteURL();\n  if (from_url.GetOrigin().spec() == chrome::kChromeUIChromeSigninURL &&\n      url.SchemeIs(content::kChromeUIScheme) &&\n      url.host_piece() != chrome::kChromeUIChromeSigninHost) {\n    VLOG(1) << \"Blocked navigation to \" << url.spec() << \" from \"\n            << chrome::kChromeUIChromeSigninURL;\n    return false;\n  }\n\n  return true;\n}\n\nnamespace {\n\n// Returns whether a SiteInstance holds a NTP. TODO(mastiz): This\n// really really really needs to be moved to a shared place where all the code\n// that needs to know this can access it. See http://crbug.com/624410.\nbool IsNTPSiteInstance(SiteInstance* site_instance) {\n  // While using SiteInstance::GetSiteURL() is unreliable and the wrong thing to\n  // use for making security decisions 99.44% of the time, for detecting the NTP\n  // it is reliable and the correct way. Again, see http://crbug.com/624410.\n  return site_instance &&\n         site_instance->GetSiteURL().SchemeIs(chrome::kChromeSearchScheme) &&\n         (site_instance->GetSiteURL().host_piece() ==\n              chrome::kChromeSearchRemoteNtpHost ||\n          site_instance->GetSiteURL().host_piece() ==\n              chrome::kChromeSearchLocalNtpHost);\n}\n\n}  // namespace\n\nvoid ChromeContentBrowserClient::OverrideNavigationParams(\n    SiteInstance* site_instance,\n    ui::PageTransition* transition,\n    bool* is_renderer_initiated,\n    content::Referrer* referrer) {\n  DCHECK(transition);\n  DCHECK(is_renderer_initiated);\n  DCHECK(referrer);\n  // TODO(crbug.com/624410): Factor the predicate to identify a URL as an NTP\n  // to a shared library.\n  if (IsNTPSiteInstance(site_instance) &&\n      ui::PageTransitionCoreTypeIs(*transition, ui::PAGE_TRANSITION_LINK)) {\n    // Use AUTO_BOOKMARK for clicks on tiles of the new tab page, consistently\n    // with native implementations like Android's.\n    *transition = ui::PAGE_TRANSITION_AUTO_BOOKMARK;\n    *is_renderer_initiated = false;\n    *referrer = content::Referrer();\n  }\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  ChromeContentBrowserClientExtensionsPart::OverrideNavigationParams(\n      site_instance, transition, is_renderer_initiated, referrer);\n#endif\n}\n\nbool ChromeContentBrowserClient::\n    ShouldFrameShareParentSiteInstanceDespiteTopDocumentIsolation(\n        const GURL& url,\n        content::SiteInstance* parent_site_instance) {\n  if (IsNTPSiteInstance(parent_site_instance))\n    return true;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::\n      ShouldFrameShareParentSiteInstanceDespiteTopDocumentIsolation(\n          url, parent_site_instance);\n#else\n  return false;\n#endif\n}\n\nbool ChromeContentBrowserClient::ShouldStayInParentProcessForNTP(\n    const GURL& url,\n    SiteInstance* parent_site_instance) {\n  return url.SchemeIs(chrome::kChromeSearchScheme) &&\n         IsNTPSiteInstance(parent_site_instance);\n}\n\nbool ChromeContentBrowserClient::IsSuitableHost(\n    content::RenderProcessHost* process_host,\n    const GURL& site_url) {\n  Profile* profile =\n      Profile::FromBrowserContext(process_host->GetBrowserContext());\n  // This may be NULL during tests. In that case, just assume any site can\n  // share any host.\n  if (!profile)\n    return true;\n\n#if !defined(OS_ANDROID)\n  // Instant URLs should only be in the instant process and instant process\n  // should only have Instant URLs.\n  InstantService* instant_service =\n      InstantServiceFactory::GetForProfile(profile);\n  if (instant_service) {\n    bool is_instant_process = instant_service->IsInstantProcess(\n        process_host->GetID());\n    bool should_be_in_instant_process =\n        search::ShouldAssignURLToInstantRenderer(site_url, profile);\n    if (is_instant_process || should_be_in_instant_process)\n      return is_instant_process && should_be_in_instant_process;\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::IsSuitableHost(\n      profile, process_host, site_url);\n#else\n  return true;\n#endif\n}\n\nbool ChromeContentBrowserClient::MayReuseHost(\n    content::RenderProcessHost* process_host) {\n  // If there is currently a prerender in progress for the host provided,\n  // it may not be shared. We require prerenders to be by themselves in a\n  // separate process so that we can monitor their resource usage.\n  prerender::PrerenderManager* prerender_manager =\n      prerender::PrerenderManagerFactory::GetForBrowserContext(\n          process_host->GetBrowserContext());\n  if (prerender_manager &&\n      !prerender_manager->MayReuseProcessHost(process_host)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool ChromeContentBrowserClient::ShouldTryToUseExistingProcessHost(\n    content::BrowserContext* browser_context, const GURL& url) {\n  // It has to be a valid URL for us to check for an extension.\n  if (!url.is_valid())\n    return false;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  return ChromeContentBrowserClientExtensionsPart::\n      ShouldTryToUseExistingProcessHost(\n          profile, url);\n#else\n  return false;\n#endif\n}\n\nvoid ChromeContentBrowserClient::SiteInstanceGotProcess(\n    SiteInstance* site_instance) {\n  CHECK(site_instance->HasProcess());\n\n  Profile* profile = Profile::FromBrowserContext(\n      site_instance->GetBrowserContext());\n  if (!profile)\n    return;\n\n#if !defined(OS_ANDROID)\n  // Remember the ID of the Instant process to signal the renderer process\n  // on startup in |AppendExtraCommandLineSwitches| below.\n  if (search::ShouldAssignURLToInstantRenderer(site_instance->GetSiteURL(),\n                                               profile)) {\n    InstantService* instant_service =\n        InstantServiceFactory::GetForProfile(profile);\n    if (instant_service)\n      instant_service->AddInstantProcess(site_instance->GetProcess()->GetID());\n  }\n#endif\n\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->SiteInstanceGotProcess(site_instance);\n}\n\nvoid ChromeContentBrowserClient::SiteInstanceDeleting(\n    SiteInstance* site_instance) {\n  if (!site_instance->HasProcess())\n    return;\n\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->SiteInstanceDeleting(site_instance);\n}\n\nbool ChromeContentBrowserClient::ShouldSwapBrowsingInstancesForNavigation(\n    SiteInstance* site_instance,\n    const GURL& current_url,\n    const GURL& new_url) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::\n      ShouldSwapBrowsingInstancesForNavigation(\n          site_instance, current_url, new_url);\n#else\n  return false;\n#endif\n}\n\nbool ChromeContentBrowserClient::ShouldIsolateErrorPage(bool in_main_frame) {\n  // TODO(nasko): Consider supporting error page isolation in subframes if\n  // Site Isolation is enabled.\n  // Note: It is temporarily disabled to investigate functional regression\n  // and process terminations. See https://crbug.com/838161.\n  return false;\n}\n\nbool ChromeContentBrowserClient::ShouldAssignSiteForURL(const GURL& url) {\n  return !url.SchemeIs(chrome::kChromeNativeScheme);\n}\n\nstd::vector<url::Origin>\nChromeContentBrowserClient::GetOriginsRequiringDedicatedProcess() {\n  std::vector<url::Origin> isolated_origin_list;\n\n// Sign-in process isolation is not needed on Android, see\n// https://crbug.com/739418.\n#if !defined(OS_ANDROID)\n  isolated_origin_list.emplace_back(\n      url::Origin::Create(GaiaUrls::GetInstance()->gaia_url()));\n#endif\n\n  return isolated_origin_list;\n}\n\nbool ChromeContentBrowserClient::ShouldEnableStrictSiteIsolation() {\n  if (base::FeatureList::IsEnabled(\n          features::kSitePerProcessOnlyForHighMemoryClients)) {\n    constexpr int kDefaultMemoryThresholdMb = 1024;\n    int memory_threshold_mb = base::GetFieldTrialParamByFeatureAsInt(\n        features::kSitePerProcessOnlyForHighMemoryClients,\n        features::kSitePerProcessOnlyForHighMemoryClientsParamName,\n        kDefaultMemoryThresholdMb);\n    if (base::SysInfo::AmountOfPhysicalMemoryMB() <= memory_threshold_mb)\n      return false;\n  }\n\n  return base::FeatureList::IsEnabled(features::kSitePerProcess);\n}\n\nbool ChromeContentBrowserClient::IsFileAccessAllowed(\n    const base::FilePath& path,\n    const base::FilePath& absolute_path,\n    const base::FilePath& profile_path) {\n  return ChromeNetworkDelegate::IsAccessAllowed(path, absolute_path,\n                                                profile_path);\n}\n\nnamespace {\n\nbool IsAutoReloadEnabled() {\n  const base::CommandLine& browser_command_line =\n      *base::CommandLine::ForCurrentProcess();\n  if (browser_command_line.HasSwitch(switches::kEnableOfflineAutoReload))\n    return true;\n  if (browser_command_line.HasSwitch(switches::kDisableOfflineAutoReload))\n    return false;\n  return true;\n}\n\nbool IsAutoReloadVisibleOnlyEnabled() {\n  const base::CommandLine& browser_command_line =\n      *base::CommandLine::ForCurrentProcess();\n  if (browser_command_line.HasSwitch(\n      switches::kEnableOfflineAutoReloadVisibleOnly)) {\n    return true;\n  }\n  if (browser_command_line.HasSwitch(\n      switches::kDisableOfflineAutoReloadVisibleOnly)) {\n    return false;\n  }\n  return true;\n}\n\nvoid MaybeAppendBlinkSettingsSwitchForFieldTrial(\n    const base::CommandLine& browser_command_line,\n    base::CommandLine* command_line) {\n  // List of field trials that modify the blink-settings command line flag. No\n  // two field trials in the list should specify the same keys, otherwise one\n  // field trial may overwrite another. See Source/core/frame/Settings.in in\n  // Blink for the list of valid keys.\n  static const char* const kBlinkSettingsFieldTrials[] = {\n      // Keys: disallowFetchForDocWrittenScriptsInMainFrame\n      //       disallowFetchForDocWrittenScriptsInMainFrameOnSlowConnections\n      //       disallowFetchForDocWrittenScriptsInMainFrameIfEffectively2G\n      \"DisallowFetchForDocWrittenScriptsInMainFrame\",\n\n      // Keys: cssExternalScannerNoPreload\n      //       cssExternalScannerPreload\n      \"CSSExternalScanner\",\n  };\n\n  std::vector<std::string> blink_settings;\n  for (const char* field_trial_name : kBlinkSettingsFieldTrials) {\n    // Each blink-settings field trial should include a forcing_flag group,\n    // to make sure that clients that specify the blink-settings flag on the\n    // command line are excluded from the experiment groups. To make\n    // sure we assign clients that specify this flag to the forcing_flag\n    // group, we must call GetVariationParams for each field trial first\n    // (for example, before checking HasSwitch() and returning), since\n    // GetVariationParams has the side-effect of assigning the client to\n    // a field trial group.\n    std::map<std::string, std::string> params;\n    if (variations::GetVariationParams(field_trial_name, &params)) {\n      for (const auto& param : params) {\n        blink_settings.push_back(base::StringPrintf(\n            \"%s=%s\", param.first.c_str(), param.second.c_str()));\n      }\n    }\n  }\n\n  if (blink_settings.empty()) {\n    return;\n  }\n\n  if (browser_command_line.HasSwitch(switches::kBlinkSettings) ||\n      command_line->HasSwitch(switches::kBlinkSettings)) {\n    // The field trials should be configured to force users that specify the\n    // blink-settings flag into a group with no params, and we return\n    // above if no params were specified, so it's an error if we reach\n    // this point.\n    LOG(WARNING) << \"Received field trial params, \"\n                    \"but blink-settings switch already specified.\";\n    return;\n  }\n\n  command_line->AppendSwitchASCII(switches::kBlinkSettings,\n                                  base::JoinString(blink_settings, \",\"));\n}\n\n#if defined(OS_ANDROID)\ntemplate <typename Interface>\nvoid ForwardToJavaFrameRegistry(\n    mojo::InterfaceRequest<Interface> request,\n    content::RenderFrameHost* render_frame_host) {\n  render_frame_host->GetJavaInterfaces()->GetInterface(std::move(request));\n}\n\ntemplate <typename Interface>\nvoid ForwardToJavaWebContentsRegistry(\n    mojo::InterfaceRequest<Interface> request,\n    content::RenderFrameHost* render_frame_host) {\n  content::WebContents* contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n  if (contents)\n    contents->GetJavaInterfaces()->GetInterface(std::move(request));\n}\n#endif\n\n}  // namespace\n\nvoid ChromeContentBrowserClient::AppendExtraCommandLineSwitches(\n    base::CommandLine* command_line,\n    int child_process_id) {\n#if defined(OS_MACOSX)\n  std::unique_ptr<metrics::ClientInfo> client_info =\n      GoogleUpdateSettings::LoadMetricsClientInfo();\n  if (client_info) {\n    command_line->AppendSwitchASCII(switches::kMetricsClientID,\n                                    client_info->client_id);\n  }\n#elif defined(OS_POSIX)\n  if (breakpad::IsCrashReporterEnabled()) {\n    std::string switch_value;\n    std::unique_ptr<metrics::ClientInfo> client_info =\n        GoogleUpdateSettings::LoadMetricsClientInfo();\n    if (client_info)\n      switch_value = client_info->client_id;\n    switch_value.push_back(',');\n    switch_value.append(chrome::GetChannelName());\n    command_line->AppendSwitchASCII(switches::kEnableCrashReporter,\n                                    switch_value);\n  }\n#endif\n\n  if (logging::DialogsAreSuppressed())\n    command_line->AppendSwitch(switches::kNoErrorDialogs);\n\n  std::string process_type =\n      command_line->GetSwitchValueASCII(switches::kProcessType);\n  const base::CommandLine& browser_command_line =\n      *base::CommandLine::ForCurrentProcess();\n\n  static const char* const kCommonSwitchNames[] = {\n    switches::kUserAgent,\n    switches::kUserDataDir,  // Make logs go to the right file.\n  };\n  command_line->CopySwitchesFrom(browser_command_line, kCommonSwitchNames,\n                                 arraysize(kCommonSwitchNames));\n\n  static const char* const kDinosaurEasterEggSwitches[] = {\n      error_page::switches::kDisableDinosaurEasterEgg,\n      error_page::switches::kEnableEasterEggBdayMode,\n  };\n  command_line->CopySwitchesFrom(browser_command_line,\n                                 kDinosaurEasterEggSwitches,\n                                 arraysize(kDinosaurEasterEggSwitches));\n\n#if defined(OS_CHROMEOS)\n  // On Chrome OS need to pass primary user homedir (in multi-profiles session).\n  base::FilePath homedir;\n  base::PathService::Get(base::DIR_HOME, &homedir);\n  command_line->AppendSwitchASCII(chromeos::switches::kHomedir,\n                                  homedir.value().c_str());\n#endif\n\n  if (process_type == switches::kRendererProcess) {\n    content::RenderProcessHost* process =\n        content::RenderProcessHost::FromID(child_process_id);\n    Profile* profile =\n        process ? Profile::FromBrowserContext(process->GetBrowserContext())\n                : NULL;\n    for (size_t i = 0; i < extra_parts_.size(); ++i) {\n      extra_parts_[i]->AppendExtraRendererCommandLineSwitches(\n          command_line, process, profile);\n    }\n\n#if defined(OS_CHROMEOS)\n    const std::string& login_profile =\n        browser_command_line.GetSwitchValueASCII(\n            chromeos::switches::kLoginProfile);\n    if (!login_profile.empty())\n      command_line->AppendSwitchASCII(\n          chromeos::switches::kLoginProfile, login_profile);\n#endif\n\n    MaybeCopyDisableWebRtcEncryptionSwitch(command_line,\n                                           browser_command_line,\n                                           chrome::GetChannel());\n\n    if (process) {\n      PrefService* prefs = profile->GetPrefs();\n      // Currently this pref is only registered if applied via a policy.\n      if (prefs->HasPrefPath(prefs::kDisable3DAPIs) &&\n          prefs->GetBoolean(prefs::kDisable3DAPIs)) {\n        // Turn this policy into a command line switch.\n        command_line->AppendSwitch(switches::kDisable3DAPIs);\n      }\n\n      const base::ListValue* switches =\n          prefs->GetList(prefs::kEnableDeprecatedWebPlatformFeatures);\n      if (switches) {\n        // Enable any deprecated features that have been re-enabled by policy.\n        for (base::ListValue::const_iterator it = switches->begin();\n             it != switches->end(); ++it) {\n          std::string switch_to_enable;\n          if (it->GetAsString(&switch_to_enable))\n            command_line->AppendSwitch(switch_to_enable);\n        }\n      }\n\n      // Disable client-side phishing detection in the renderer if it is\n      // disabled in the Profile preferences or the browser process.\n      if (!prefs->GetBoolean(prefs::kSafeBrowsingEnabled) ||\n          !g_browser_process->safe_browsing_detection_service()) {\n        command_line->AppendSwitch(\n            switches::kDisableClientSidePhishingDetection);\n      }\n\n      if (prefs->GetBoolean(prefs::kPrintPreviewDisabled))\n        command_line->AppendSwitch(switches::kDisablePrintPreview);\n\n#if !defined(OS_ANDROID)\n      InstantService* instant_service =\n          InstantServiceFactory::GetForProfile(profile);\n      if (instant_service &&\n          instant_service->IsInstantProcess(process->GetID())) {\n        command_line->AppendSwitch(switches::kInstantProcess);\n      }\n#endif\n\n      if (prefs->HasPrefPath(prefs::kAllowDinosaurEasterEgg) &&\n          !prefs->GetBoolean(prefs::kAllowDinosaurEasterEgg)) {\n        command_line->AppendSwitch(\n            error_page::switches::kDisableDinosaurEasterEgg);\n      }\n\n      if (prefs->HasPrefPath(prefs::kUnsafelyTreatInsecureOriginAsSecure)) {\n        command_line->AppendSwitchASCII(\n            switches::kUnsafelyTreatInsecureOriginAsSecure,\n            prefs->GetString(prefs::kUnsafelyTreatInsecureOriginAsSecure));\n      }\n    }\n\n    if (IsAutoReloadEnabled())\n      command_line->AppendSwitch(switches::kEnableOfflineAutoReload);\n    if (IsAutoReloadVisibleOnlyEnabled()) {\n      command_line->AppendSwitch(\n          switches::kEnableOfflineAutoReloadVisibleOnly);\n    }\n\n    {\n      // Enable showing a saved copy if the user explicitly enabled it.\n      // Note that as far as the renderer is concerned, the feature is\n      // enabled if-and-only-if one of the kEnableShowSavedCopy* switches\n      // is on the command line; the yes/no/default behavior is only at\n      // the browser command line level.\n\n      // Command line switches override\n      const std::string& show_saved_copy_value =\n          browser_command_line.GetSwitchValueASCII(\n              error_page::switches::kShowSavedCopy);\n      if (show_saved_copy_value ==\n              error_page::switches::kEnableShowSavedCopyPrimary ||\n          show_saved_copy_value ==\n              error_page::switches::kEnableShowSavedCopySecondary ||\n          show_saved_copy_value ==\n              error_page::switches::kDisableShowSavedCopy) {\n        command_line->AppendSwitchASCII(error_page::switches::kShowSavedCopy,\n                                        show_saved_copy_value);\n      }\n    }\n    MaybeAppendBlinkSettingsSwitchForFieldTrial(\n        browser_command_line, command_line);\n\n#if defined(OS_ANDROID)\n    // If the platform is Android, force the distillability service on.\n    command_line->AppendSwitch(switches::kEnableDistillabilityService);\n#endif\n\n    // Please keep this in alphabetical order.\n    static const char* const kSwitchNames[] = {\n      autofill::switches::kDisablePasswordGeneration,\n      autofill::switches::kEnablePasswordGeneration,\n      autofill::switches::kEnableSuggestionsWithSubstringMatch,\n      autofill::switches::kIgnoreAutocompleteOffForAutofill,\n      autofill::switches::kLocalHeuristicsOnlyForPasswordGeneration,\n      autofill::switches::kShowAutofillSignatures,\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n      extensions::switches::kAllowHTTPBackgroundPage,\n      extensions::switches::kAllowLegacyExtensionManifests,\n      extensions::switches::kEnableEmbeddedExtensionOptions,\n      extensions::switches::kEnableExperimentalExtensionApis,\n      extensions::switches::kExtensionsOnChromeURLs,\n      extensions::switches::kWhitelistedExtensionID,\n#endif\n      switches::kAllowInsecureLocalhost,\n      switches::kAppsGalleryURL,\n      switches::kCloudPrintURL,\n      switches::kCloudPrintXmppEndpoint,\n      switches::kDisableBundledPpapiFlash,\n      switches::kDisableCastStreamingHWEncoding,\n      switches::kDisableJavaScriptHarmonyShipping,\n      variations::switches::kEnableBenchmarking,\n      switches::kEnableDistillabilityService,\n      switches::kEnableNaCl,\n#if BUILDFLAG(ENABLE_NACL)\n      switches::kEnableNaClDebug,\n      switches::kEnableNaClNonSfiMode,\n#endif\n      switches::kEnableNetBenchmarking,\n#if BUILDFLAG(ENABLE_NACL)\n      switches::kForcePNaClSubzero,\n#endif\n      switches::kForceUIDirection,\n      switches::kJavaScriptHarmony,\n      switches::kOriginTrialDisabledFeatures,\n      switches::kOriginTrialDisabledTokens,\n      switches::kOriginTrialPublicKey,\n      switches::kPpapiFlashArgs,\n      switches::kPpapiFlashPath,\n      switches::kPpapiFlashVersion,\n      switches::kProfilingAtStart,\n      switches::kProfilingFile,\n      switches::kProfilingFlush,\n      switches::kReaderModeHeuristics,\n      translate::switches::kTranslateSecurityOrigin,\n    };\n\n    command_line->CopySwitchesFrom(browser_command_line, kSwitchNames,\n                                   arraysize(kSwitchNames));\n  } else if (process_type == switches::kUtilityProcess) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n    static const char* const kSwitchNames[] = {\n      extensions::switches::kAllowHTTPBackgroundPage,\n      extensions::switches::kEnableExperimentalExtensionApis,\n      extensions::switches::kExtensionsOnChromeURLs,\n      extensions::switches::kWhitelistedExtensionID,\n    };\n\n    command_line->CopySwitchesFrom(browser_command_line, kSwitchNames,\n                                   arraysize(kSwitchNames));\n#endif\n  } else if (process_type == service_manager::switches::kZygoteProcess) {\n    static const char* const kSwitchNames[] = {\n      // Load (in-process) Pepper plugins in-process in the zygote pre-sandbox.\n      switches::kDisableBundledPpapiFlash,\n#if BUILDFLAG(ENABLE_NACL)\n      switches::kEnableNaClDebug,\n      switches::kEnableNaClNonSfiMode,\n      switches::kForcePNaClSubzero,\n      switches::kNaClDangerousNoSandboxNonSfi,\n#endif\n      switches::kPpapiFlashPath,\n      switches::kPpapiFlashVersion,\n    };\n\n    command_line->CopySwitchesFrom(browser_command_line, kSwitchNames,\n                                   arraysize(kSwitchNames));\n  } else if (process_type == switches::kGpuProcess) {\n    // If --ignore-gpu-blacklist is passed in, don't send in crash reports\n    // because GPU is expected to be unreliable.\n    if (browser_command_line.HasSwitch(switches::kIgnoreGpuBlacklist) &&\n        !command_line->HasSwitch(switches::kDisableBreakpad))\n      command_line->AppendSwitch(switches::kDisableBreakpad);\n  }\n\n  StackSamplingConfiguration::Get()->AppendCommandLineSwitchForChildProcess(\n      process_type,\n      command_line);\n}\n\nvoid ChromeContentBrowserClient::AdjustUtilityServiceProcessCommandLine(\n    const service_manager::Identity& identity,\n    base::CommandLine* command_line) {\n#if BUILDFLAG(ENABLE_MUS)\n  bool copy_switches = false;\n  if (identity.name() == ui::mojom::kServiceName) {\n    command_line->AppendSwitch(switches::kMessageLoopTypeUi);\n    copy_switches = true;\n  }\n#if defined(OS_CHROMEOS)\n  if (identity.name() == ash::mojom::kServiceName) {\n    command_line->AppendSwitch(switches::kMessageLoopTypeUi);\n    copy_switches = true;\n  }\n  if (ash_service_registry::IsAshRelatedServiceName(identity.name())) {\n    command_line->AppendSwitchASCII(\n        switches::kMashServiceName,\n        ash_service_registry::GetAshRelatedServiceLabel(identity.name()));\n  }\n#endif\n  // TODO(sky): move to a whitelist, but currently the set of flags is rather\n  // sprawling.\n  if (copy_switches) {\n    for (const auto& sw : base::CommandLine::ForCurrentProcess()->GetSwitches())\n      command_line->AppendSwitchNative(sw.first, sw.second);\n  }\n#endif  // BUILDFLAG(ENABLE_MUS)\n\n#if defined(OS_MACOSX)\n  // On Mac, the video-capture and audio services require a CFRunLoop, provided\n  // by a UI message loop, to run AVFoundation and CoreAudio code.\n  // See https://crbug.com/834581\n  if (identity.name() == video_capture::mojom::kServiceName ||\n      identity.name() == audio::mojom::kServiceName)\n    command_line->AppendSwitch(switches::kMessageLoopTypeUi);\n#endif\n}\n\nstd::string ChromeContentBrowserClient::GetApplicationLocale() {\n  if (BrowserThread::CurrentlyOn(BrowserThread::IO))\n    return g_io_thread_application_locale.Get();\n  return g_browser_process->GetApplicationLocale();\n}\n\nstd::string ChromeContentBrowserClient::GetAcceptLangs(\n    content::BrowserContext* context) {\n  Profile* profile = Profile::FromBrowserContext(context);\n  return profile->GetPrefs()->GetString(prefs::kAcceptLanguages);\n}\n\nconst gfx::ImageSkia* ChromeContentBrowserClient::GetDefaultFavicon() {\n  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n  return rb.GetNativeImageNamed(IDR_DEFAULT_FAVICON).ToImageSkia();\n}\n\nbool ChromeContentBrowserClient::IsDataSaverEnabled(\n    content::BrowserContext* browser_context) {\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  if (!profile)\n    return false;\n  PrefService* prefs = profile->GetPrefs();\n  return prefs && prefs->GetBoolean(prefs::kDataSaverEnabled);\n}\n\nvoid ChromeContentBrowserClient::NavigationRequestStarted(\n    int frame_tree_node_id,\n    const GURL& url,\n    std::unique_ptr<net::HttpRequestHeaders>* extra_headers,\n    int* extra_load_flags) {\n  WebContents* web_contents =\n      WebContents::FromFrameTreeNodeId(frame_tree_node_id);\n  *extra_headers =\n      client_hints::GetAdditionalNavigationRequestClientHintsHeaders(\n          web_contents->GetBrowserContext(), url);\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(web_contents);\n  if (prerender_contents) {\n    if (prerender_contents->prerender_mode() == prerender::PREFETCH_ONLY)\n      *extra_load_flags = net::LOAD_PREFETCH;\n  }\n}\n\nbool ChromeContentBrowserClient::AllowAppCache(\n    const GURL& manifest_url,\n    const GURL& first_party,\n    content::ResourceContext* context) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(context);\n  return io_data->GetCookieSettings()->IsCookieAccessAllowed(manifest_url,\n                                                             first_party);\n}\n\nbool ChromeContentBrowserClient::AllowServiceWorker(\n    const GURL& scope,\n    const GURL& first_party_url,\n    content::ResourceContext* context,\n    const base::Callback<content::WebContents*(void)>& wc_getter) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // Check if this is an extension-related service worker, and, if so, if it's\n  // allowed (this can return false if, e.g., the extension is disabled).\n  // If it's not allowed, return immediately. We deliberately do *not* report\n  // to the TabSpecificContentSettings, since the service worker is blocked\n  // because of the extension, rather than because of the user's content\n  // settings.\n  if (!ChromeContentBrowserClientExtensionsPart::AllowServiceWorker(\n          scope, first_party_url, context)) {\n    return false;\n  }\n#endif\n\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(context);\n\n  // Check if JavaScript is allowed.\n  content_settings::SettingInfo info;\n  std::unique_ptr<base::Value> value =\n      io_data->GetHostContentSettingsMap()->GetWebsiteSetting(\n          first_party_url, first_party_url, CONTENT_SETTINGS_TYPE_JAVASCRIPT,\n          std::string(), &info);\n  ContentSetting setting = content_settings::ValueToContentSetting(value.get());\n  bool allow_javascript = (setting == CONTENT_SETTING_ALLOW);\n\n  // Check if cookies are allowed.\n  bool allow_serviceworker =\n      io_data->GetCookieSettings()->IsCookieAccessAllowed(scope,\n                                                          first_party_url);\n  // Record access to database for potential display in UI.\n  // Only post the task if this is for a specific tab.\n  if (!wc_getter.is_null()) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&TabSpecificContentSettings::ServiceWorkerAccessed,\n                       wc_getter, scope, !allow_javascript,\n                       !allow_serviceworker));\n  }\n  return allow_javascript && allow_serviceworker;\n}\n\nbool ChromeContentBrowserClient::AllowSharedWorker(\n    const GURL& worker_url,\n    const GURL& main_frame_url,\n    const std::string& name,\n    const url::Origin& constructor_origin,\n    content::BrowserContext* context,\n    int render_process_id,\n    int render_frame_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  // Check if cookies are allowed.\n  bool allow =\n      CookieSettingsFactory::GetForProfile(Profile::FromBrowserContext(context))\n          ->IsCookieAccessAllowed(worker_url, main_frame_url);\n\n  TabSpecificContentSettings::SharedWorkerAccessed(\n      render_process_id, render_frame_id, worker_url, name, constructor_origin,\n      !allow);\n  return allow;\n}\n\nbool ChromeContentBrowserClient::AllowGetCookie(\n    const GURL& url,\n    const GURL& first_party,\n    const net::CookieList& cookie_list,\n    content::ResourceContext* context,\n    int render_process_id,\n    int render_frame_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(context);\n  bool allow =\n      io_data->GetCookieSettings()->IsCookieAccessAllowed(url, first_party);\n\n  base::Callback<content::WebContents*(void)> wc_getter =\n      base::Bind(&GetWebContents, render_process_id, render_frame_id);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::BindOnce(&TabSpecificContentSettings::CookiesRead, wc_getter, url,\n                     first_party, cookie_list, !allow));\n  return allow;\n}\n\nbool ChromeContentBrowserClient::AllowSetCookie(\n    const GURL& url,\n    const GURL& first_party,\n    const net::CanonicalCookie& cookie,\n    content::ResourceContext* context,\n    int render_process_id,\n    int render_frame_id,\n    const net::CookieOptions& options) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(context);\n  content_settings::CookieSettings* cookie_settings =\n      io_data->GetCookieSettings();\n  bool allow = cookie_settings->IsCookieAccessAllowed(url, first_party);\n\n  base::Callback<content::WebContents*(void)> wc_getter =\n      base::Bind(&GetWebContents, render_process_id, render_frame_id);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::BindOnce(&TabSpecificContentSettings::CookieChanged, wc_getter, url,\n                     first_party, cookie, options, !allow));\n  return allow;\n}\n\nvoid ChromeContentBrowserClient::AllowWorkerFileSystem(\n    const GURL& url,\n    content::ResourceContext* context,\n    const std::vector<std::pair<int, int> >& render_frames,\n    base::Callback<void(bool)> callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(context);\n  content_settings::CookieSettings* cookie_settings =\n      io_data->GetCookieSettings();\n  bool allow = cookie_settings->IsCookieAccessAllowed(url, url);\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  GuestPermissionRequestHelper(url, render_frames, callback, allow);\n#else\n  FileSystemAccessed(url, render_frames, callback, allow);\n#endif\n}\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\nvoid ChromeContentBrowserClient::GuestPermissionRequestHelper(\n    const GURL& url,\n    const std::vector<std::pair<int, int> >& render_frames,\n    base::Callback<void(bool)> callback,\n    bool allow) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  std::vector<std::pair<int, int> >::const_iterator i;\n  std::map<int, int> process_map;\n  std::map<int, int>::const_iterator it;\n  bool has_web_view_guest = false;\n  // Record access to file system for potential display in UI.\n  for (i = render_frames.begin(); i != render_frames.end(); ++i) {\n    if (process_map.find(i->first) != process_map.end())\n      continue;\n\n    process_map.insert(std::pair<int, int>(i->first, i->second));\n\n    if (extensions::WebViewRendererState::GetInstance()->IsGuest(i->first))\n      has_web_view_guest = true;\n  }\n  if (!has_web_view_guest) {\n    FileSystemAccessed(url, render_frames, callback, allow);\n    return;\n  }\n  DCHECK_EQ(1U, process_map.size());\n  it = process_map.begin();\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::BindOnce(\n          &ChromeContentBrowserClient::RequestFileSystemPermissionOnUIThread,\n          it->first, it->second, url, allow,\n          base::Bind(\n              &ChromeContentBrowserClient::FileSystemAccessed,\n              weak_factory_.GetWeakPtr(), url, render_frames,\n              base::Bind(&InvokeCallbackOnThread,\n                         base::SequencedTaskRunnerHandle::Get(), callback))));\n}\n\nvoid ChromeContentBrowserClient::RequestFileSystemPermissionOnUIThread(\n    int render_process_id,\n    int render_frame_id,\n    const GURL& url,\n    bool allowed_by_default,\n    const base::Callback<void(bool)>& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  extensions::WebViewPermissionHelper* web_view_permission_helper =\n      extensions::WebViewPermissionHelper::FromFrameID(\n          render_process_id, render_frame_id);\n  web_view_permission_helper->RequestFileSystemPermission(url,\n                                                          allowed_by_default,\n                                                          callback);\n}\n#endif\n\nvoid ChromeContentBrowserClient::FileSystemAccessed(\n    const GURL& url,\n    const std::vector<std::pair<int, int> >& render_frames,\n    base::Callback<void(bool)> callback,\n    bool allow) {\n  // Record access to file system for potential display in UI.\n  std::vector<std::pair<int, int> >::const_iterator i;\n  for (i = render_frames.begin(); i != render_frames.end(); ++i) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&TabSpecificContentSettings::FileSystemAccessed,\n                       i->first, i->second, url, !allow));\n  }\n  callback.Run(allow);\n}\n\nbool ChromeContentBrowserClient::AllowWorkerIndexedDB(\n    const GURL& url,\n    const base::string16& name,\n    content::ResourceContext* context,\n    const std::vector<std::pair<int, int> >& render_frames) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(context);\n  content_settings::CookieSettings* cookie_settings =\n      io_data->GetCookieSettings();\n  bool allow = cookie_settings->IsCookieAccessAllowed(url, url);\n\n  // Record access to IndexedDB for potential display in UI.\n  std::vector<std::pair<int, int> >::const_iterator i;\n  for (i = render_frames.begin(); i != render_frames.end(); ++i) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&TabSpecificContentSettings::IndexedDBAccessed, i->first,\n                       i->second, url, name, !allow));\n  }\n\n  return allow;\n}\n\nChromeContentBrowserClient::AllowWebBluetoothResult\nChromeContentBrowserClient::AllowWebBluetooth(\n    content::BrowserContext* browser_context,\n    const url::Origin& requesting_origin,\n    const url::Origin& embedding_origin) {\n  // TODO(crbug.com/598890): Don't disable if\n  // base::CommandLine::ForCurrentProcess()->\n  // HasSwitch(switches::kEnableWebBluetooth) is true.\n  if (variations::GetVariationParamValue(\n          PermissionContextBase::kPermissionsKillSwitchFieldStudy,\n          \"Bluetooth\") ==\n      PermissionContextBase::kPermissionsKillSwitchBlockedValue) {\n    // The kill switch is enabled for this permission. Block requests.\n    return AllowWebBluetoothResult::BLOCK_GLOBALLY_DISABLED;\n  }\n\n  const HostContentSettingsMap* const content_settings =\n      HostContentSettingsMapFactory::GetForProfile(\n          Profile::FromBrowserContext(browser_context));\n\n  if (content_settings->GetContentSetting(\n          requesting_origin.GetURL(), embedding_origin.GetURL(),\n          CONTENT_SETTINGS_TYPE_BLUETOOTH_GUARD,\n          std::string()) == CONTENT_SETTING_BLOCK) {\n    return AllowWebBluetoothResult::BLOCK_POLICY;\n  }\n  return AllowWebBluetoothResult::ALLOW;\n}\n\nstd::string ChromeContentBrowserClient::GetWebBluetoothBlocklist() {\n  return variations::GetVariationParamValue(\"WebBluetoothBlocklist\",\n                                            \"blocklist_additions\");\n}\n\nnet::URLRequestContext*\nChromeContentBrowserClient::OverrideRequestContextForURL(\n    const GURL& url, content::ResourceContext* context) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  if (url.SchemeIs(extensions::kExtensionScheme)) {\n    ProfileIOData* io_data = ProfileIOData::FromResourceContext(context);\n    return io_data->extensions_request_context();\n  }\n#endif\n\n  return NULL;\n}\n\nvoid ChromeContentBrowserClient::GetGeolocationRequestContext(\n    base::OnceCallback<void(scoped_refptr<net::URLRequestContextGetter>)>\n        callback) {\n  BrowserThread::PostTaskAndReplyWithResult(\n      BrowserThread::UI, FROM_HERE,\n      base::BindOnce(&GetSystemRequestContextOnUIThread), std::move(callback));\n}\n\nstd::string ChromeContentBrowserClient::GetGeolocationApiKey() {\n  return google_apis::GetAPIKey();\n}\n\n#if defined(OS_ANDROID)\nbool ChromeContentBrowserClient::ShouldUseGmsCoreGeolocationProvider() {\n  // Indicate that Chrome uses the GMS core location provider.\n  return true;\n}\n#endif\n\nQuotaPermissionContext*\nChromeContentBrowserClient::CreateQuotaPermissionContext() {\n  return new ChromeQuotaPermissionContext();\n}\n\nvoid ChromeContentBrowserClient::GetQuotaSettings(\n    content::BrowserContext* context,\n    content::StoragePartition* partition,\n    storage::OptionalQuotaSettingsCallback callback) {\n  if (g_default_quota_settings) {\n    // For debugging tests harness can inject settings.\n    std::move(callback).Run(*g_default_quota_settings);\n    return;\n  }\n  storage::GetNominalDynamicSettings(\n      partition->GetPath(), context->IsOffTheRecord(), std::move(callback));\n}\n\nvoid ChromeContentBrowserClient::AllowCertificateError(\n    content::WebContents* web_contents,\n    int cert_error,\n    const net::SSLInfo& ssl_info,\n    const GURL& request_url,\n    ResourceType resource_type,\n    bool strict_enforcement,\n    bool expired_previous_decision,\n    const base::Callback<void(content::CertificateRequestResultType)>&\n        callback) {\n  DCHECK(web_contents);\n  if (resource_type != content::RESOURCE_TYPE_MAIN_FRAME) {\n    // A sub-resource has a certificate error. The user doesn't really\n    // have a context for making the right decision, so block the\n    // request hard, without an info bar to allow showing the insecure\n    // content.\n    if (!callback.is_null())\n      callback.Run(content::CERTIFICATE_REQUEST_RESULT_TYPE_DENY);\n    return;\n  }\n\n  // If the tab is being prerendered, cancel the prerender and the request.\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(web_contents);\n  if (prerender_contents) {\n    prerender_contents->Destroy(prerender::FINAL_STATUS_SSL_ERROR);\n    if (!callback.is_null()) {\n      callback.Run(content::CERTIFICATE_REQUEST_RESULT_TYPE_CANCEL);\n    }\n    return;\n  }\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kCommittedInterstitials)) {\n    // We deny the request here in order to trigger the committed interstitials\n    // code path (committing certificate error pages as navigations) instead of\n    // the old code path.\n    callback.Run(content::CERTIFICATE_REQUEST_RESULT_TYPE_DENY);\n    return;\n  }\n\n  // Otherwise, display an SSL blocking page. The interstitial page takes\n  // ownership of ssl_blocking_page. We pass a null BlockingPageReadyCallback()\n  // to indicate that we don't want SSLErrorHandler to take the committed\n  // interstitials code path.\n  SSLErrorHandler::HandleSSLError(\n      web_contents, cert_error, ssl_info, request_url,\n      expired_previous_decision,\n      std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n      callback, SSLErrorHandler::BlockingPageReadyCallback());\n}\n\nnamespace {\n\n// Attempts to auto-select a client certificate according to the value of\n// |CONTENT_SETTINGS_TYPE_AUTO_SELECT_CERTIFICATE| content setting for\n// |requesting_url|. If no certificate was auto-selected, returns nullptr.\nstd::unique_ptr<net::ClientCertIdentity> AutoSelectCertificate(\n    Profile* profile,\n    const GURL& requesting_url,\n    net::ClientCertIdentityList& client_certs) {\n  HostContentSettingsMap* host_content_settings_map =\n      HostContentSettingsMapFactory::GetForProfile(profile);\n  std::unique_ptr<base::Value> setting =\n      host_content_settings_map->GetWebsiteSetting(\n          requesting_url, requesting_url,\n          CONTENT_SETTINGS_TYPE_AUTO_SELECT_CERTIFICATE, std::string(), NULL);\n\n  if (!setting)\n    return nullptr;\n\n  const base::DictionaryValue* setting_dict;\n  if (!setting->GetAsDictionary(&setting_dict)) {\n    NOTREACHED();\n    return nullptr;\n  }\n\n  const base::Value* filters =\n      setting_dict->FindKeyOfType(\"filters\", base::Value::Type::LIST);\n  if (filters) {\n    for (const base::Value& filter : filters->GetList()) {\n      const base::DictionaryValue* filter_dict;\n      if (!filter.GetAsDictionary(&filter_dict)) {\n        NOTREACHED();\n        continue;\n      }\n      // Use the first certificate that is matched by the filter.\n      for (size_t i = 0; i < client_certs.size(); ++i) {\n        if (CertMatchesFilter(*client_certs[i]->certificate(), *filter_dict)) {\n          return std::move(client_certs[i]);\n        }\n      }\n    }\n  } else {\n    // |setting_dict| has the wrong format (e.g. single filter instead of a\n    // list of filters). This content setting is only provided by\n    // the |PolicyProvider|, which should always set it to a valid format.\n    // Therefore, delete the invalid value.\n    host_content_settings_map->SetWebsiteSettingDefaultScope(\n        requesting_url, requesting_url,\n        CONTENT_SETTINGS_TYPE_AUTO_SELECT_CERTIFICATE, std::string(), nullptr);\n  }\n\n  return nullptr;\n}\n\n}  // namespace\n\nvoid ChromeContentBrowserClient::SelectClientCertificate(\n    content::WebContents* web_contents,\n    net::SSLCertRequestInfo* cert_request_info,\n    net::ClientCertIdentityList client_certs,\n    std::unique_ptr<content::ClientCertificateDelegate> delegate) {\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(web_contents);\n  if (prerender_contents) {\n    prerender_contents->Destroy(\n        prerender::FINAL_STATUS_SSL_CLIENT_CERTIFICATE_REQUESTED);\n    return;\n  }\n\n  GURL requesting_url(\"https://\" + cert_request_info->host_and_port.ToString());\n  DCHECK(requesting_url.is_valid())\n      << \"Invalid URL string: https://\"\n      << cert_request_info->host_and_port.ToString();\n\n  bool may_show_cert_selection = true;\n\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n#if defined(OS_CHROMEOS)\n  if (chromeos::ProfileHelper::IsSigninProfile(profile)) {\n    // TODO(pmarko): crbug.com/723849: Set |may_show_cert_selection| to false\n    // and remove the command-line flag after prototype phase when the\n    // DeviceLoginScreenAutoSelectCertificateForUrls policy is live.\n    may_show_cert_selection =\n        chromeos::switches::IsSigninFrameClientCertUserSelectionEnabled();\n\n    content::StoragePartition* storage_partition =\n        content::BrowserContext::GetStoragePartition(\n            profile, web_contents->GetSiteInstance());\n    chromeos::login::SigninPartitionManager* signin_partition_manager =\n        chromeos::login::SigninPartitionManager::Factory::GetForBrowserContext(\n            profile);\n\n    // On the sign-in profile, only allow client certs in the context of the\n    // sign-in frame.\n    if (!signin_partition_manager->IsCurrentSigninStoragePartition(\n            storage_partition)) {\n      LOG(WARNING)\n          << \"Client cert requested in sign-in profile in wrong context.\";\n      // Continue without client certificate. We do this to mimic the case of no\n      // client certificate being present in the profile's certificate store.\n      delegate->ContinueWithCertificate(nullptr, nullptr);\n      return;\n    }\n    VLOG(1) << \"Client cert requested in sign-in profile.\";\n  }\n#endif  // defined(OS_CHROMEOS)\n\n  std::unique_ptr<net::ClientCertIdentity> auto_selected_identity =\n      AutoSelectCertificate(profile, requesting_url, client_certs);\n  if (auto_selected_identity) {\n    // The callback will own |auto_selected_identity| and |delegate|, keeping\n    // them alive until after ContinueWithCertificate is called.\n    scoped_refptr<net::X509Certificate> cert =\n        auto_selected_identity->certificate();\n    net::ClientCertIdentity::SelfOwningAcquirePrivateKey(\n        std::move(auto_selected_identity),\n        base::Bind(&content::ClientCertificateDelegate::ContinueWithCertificate,\n                   base::Passed(&delegate), std::move(cert)));\n    return;\n  }\n\n  if (!may_show_cert_selection) {\n    LOG(WARNING) << \"No client cert matched by policy and user selection is \"\n                    \"not allowed.\";\n    // Continue without client certificate. We do this to mimic the case of no\n    // client certificate being present in the profile's certificate store.\n    delegate->ContinueWithCertificate(nullptr, nullptr);\n    return;\n  }\n\n  chrome::ShowSSLClientCertificateSelector(web_contents, cert_request_info,\n                                           std::move(client_certs),\n                                           std::move(delegate));\n}\n\ncontent::MediaObserver* ChromeContentBrowserClient::GetMediaObserver() {\n  return MediaCaptureDevicesDispatcher::GetInstance();\n}\n\ncontent::PlatformNotificationService*\nChromeContentBrowserClient::GetPlatformNotificationService() {\n  return PlatformNotificationServiceImpl::GetInstance();\n}\n\nbool ChromeContentBrowserClient::CanCreateWindow(\n    RenderFrameHost* opener,\n    const GURL& opener_url,\n    const GURL& opener_top_level_frame_url,\n    const GURL& source_origin,\n    content::mojom::WindowContainerType container_type,\n    const GURL& target_url,\n    const content::Referrer& referrer,\n    const std::string& frame_name,\n    WindowOpenDisposition disposition,\n    const blink::mojom::WindowFeatures& features,\n    bool user_gesture,\n    bool opener_suppressed,\n    bool* no_javascript_access) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(opener);\n\n  content::WebContents* web_contents =\n      content::WebContents::FromRenderFrameHost(opener);\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  DCHECK(profile);\n  *no_javascript_access = false;\n\n  // If the opener is trying to create a background window but doesn't have\n  // the appropriate permission, fail the attempt.\n  if (container_type == content::mojom::WindowContainerType::BACKGROUND) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n    auto* process_map = extensions::ProcessMap::Get(profile);\n    auto* registry = extensions::ExtensionRegistry::Get(profile);\n    if (!URLHasExtensionBackgroundPermission(process_map, registry, opener_url,\n                                             opener->GetProcess()->GetID())) {\n      return false;\n    }\n\n    // Note: this use of GetExtensionOrAppByURL is safe but imperfect.  It may\n    // return a recently installed Extension even if this CanCreateWindow call\n    // was made by an old copy of the page in a normal web process.  That's ok,\n    // because the permission check above would have caused an early return\n    // already. We must use the full URL to find hosted apps, though, and not\n    // just the origin.\n    const Extension* extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(opener_url);\n    if (extension && !extensions::BackgroundInfo::AllowJSAccess(extension))\n      *no_javascript_access = true;\n#endif\n\n    return true;\n  }\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  if (extensions::WebViewRendererState::GetInstance()->IsGuest(\n          opener->GetProcess()->GetID())) {\n    return true;\n  }\n\n  if (target_url.SchemeIs(extensions::kExtensionScheme)) {\n    // Intentionally duplicating |registry| code from above because we want to\n    // reduce calls to retrieve them as this function is a SYNC IPC handler.\n    auto* registry = extensions::ExtensionRegistry::Get(profile);\n    const Extension* extension =\n        registry->enabled_extensions().GetExtensionOrAppByURL(target_url);\n    if (extension && extension->is_platform_app()) {\n      UMA_HISTOGRAM_ENUMERATION(\n          \"Extensions.AppLoadedInTab\",\n          ClassifyAppLoadedInTabSource(opener_url, extension),\n          APP_LOADED_IN_TAB_SOURCE_MAX);\n\n      // window.open() may not be used to load v2 apps in a regular tab.\n      return false;\n    }\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  HostContentSettingsMap* content_settings =\n      HostContentSettingsMapFactory::GetForProfile(profile);\n  if (FlashDownloadInterception::ShouldStopFlashDownloadAction(\n          content_settings, opener_top_level_frame_url, target_url,\n          user_gesture)) {\n    FlashDownloadInterception::InterceptFlashDownloadNavigation(\n        web_contents, opener_top_level_frame_url);\n    return false;\n  }\n#endif\n\n  // Don't let prerenders open popups.\n  if (auto* prerender_contents =\n          prerender::PrerenderContents::FromWebContents(web_contents)) {\n    prerender_contents->Destroy(prerender::FINAL_STATUS_CREATE_NEW_WINDOW);\n    return false;\n  }\n\n  BlockedWindowParams blocked_params(target_url, referrer, frame_name,\n                                     disposition, features, user_gesture,\n                                     opener_suppressed);\n  NavigateParams nav_params = blocked_params.CreateNavigateParams(web_contents);\n  if (PopupBlockerTabHelper::MaybeBlockPopup(\n          web_contents, opener_top_level_frame_url, &nav_params,\n          nullptr /*=open_url_params*/, blocked_params.features())) {\n    return false;\n  }\n\n#if defined(OS_ANDROID)\n  auto* single_tab_mode_helper =\n      SingleTabModeTabHelper::FromWebContents(web_contents);\n  if (single_tab_mode_helper &&\n      single_tab_mode_helper->block_all_new_windows()) {\n    if (TabAndroid* tab_android = TabAndroid::FromWebContents(web_contents)) {\n      tab_android->HandlePopupNavigation(&nav_params);\n    }\n    return false;\n  }\n#endif\n\n  return true;\n}\n\nvoid ChromeContentBrowserClient::ResourceDispatcherHostCreated() {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  safe_browsing_service_ = g_browser_process->safe_browsing_service();\n\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->ResourceDispatcherHostCreated();\n\n  return g_browser_process->ResourceDispatcherHostCreated();\n}\n\ncontent::SpeechRecognitionManagerDelegate*\n    ChromeContentBrowserClient::CreateSpeechRecognitionManagerDelegate() {\n  return new speech::ChromeSpeechRecognitionManagerDelegate();\n}\n\nnet::NetLog* ChromeContentBrowserClient::GetNetLog() {\n  return g_browser_process->net_log();\n}\n\nvoid ChromeContentBrowserClient::OverrideWebkitPrefs(\n    RenderViewHost* rvh, WebPreferences* web_prefs) {\n  Profile* profile = Profile::FromBrowserContext(\n      rvh->GetProcess()->GetBrowserContext());\n  PrefService* prefs = profile->GetPrefs();\n\n// Fill font preferences. These are not registered on Android\n// - http://crbug.com/308033, http://crbug.com/696364.\n#if !defined(OS_ANDROID)\n  FontFamilyCache::FillFontFamilyMap(profile,\n                                     prefs::kWebKitStandardFontFamilyMap,\n                                     &web_prefs->standard_font_family_map);\n  FontFamilyCache::FillFontFamilyMap(profile,\n                                     prefs::kWebKitFixedFontFamilyMap,\n                                     &web_prefs->fixed_font_family_map);\n  FontFamilyCache::FillFontFamilyMap(profile,\n                                     prefs::kWebKitSerifFontFamilyMap,\n                                     &web_prefs->serif_font_family_map);\n  FontFamilyCache::FillFontFamilyMap(profile,\n                                     prefs::kWebKitSansSerifFontFamilyMap,\n                                     &web_prefs->sans_serif_font_family_map);\n  FontFamilyCache::FillFontFamilyMap(profile,\n                                     prefs::kWebKitCursiveFontFamilyMap,\n                                     &web_prefs->cursive_font_family_map);\n  FontFamilyCache::FillFontFamilyMap(profile,\n                                     prefs::kWebKitFantasyFontFamilyMap,\n                                     &web_prefs->fantasy_font_family_map);\n  FontFamilyCache::FillFontFamilyMap(profile,\n                                     prefs::kWebKitPictographFontFamilyMap,\n                                     &web_prefs->pictograph_font_family_map);\n\n  web_prefs->default_font_size =\n      prefs->GetInteger(prefs::kWebKitDefaultFontSize);\n  web_prefs->default_fixed_font_size =\n      prefs->GetInteger(prefs::kWebKitDefaultFixedFontSize);\n  web_prefs->minimum_font_size =\n      prefs->GetInteger(prefs::kWebKitMinimumFontSize);\n  web_prefs->minimum_logical_font_size =\n      prefs->GetInteger(prefs::kWebKitMinimumLogicalFontSize);\n#endif\n\n  web_prefs->default_encoding = prefs->GetString(prefs::kDefaultCharset);\n\n  web_prefs->dom_paste_enabled =\n      prefs->GetBoolean(prefs::kWebKitDomPasteEnabled);\n  web_prefs->javascript_can_access_clipboard =\n      prefs->GetBoolean(prefs::kWebKitJavascriptCanAccessClipboard);\n  web_prefs->tabs_to_links = prefs->GetBoolean(prefs::kWebkitTabsToLinks);\n\n  if (!prefs->GetBoolean(prefs::kWebKitJavascriptEnabled))\n    web_prefs->javascript_enabled = false;\n\n  // Only allow disabling web security via the command-line flag if the user\n  // has specified a distinct profile directory. This still enables tests to\n  // disable web security by setting the pref directly.\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n  if (!prefs->GetBoolean(prefs::kWebKitWebSecurityEnabled)) {\n    web_prefs->web_security_enabled = false;\n  } else if (!web_prefs->web_security_enabled &&\n             command_line->HasSwitch(switches::kDisableWebSecurity) &&\n             !command_line->HasSwitch(switches::kUserDataDir)) {\n    LOG(ERROR) << \"Web security may only be disabled if '--user-data-dir' is \"\n               \"also specified.\";\n    web_prefs->web_security_enabled = true;\n  }\n\n  if (!prefs->GetBoolean(prefs::kWebKitPluginsEnabled))\n    web_prefs->plugins_enabled = false;\n  web_prefs->loads_images_automatically =\n      prefs->GetBoolean(prefs::kWebKitLoadsImagesAutomatically);\n\n  if (prefs->GetBoolean(prefs::kDisable3DAPIs)) {\n    web_prefs->webgl1_enabled = false;\n    web_prefs->webgl2_enabled = false;\n  }\n\n  web_prefs->allow_running_insecure_content =\n      prefs->GetBoolean(prefs::kWebKitAllowRunningInsecureContent);\n#if defined(OS_ANDROID)\n  web_prefs->font_scale_factor =\n      static_cast<float>(prefs->GetDouble(prefs::kWebKitFontScaleFactor));\n  web_prefs->device_scale_adjustment = GetDeviceScaleAdjustment();\n  web_prefs->force_enable_zoom =\n      prefs->GetBoolean(prefs::kWebKitForceEnableZoom);\n#endif\n\n#if defined(OS_ANDROID)\n  web_prefs->password_echo_enabled =\n      prefs->GetBoolean(prefs::kWebKitPasswordEchoEnabled);\n#else\n  web_prefs->password_echo_enabled = browser_defaults::kPasswordEchoEnabled;\n#endif\n\n  web_prefs->text_areas_are_resizable =\n      prefs->GetBoolean(prefs::kWebKitTextAreasAreResizable);\n  web_prefs->hyperlink_auditing_enabled =\n      prefs->GetBoolean(prefs::kEnableHyperlinkAuditing);\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  std::string image_animation_policy =\n      prefs->GetString(prefs::kAnimationPolicy);\n  if (image_animation_policy == kAnimationPolicyOnce)\n    web_prefs->animation_policy =\n        content::IMAGE_ANIMATION_POLICY_ANIMATION_ONCE;\n  else if (image_animation_policy == kAnimationPolicyNone)\n    web_prefs->animation_policy = content::IMAGE_ANIMATION_POLICY_NO_ANIMATION;\n  else\n    web_prefs->animation_policy = content::IMAGE_ANIMATION_POLICY_ALLOWED;\n#endif\n\n  // Make sure we will set the default_encoding with canonical encoding name.\n  web_prefs->default_encoding =\n      base::GetCanonicalEncodingNameByAliasName(web_prefs->default_encoding);\n  if (web_prefs->default_encoding.empty()) {\n    prefs->ClearPref(prefs::kDefaultCharset);\n    web_prefs->default_encoding = prefs->GetString(prefs::kDefaultCharset);\n  }\n  DCHECK(!web_prefs->default_encoding.empty());\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnablePotentiallyAnnoyingSecurityFeatures)) {\n    web_prefs->disable_reading_from_canvas = true;\n    web_prefs->strict_mixed_content_checking = true;\n    web_prefs->strict_powerful_feature_restrictions = true;\n  }\n\n  web_prefs->data_saver_enabled = GetDataSaverEnabledPref(prefs);\n\n  web_prefs->data_saver_holdback_web_api_enabled =\n      base::GetFieldTrialParamByFeatureAsBool(features::kDataSaverHoldback,\n                                              \"holdback_web\", false);\n  web_prefs->data_saver_holdback_media_api_enabled =\n      base::GetFieldTrialParamByFeatureAsBool(features::kDataSaverHoldback,\n                                              \"holdback_media\", false);\n\n  content::WebContents* contents =\n      content::WebContents::FromRenderViewHost(rvh);\n  if (contents) {\n#if defined(OS_ANDROID)\n    TabAndroid* tab_android = TabAndroid::FromWebContents(contents);\n    if (tab_android) {\n      web_prefs->embedded_media_experience_enabled =\n          tab_android->ShouldEnableEmbeddedMediaExperience();\n\n      if (base::FeatureList::IsEnabled(\n              features::kAllowAutoplayUnmutedInWebappManifestScope)) {\n        web_prefs->media_playback_gesture_whitelist_scope =\n            tab_android->GetWebappManifestScope();\n      }\n\n      if (base::FeatureList::IsEnabled(media::kUseSurfaceLayerForVideo)) {\n        web_prefs->picture_in_picture_enabled =\n            tab_android->IsPictureInPictureEnabled();\n      }\n    }\n#endif  // defined(OS_ANDROID)\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n    Browser* browser = chrome::FindBrowserWithWebContents(contents);\n    if (browser && browser->hosted_app_controller() &&\n        browser->hosted_app_controller()->created_for_installed_pwa()) {\n      web_prefs->strict_mixed_content_checking = true;\n    }\n#endif\n\n    web_prefs->immersive_mode_enabled = vr::VrTabHelper::IsInVr(contents);\n  }\n\n#if defined(OS_ANDROID)\n  web_prefs->video_fullscreen_detection_enabled =\n      chrome::android::AppHooks::ShouldDetectVideoFullscreen();\n\n  web_prefs->enable_media_download_in_product_help =\n      base::FeatureList::IsEnabled(\n          feature_engagement::kIPHMediaDownloadFeature);\n#endif  // defined(OS_ANDROID)\n\n  if (base::FeatureList::IsEnabled(features::kLowPriorityIframes)) {\n    // Obtain the maximum effective connection type at which the feature is\n    // enabled.\n    std::string effective_connection_type_param =\n        base::GetFieldTrialParamValueByFeature(\n            features::kLowPriorityIframes,\n            \"max_effective_connection_type_threshold\");\n\n    base::Optional<net::EffectiveConnectionType> effective_connection_type =\n        net::GetEffectiveConnectionTypeForName(effective_connection_type_param);\n    if (effective_connection_type) {\n      web_prefs->low_priority_iframes_threshold =\n          effective_connection_type.value();\n    }\n  }\n\n  if (base::FeatureList::IsEnabled(features::kLazyFrameLoading)) {\n    const char* param_name =\n        web_prefs->data_saver_enabled\n            ? \"lazy_frame_loading_distance_thresholds_px_by_ect\"\n            : \"lazy_frame_loading_distance_thresholds_px_by_ect_with_data_\"\n              \"saver_enabled\";\n\n    base::StringPairs pairs;\n    base::SplitStringIntoKeyValuePairs(\n        base::GetFieldTrialParamValueByFeature(features::kLazyFrameLoading,\n                                               param_name),\n        ':', ',', &pairs);\n\n    for (const auto& pair : pairs) {\n      base::Optional<net::EffectiveConnectionType> effective_connection_type =\n          net::GetEffectiveConnectionTypeForName(pair.first);\n      int value = 0;\n      if (effective_connection_type && base::StringToInt(pair.second, &value)) {\n        web_prefs->lazy_frame_loading_distance_thresholds_px\n            [effective_connection_type.value()] = value;\n      }\n    }\n  }\n\n#if !defined(OS_ANDROID)\n  // If autoplay is allowed by policy then update the autoplay policy in web\n  // preferences.\n  if (IsAutoplayAllowedByPolicy(contents, prefs)) {\n    web_prefs->autoplay_policy =\n        content::AutoplayPolicy::kNoUserGestureRequired;\n  }\n#endif  // !defined(OS_ANDROID)\n\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->OverrideWebkitPrefs(rvh, web_prefs);\n}\n\nvoid ChromeContentBrowserClient::BrowserURLHandlerCreated(\n    BrowserURLHandler* handler) {\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->BrowserURLHandlerCreated(handler);\n\n  // about: handler. Must come before chrome: handler, since it will\n  // rewrite about: urls to chrome: URLs and then expect chrome: to\n  // actually handle them.  Also relies on a preliminary fixup phase.\n  handler->SetFixupHandler(&FixupBrowserAboutURL);\n  handler->AddHandlerPair(&WillHandleBrowserAboutURL,\n                          BrowserURLHandler::null_handler());\n\n  // The group policy NTP URL handler must be registered before the other NTP\n  // URL handlers below.\n  handler->AddHandlerPair(&HandleNewTabPageLocationOverride,\n                          BrowserURLHandler::null_handler());\n\n#if defined(OS_ANDROID)\n  // Handler to rewrite chrome://newtab on Android.\n  handler->AddHandlerPair(&chrome::android::HandleAndroidNativePageURL,\n                          BrowserURLHandler::null_handler());\n#else\n  // Handler to rewrite chrome://newtab for InstantExtended.\n  handler->AddHandlerPair(&search::HandleNewTabURLRewrite,\n                          &search::HandleNewTabURLReverseRewrite);\n#endif\n\n  // chrome: & friends.\n  handler->AddHandlerPair(&ChromeContentBrowserClient::HandleWebUI,\n                          &ChromeContentBrowserClient::HandleWebUIReverse);\n}\n\nbase::FilePath ChromeContentBrowserClient::GetDefaultDownloadDirectory() {\n  return DownloadPrefs::GetDefaultDownloadDirectory();\n}\n\nstd::string ChromeContentBrowserClient::GetDefaultDownloadName() {\n  return l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME);\n}\n\nbase::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {\n  base::FilePath user_data_dir;\n  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);\n  DCHECK(!user_data_dir.empty());\n  return user_data_dir.Append(FILE_PATH_LITERAL(\"ShaderCache\"));\n}\n\nvoid ChromeContentBrowserClient::DidCreatePpapiPlugin(\n    content::BrowserPpapiHost* browser_host) {\n#if BUILDFLAG(ENABLE_PLUGINS)\n  ChromeContentBrowserClientPluginsPart::DidCreatePpapiPlugin(browser_host);\n#endif\n}\n\ncontent::BrowserPpapiHost*\n    ChromeContentBrowserClient::GetExternalBrowserPpapiHost(\n        int plugin_process_id) {\n#if BUILDFLAG(ENABLE_NACL)\n  content::BrowserChildProcessHostIterator iter(PROCESS_TYPE_NACL_LOADER);\n  while (!iter.Done()) {\n    nacl::NaClProcessHost* host = static_cast<nacl::NaClProcessHost*>(\n        iter.GetDelegate());\n    if (host->process() &&\n        host->process()->GetData().id == plugin_process_id) {\n      // Found the plugin.\n      return host->browser_ppapi_host();\n    }\n    ++iter;\n  }\n#endif\n  return NULL;\n}\n\nbool ChromeContentBrowserClient::AllowPepperSocketAPI(\n    content::BrowserContext* browser_context,\n    const GURL& url,\n    bool private_api,\n    const content::SocketPermissionRequest* params) {\n#if BUILDFLAG(ENABLE_PLUGINS) && BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientPluginsPart::AllowPepperSocketAPI(\n      browser_context, url, private_api, params, allowed_socket_origins_);\n#else\n  return false;\n#endif\n}\n\nbool ChromeContentBrowserClient::IsPepperVpnProviderAPIAllowed(\n    content::BrowserContext* browser_context,\n    const GURL& url) {\n#if BUILDFLAG(ENABLE_PLUGINS) && BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientPluginsPart::IsPepperVpnProviderAPIAllowed(\n      browser_context, url);\n#else\n  return false;\n#endif\n}\n\nstd::unique_ptr<content::VpnServiceProxy>\nChromeContentBrowserClient::GetVpnServiceProxy(\n    content::BrowserContext* browser_context) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::GetVpnServiceProxy(\n      browser_context);\n#else\n  return nullptr;\n#endif\n}\n\nstd::unique_ptr<ui::SelectFilePolicy>\nChromeContentBrowserClient::CreateSelectFilePolicy(WebContents* web_contents) {\n  return std::make_unique<ChromeSelectFilePolicy>(web_contents);\n}\n\nvoid ChromeContentBrowserClient::GetAdditionalAllowedSchemesForFileSystem(\n    std::vector<std::string>* additional_allowed_schemes) {\n  ContentBrowserClient::GetAdditionalAllowedSchemesForFileSystem(\n      additional_allowed_schemes);\n  additional_allowed_schemes->push_back(content::kChromeDevToolsScheme);\n  additional_allowed_schemes->push_back(content::kChromeUIScheme);\n  for (size_t i = 0; i < extra_parts_.size(); ++i) {\n    extra_parts_[i]->GetAdditionalAllowedSchemesForFileSystem(\n        additional_allowed_schemes);\n  }\n}\n\nvoid ChromeContentBrowserClient::GetSchemesBypassingSecureContextCheckWhitelist(\n    std::set<std::string>* schemes) {\n  *schemes = secure_origin_whitelist::GetSchemesBypassingSecureContextCheck();\n}\n\nvoid ChromeContentBrowserClient::GetURLRequestAutoMountHandlers(\n    std::vector<storage::URLRequestAutoMountHandler>* handlers) {\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->GetURLRequestAutoMountHandlers(handlers);\n}\n\n::rappor::RapporService* ChromeContentBrowserClient::GetRapporService() {\n  return g_browser_process->rappor_service();\n}\n\nvoid ChromeContentBrowserClient::GetAdditionalFileSystemBackends(\n    content::BrowserContext* browser_context,\n    const base::FilePath& storage_partition_path,\n    std::vector<std::unique_ptr<storage::FileSystemBackend>>*\n        additional_backends) {\n#if defined(OS_CHROMEOS)\n  storage::ExternalMountPoints* external_mount_points =\n      content::BrowserContext::GetMountPoints(browser_context);\n  DCHECK(external_mount_points);\n  auto backend = std::make_unique<chromeos::FileSystemBackend>(\n      std::make_unique<drive::FileSystemBackendDelegate>(),\n      std::make_unique<chromeos::file_system_provider::BackendDelegate>(),\n      std::make_unique<chromeos::MTPFileSystemBackendDelegate>(\n          storage_partition_path),\n      std::make_unique<arc::ArcContentFileSystemBackendDelegate>(),\n      std::make_unique<arc::ArcDocumentsProviderBackendDelegate>(),\n      external_mount_points, storage::ExternalMountPoints::GetSystemInstance());\n  backend->AddSystemMountPoints();\n  DCHECK(backend->CanHandleType(storage::kFileSystemTypeExternal));\n  additional_backends->push_back(std::move(backend));\n#endif\n\n  for (size_t i = 0; i < extra_parts_.size(); ++i) {\n    extra_parts_[i]->GetAdditionalFileSystemBackends(\n        browser_context, storage_partition_path, additional_backends);\n  }\n}\n\n#if defined(OS_POSIX) && !defined(OS_MACOSX)\nvoid ChromeContentBrowserClient::GetAdditionalMappedFilesForChildProcess(\n    const base::CommandLine& command_line,\n    int child_process_id,\n    PosixFileDescriptorInfo* mappings) {\n\n#if defined(OS_ANDROID)\n  base::MemoryMappedFile::Region region;\n  int fd = ui::GetMainAndroidPackFd(&region);\n  mappings->ShareWithRegion(kAndroidUIResourcesPakDescriptor, fd, region);\n\n  fd = ui::GetCommonResourcesPackFd(&region);\n  mappings->ShareWithRegion(kAndroidChrome100PercentPakDescriptor, fd, region);\n\n  fd = ui::GetLocalePackFd(&region);\n  mappings->ShareWithRegion(kAndroidLocalePakDescriptor, fd, region);\n\n  // Optional secondary locale .pak file.\n  fd = ui::GetSecondaryLocalePackFd(&region);\n  if (fd != -1) {\n    mappings->ShareWithRegion(kAndroidSecondaryLocalePakDescriptor, fd, region);\n  }\n\n  breakpad::CrashDumpObserver::GetInstance()->BrowserChildProcessStarted(\n      child_process_id, mappings);\n\n  base::FilePath app_data_path;\n  base::PathService::Get(base::DIR_ANDROID_APP_DATA, &app_data_path);\n  DCHECK(!app_data_path.empty());\n#else\n  int crash_signal_fd = GetCrashSignalFD(command_line);\n  if (crash_signal_fd >= 0) {\n    mappings->Share(service_manager::kCrashDumpSignal, crash_signal_fd);\n  }\n#endif  // defined(OS_ANDROID)\n}\n#endif  // defined(OS_POSIX) && !defined(OS_MACOSX)\n\n#if defined(OS_WIN)\nbase::string16 ChromeContentBrowserClient::GetAppContainerSidForSandboxType(\n    int sandbox_type) const {\n  base::string16 sid;\n\n#if defined(GOOGLE_CHROME_BUILD)\n  const version_info::Channel channel = chrome::GetChannel();\n\n  // It's possible to have a SxS installation running at the same time as a\n  // non-SxS so isolate them from each other.\n  if (channel == version_info::Channel::CANARY) {\n    sid.assign(\n        L\"S-1-15-2-3251537155-1984446955-2931258699-841473695-1938553385-\"\n        L\"924012150-\");\n  } else {\n    sid.assign(\n        L\"S-1-15-2-3251537155-1984446955-2931258699-841473695-1938553385-\"\n        L\"924012149-\");\n  }\n#else\n  sid.assign(\n      L\"S-1-15-2-3251537155-1984446955-2931258699-841473695-1938553385-\"\n      L\"924012148-\");\n#endif\n\n  // TODO(wfh): Add support for more process types here. crbug.com/499523\n  switch (sandbox_type) {\n    case service_manager::SANDBOX_TYPE_RENDERER:\n      return sid + L\"129201922\";\n    case service_manager::SANDBOX_TYPE_UTILITY:\n      return base::string16();\n    case service_manager::SANDBOX_TYPE_GPU:\n      return base::string16();\n    case service_manager::SANDBOX_TYPE_PPAPI:\n      return sid + L\"129201925\";\n#if BUILDFLAG(ENABLE_NACL)\n    case PROCESS_TYPE_NACL_LOADER:\n      return base::string16();\n    case PROCESS_TYPE_NACL_BROKER:\n      return base::string16();\n#endif\n  }\n\n  // Should never reach here.\n  CHECK(0);\n  return base::string16();\n}\n\nbool ChromeContentBrowserClient::PreSpawnRenderer(\n    sandbox::TargetPolicy* policy) {\n  // This code is duplicated in nacl_exe_win_64.cc.\n  // Allow the server side of a pipe restricted to the \"chrome.nacl.\"\n  // namespace so that it cannot impersonate other system or other chrome\n  // service pipes.\n  sandbox::ResultCode result = policy->AddRule(\n      sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,\n      sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,\n      L\"\\\\\\\\.\\\\pipe\\\\chrome.nacl.*\");\n  if (result != sandbox::SBOX_ALL_OK)\n    return false;\n  return result == sandbox::SBOX_ALL_OK;\n}\n#endif  // defined(OS_WIN)\n\nvoid ChromeContentBrowserClient::ExposeInterfacesToRenderer(\n    service_manager::BinderRegistry* registry,\n    blink::AssociatedInterfaceRegistry* associated_registry,\n    content::RenderProcessHost* render_process_host) {\n  // The CacheStatsRecorder is an associated binding, instead of a\n  // non-associated one, because the sender (in the renderer process) posts the\n  // message after a time delay, in order to rate limit. The association\n  // protects against the render process host ID being recycled in that time\n  // gap between the preparation and the execution of that IPC.\n  associated_registry->AddInterface(\n      base::Bind(&CacheStatsRecorder::Create, render_process_host->GetID()));\n\n  scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner =\n      content::BrowserThread::GetTaskRunnerForThread(\n          content::BrowserThread::UI);\n  registry->AddInterface(\n      base::Bind(&rappor::RapporRecorderImpl::Create,\n                 g_browser_process->rappor_service()),\n      ui_task_runner);\n  registry->AddInterface(\n      base::BindRepeating(&metrics::CallStackProfileCollector::Create,\n                          metrics::CallStackProfileParams::RENDERER_PROCESS));\n\n  if (NetBenchmarking::CheckBenchmarkingEnabled()) {\n    Profile* profile =\n        Profile::FromBrowserContext(render_process_host->GetBrowserContext());\n    auto* loading_predictor =\n        predictors::LoadingPredictorFactory::GetForProfile(profile);\n    auto* predictor = profile->GetNetworkPredictor();\n    net::URLRequestContextGetter* context =\n        render_process_host->GetStoragePartition()->GetURLRequestContext();\n    registry->AddInterface(base::Bind(\n        &NetBenchmarking::Create,\n        loading_predictor ? loading_predictor->GetWeakPtr() : nullptr,\n        predictor ? predictor->GetUIWeakPtr() : nullptr,\n        base::RetainedRef(context)));\n  }\n\n#if defined(SAFE_BROWSING_DB_LOCAL) || defined(SAFE_BROWSING_DB_REMOTE)\n  if (safe_browsing_service_) {\n    content::ResourceContext* resource_context =\n        render_process_host->GetBrowserContext()->GetResourceContext();\n    registry->AddInterface(\n        base::Bind(\n            &safe_browsing::MojoSafeBrowsingImpl::MaybeCreate,\n            render_process_host->GetID(), resource_context,\n            base::Bind(\n                &ChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate,\n                base::Unretained(this), resource_context)),\n        BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));\n  }\n#endif  // defined(SAFE_BROWSING_DB_LOCAL) || defined(SAFE_BROWSING_DB_REMOTE)\n\n#if defined(OS_WIN)\n  if (base::FeatureList::IsEnabled(features::kModuleDatabase)) {\n    // Add the ModuleEventSink interface. This is the interface used by renderer\n    // processes to notify the browser of modules in their address space. The\n    // process handle is not yet available at this point so pass in a callback\n    // to allow to retrieve a duplicate at the time the interface is actually\n    // created. It is safe to pass a raw pointer to |render_process_host|: the\n    // callback will be invoked in the context of ModuleDatabase::GetInstance,\n    // which is invoked by Mojo initialization, which occurs while the\n    // |render_process_host| is alive.\n    auto get_process = base::BindRepeating(\n        [](content::RenderProcessHost* host) -> base::Process {\n          return host->GetProcess().Duplicate();\n        },\n        base::Unretained(render_process_host));\n    // The ModuleDatabase is a global singleton so passing an unretained pointer\n    // is safe.\n    registry->AddInterface(\n        base::BindRepeating(&ModuleEventSinkImpl::Create,\n                            std::move(get_process),\n                            content::PROCESS_TYPE_RENDERER,\n                            base::Unretained(ModuleDatabase::GetInstance())),\n        ui_task_runner);\n  }\n#endif\n\n  for (auto* ep : extra_parts_) {\n    ep->ExposeInterfacesToRenderer(registry, associated_registry,\n                                   render_process_host);\n  }\n}\n\nvoid ChromeContentBrowserClient::ExposeInterfacesToMediaService(\n    service_manager::BinderRegistry* registry,\n    content::RenderFrameHost* render_frame_host) {\n#if BUILDFLAG(ENABLE_LIBRARY_CDMS)\n  registry->AddInterface(\n      base::Bind(&OutputProtectionImpl::Create, render_frame_host));\n  registry->AddInterface(\n      base::Bind(&PlatformVerificationImpl::Create, render_frame_host));\n#endif  // BUILDFLAG(ENABLE_LIBRARY_CDMS)\n\n#if BUILDFLAG(ENABLE_MOJO_CDM) && defined(OS_ANDROID)\n  registry->AddInterface(base::Bind(&CreateMediaDrmStorage, render_frame_host));\n#endif\n}\n\nvoid ChromeContentBrowserClient::BindInterfaceRequestFromFrame(\n    content::RenderFrameHost* render_frame_host,\n    const std::string& interface_name,\n    mojo::ScopedMessagePipeHandle interface_pipe) {\n  if (!frame_interfaces_ && !frame_interfaces_parameterized_ &&\n      !worker_interfaces_parameterized_) {\n    InitWebContextInterfaces();\n  }\n\n  if (!frame_interfaces_parameterized_->TryBindInterface(\n          interface_name, &interface_pipe, render_frame_host)) {\n    frame_interfaces_->TryBindInterface(interface_name, &interface_pipe);\n  }\n}\n\nvoid ChromeContentBrowserClient::BindInterfaceRequestFromWorker(\n    content::RenderProcessHost* render_process_host,\n    const url::Origin& origin,\n    const std::string& interface_name,\n    mojo::ScopedMessagePipeHandle interface_pipe) {\n  if (!frame_interfaces_ && !frame_interfaces_parameterized_ &&\n      !worker_interfaces_parameterized_) {\n    InitWebContextInterfaces();\n  }\n\n  worker_interfaces_parameterized_->BindInterface(\n      interface_name, std::move(interface_pipe), render_process_host, origin);\n}\n\nvoid ChromeContentBrowserClient::BindInterfaceRequest(\n    const service_manager::BindSourceInfo& source_info,\n    const std::string& interface_name,\n    mojo::ScopedMessagePipeHandle* interface_pipe) {\n  if (source_info.identity.name() == content::mojom::kGpuServiceName)\n    gpu_binder_registry_.TryBindInterface(interface_name, interface_pipe);\n}\n\nvoid ChromeContentBrowserClient::RegisterInProcessServices(\n    StaticServiceMap* services,\n    content::ServiceManagerConnection* connection) {\n  {\n    service_manager::EmbeddedServiceInfo info;\n    info.factory = ChromeService::GetInstance()->CreateChromeServiceFactory();\n    services->insert(std::make_pair(chrome::mojom::kServiceName, info));\n  }\n  if (g_browser_process->pref_service_factory()) {\n    service_manager::EmbeddedServiceInfo info;\n    info.factory =\n        g_browser_process->pref_service_factory()->CreatePrefServiceFactory();\n    info.task_runner = base::ThreadTaskRunnerHandle::Get();\n    services->insert(\n        std::make_pair(prefs::mojom::kLocalStateServiceName, info));\n  }\n  service_manager::EmbeddedServiceInfo info;\n#if BUILDFLAG(ENABLE_MOJO_MEDIA_IN_BROWSER_PROCESS)\n  {\n    service_manager::EmbeddedServiceInfo info;\n    info.factory = base::Bind(&media::CreateMediaService);\n    services->insert(std::make_pair(media::mojom::kMediaServiceName, info));\n  }\n#endif\n\n#if defined(OS_ANDROID)\n  {\n    service_manager::EmbeddedServiceInfo info;\n    info.factory =\n        base::Bind(&proxy_resolver::ProxyResolverService::CreateService);\n    services->insert(\n        std::make_pair(proxy_resolver::mojom::kProxyResolverServiceName, info));\n  }\n#endif\n  g_browser_process->platform_part()->RegisterInProcessServices(services,\n                                                                connection);\n}\n\nvoid ChromeContentBrowserClient::RegisterOutOfProcessServices(\n    OutOfProcessServiceMap* services) {\n#if BUILDFLAG(ENABLE_PRINTING)\n  (*services)[printing::mojom::kServiceName] = l10n_util::GetStringUTF16(\n      IDS_UTILITY_PROCESS_PDF_COMPOSITOR_SERVICE_NAME);\n#endif\n\n#if BUILDFLAG(ENABLE_PRINT_PREVIEW) || \\\n    (BUILDFLAG(ENABLE_PRINTING) && defined(OS_WIN))\n  (*services)[printing::mojom::kChromePrintingServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_PRINTING_SERVICE_NAME);\n#endif\n\n  (*services)[heap_profiling::mojom::kServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_PROFILING_SERVICE_NAME);\n\n#if BUILDFLAG(ENABLE_EXTENSIONS) || defined(OS_ANDROID)\n  (*services)[chrome::mojom::kMediaGalleryUtilServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_MEDIA_GALLERY_UTILITY_NAME);\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  (*services)[chrome::mojom::kRemovableStorageWriterServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_IMAGE_WRITER_NAME);\n#endif\n\n#if defined(OS_WIN)\n  (*services)[chrome::mojom::kUtilWinServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_UTILITY_WIN_NAME);\n#endif\n\n#if defined(OS_WIN) && BUILDFLAG(ENABLE_EXTENSIONS)\n  (*services)[chrome::mojom::kWifiUtilWinServiceName] =\n      l10n_util::GetStringUTF16(\n          IDS_UTILITY_PROCESS_WIFI_CREDENTIALS_GETTER_NAME);\n#endif\n\n#if !defined(OS_ANDROID)\n  (*services)[chrome::mojom::kProfileImportServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_PROFILE_IMPORTER_NAME);\n\n  (*services)[proxy_resolver::mojom::kProxyResolverServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_PROXY_RESOLVER_NAME);\n#endif\n\n#if defined(FULL_SAFE_BROWSING) || defined(OS_CHROMEOS)\n  (*services)[chrome::mojom::kFileUtilServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_FILE_UTILITY_NAME);\n#endif\n\n  (*services)[patch::mojom::kServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_PATCH_NAME);\n\n  (*services)[unzip::mojom::kServiceName] =\n      l10n_util::GetStringUTF16(IDS_UTILITY_PROCESS_UNZIP_NAME);\n\n#if defined(OS_CHROMEOS)\n  ash_service_registry::RegisterOutOfProcessServices(services);\n#endif\n}\n\nbool ChromeContentBrowserClient::ShouldTerminateOnServiceQuit(\n    const service_manager::Identity& id) {\n#if defined(OS_CHROMEOS)\n  return ash_service_registry::ShouldTerminateOnServiceQuit(id.name());\n#endif\n  return false;\n}\n\nstd::unique_ptr<base::Value>\nChromeContentBrowserClient::GetServiceManifestOverlay(base::StringPiece name) {\n  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n  int id = -1;\n  if (name == content::mojom::kBrowserServiceName)\n    id = IDR_CHROME_CONTENT_BROWSER_MANIFEST_OVERLAY;\n  else if (name == content::mojom::kGpuServiceName)\n    id = IDR_CHROME_CONTENT_GPU_MANIFEST_OVERLAY;\n  else if (name == content::mojom::kPackagedServicesServiceName)\n    id = IDR_CHROME_CONTENT_PACKAGED_SERVICES_MANIFEST_OVERLAY;\n  else if (name == content::mojom::kPluginServiceName)\n    id = IDR_CHROME_CONTENT_PLUGIN_MANIFEST_OVERLAY;\n  else if (name == content::mojom::kRendererServiceName)\n    id = IDR_CHROME_CONTENT_RENDERER_MANIFEST_OVERLAY;\n  else if (name == content::mojom::kUtilityServiceName)\n    id = IDR_CHROME_CONTENT_UTILITY_MANIFEST_OVERLAY;\n  if (id == -1)\n    return nullptr;\n\n  base::StringPiece manifest_contents =\n      rb.GetRawDataResourceForScale(id, ui::ScaleFactor::SCALE_FACTOR_NONE);\n  return base::JSONReader::Read(manifest_contents);\n}\n\nstd::vector<content::ContentBrowserClient::ServiceManifestInfo>\nChromeContentBrowserClient::GetExtraServiceManifests() {\n  return std::vector<content::ContentBrowserClient::ServiceManifestInfo>({\n#if BUILDFLAG(ENABLE_NACL)\n    {nacl::kNaClLoaderServiceName, IDR_NACL_LOADER_MANIFEST},\n#if defined(OS_WIN)\n        {nacl::kNaClBrokerServiceName, IDR_NACL_BROKER_MANIFEST},\n#endif  // defined(OS_WIN)\n#endif  // BUILDFLAG(ENABLE_NACL)\n#if BUILDFLAG(ENABLE_PRINTING)\n        {printing::mojom::kServiceName, IDR_PDF_COMPOSITOR_MANIFEST},\n#endif\n        {chrome::mojom::kRendererServiceName,\n         IDR_CHROME_RENDERER_SERVICE_MANIFEST},\n  });\n}\n\nvoid ChromeContentBrowserClient::OpenURL(\n    content::BrowserContext* browser_context,\n    const content::OpenURLParams& params,\n    const base::Callback<void(content::WebContents*)>& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n#if defined(OS_ANDROID)\n  ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,\n                                               callback);\n#else\n  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),\n                            params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav_params.user_gesture = params.user_gesture;\n\n  Navigate(&nav_params);\n  callback.Run(nav_params.navigated_or_inserted_contents);\n#endif\n}\n\ncontent::ControllerPresentationServiceDelegate*\nChromeContentBrowserClient::GetControllerPresentationServiceDelegate(\n    content::WebContents* web_contents) {\n  if (media_router::MediaRouterEnabled(web_contents->GetBrowserContext())) {\n    return media_router::PresentationServiceDelegateImpl::\n        GetOrCreateForWebContents(web_contents);\n  }\n  return nullptr;\n}\n\ncontent::ReceiverPresentationServiceDelegate*\nChromeContentBrowserClient::GetReceiverPresentationServiceDelegate(\n    content::WebContents* web_contents) {\n  if (media_router::MediaRouterEnabled(web_contents->GetBrowserContext())) {\n    // ReceiverPresentationServiceDelegateImpl exists only for WebContents\n    // created for offscreen presentations. The WebContents must belong to\n    // an incognito profile.\n    if (auto* impl = media_router::ReceiverPresentationServiceDelegateImpl::\n            FromWebContents(web_contents)) {\n      DCHECK(web_contents->GetBrowserContext()->IsOffTheRecord());\n      return impl;\n    }\n  }\n  return nullptr;\n}\n\nvoid ChromeContentBrowserClient::RecordURLMetric(const std::string& metric,\n                                                 const GURL& url) {\n  if (url.is_valid()) {\n    rappor::SampleDomainAndRegistryFromGURL(g_browser_process->rappor_service(),\n                                            metric, url);\n  }\n}\n\nstd::string ChromeContentBrowserClient::GetMetricSuffixForURL(const GURL& url) {\n  // Don't change these returned strings. They are written (in hashed form) into\n  // UMA logs. If you add more strings, you must update histograms.xml and get\n  // histograms review. Only Google domains should be here for privacy purposes.\n  // TODO(falken): Ideally Chrome would log the relevant UMA directly and this\n  // function could be removed.\n  if (page_load_metrics::IsGoogleSearchResultUrl(url))\n    return \"search\";\n  if (url.host() == \"docs.google.com\")\n    return \"docs\";\n  return std::string();\n}\n\nstd::vector<std::unique_ptr<content::NavigationThrottle>>\nChromeContentBrowserClient::CreateThrottlesForNavigation(\n    content::NavigationHandle* handle) {\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n\n  // MetricsNavigationThrottle requires that it runs before NavigationThrottles\n  // that may delay or cancel navigations, so only NavigationThrottles that\n  // don't delay or cancel navigations (e.g. throttles that are only observing\n  // callbacks without affecting navigation behavior) should be added before\n  // MetricsNavigationThrottle.\n  if (handle->IsInMainFrame()) {\n    throttles.push_back(\n        page_load_metrics::MetricsNavigationThrottle::Create(handle));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  std::unique_ptr<content::NavigationThrottle> flash_url_throttle =\n      FlashDownloadInterception::MaybeCreateThrottleFor(handle);\n  if (flash_url_throttle)\n    throttles.push_back(std::move(flash_url_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_throttle =\n      SupervisedUserNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (supervised_user_throttle)\n    throttles.push_back(std::move(supervised_user_throttle));\n#endif\n\n#if defined(OS_ANDROID)\n  // TODO(davidben): This is insufficient to integrate with prerender properly.\n  // https://crbug.com/370595\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(handle->GetWebContents());\n  if (!prerender_contents && handle->IsInMainFrame()) {\n    throttles.push_back(\n        navigation_interception::InterceptNavigationDelegate::CreateThrottleFor(\n            handle));\n  }\n  throttles.push_back(InterceptOMADownloadNavigationThrottle::Create(handle));\n#elif BUILDFLAG(ENABLE_EXTENSIONS)\n  if (handle->IsInMainFrame()) {\n    // Redirect some navigations to apps that have registered matching URL\n    // handlers ('url_handlers' in the manifest).\n    auto url_to_app_throttle =\n        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);\n    if (url_to_app_throttle)\n      throttles.push_back(std::move(url_to_app_throttle));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {\n    if (base::FeatureList::IsEnabled(features::kDesktopPWAsLinkCapturing)) {\n      auto bookmark_app_experimental_throttle =\n          extensions::BookmarkAppExperimentalNavigationThrottle::\n              MaybeCreateThrottleFor(handle);\n      if (bookmark_app_experimental_throttle)\n        throttles.push_back(std::move(bookmark_app_experimental_throttle));\n    } else {\n      auto bookmark_app_throttle =\n          extensions::BookmarkAppNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n      if (bookmark_app_throttle)\n        throttles.push_back(std::move(bookmark_app_throttle));\n    }\n  }\n#endif\n\n#if defined(OS_CHROMEOS)\n  // Check if we need to add merge session throttle. This throttle will postpone\n  // loading of main frames.\n  if (handle->IsInMainFrame()) {\n    // Add interstitial page while merge session process (cookie reconstruction\n    // from OAuth2 refresh token in ChromeOS login) is still in progress while\n    // we are attempting to load a google property.\n    if (merge_session_throttling_utils::ShouldAttachNavigationThrottle() &&\n        !merge_session_throttling_utils::AreAllSessionMergedAlready() &&\n        handle->GetURL().SchemeIsHTTPOrHTTPS()) {\n      throttles.push_back(MergeSessionNavigationThrottle::Create(handle));\n    }\n\n    auto url_to_apps_throttle =\n        chromeos::AppsNavigationThrottle::MaybeCreate(handle);\n    if (url_to_apps_throttle)\n      throttles.push_back(std::move(url_to_apps_throttle));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  throttles.push_back(\n      std::make_unique<extensions::ExtensionNavigationThrottle>(handle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_nav_throttle =\n      SupervisedUserGoogleAuthNavigationThrottle::MaybeCreate(handle);\n  if (supervised_user_nav_throttle)\n    throttles.push_back(std::move(supervised_user_nav_throttle));\n#endif\n\n  content::WebContents* web_contents = handle->GetWebContents();\n  if (auto* subresource_filter_client =\n          ChromeSubresourceFilterClient::FromWebContents(web_contents)) {\n    subresource_filter_client->MaybeAppendNavigationThrottles(handle,\n                                                              &throttles);\n  }\n\n#if !defined(OS_ANDROID)\n  // BackgroundTabNavigationThrottle is used by TabManager, which is only\n  // enabled on non-Android platforms.\n  std::unique_ptr<content::NavigationThrottle>\n      background_tab_navigation_throttle = resource_coordinator::\n          BackgroundTabNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (background_tab_navigation_throttle)\n    throttles.push_back(std::move(background_tab_navigation_throttle));\n#endif\n\n#if defined(SAFE_BROWSING_DB_LOCAL)\n  std::unique_ptr<content::NavigationThrottle>\n      password_protection_navigation_throttle =\n          safe_browsing::MaybeCreateNavigationThrottle(handle);\n  if (password_protection_navigation_throttle) {\n    throttles.push_back(std::move(password_protection_navigation_throttle));\n  }\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> pdf_iframe_throttle =\n      PDFIFrameNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (pdf_iframe_throttle)\n    throttles.push_back(std::move(pdf_iframe_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> tab_under_throttle =\n      TabUnderNavigationThrottle::MaybeCreate(handle);\n  if (tab_under_throttle)\n    throttles.push_back(std::move(tab_under_throttle));\n\n  throttles.push_back(std::make_unique<PolicyBlacklistNavigationThrottle>(\n      handle, handle->GetWebContents()->GetBrowserContext()));\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kCommittedInterstitials)) {\n    throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(\n        handle,\n        std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n        base::Bind(&SSLErrorHandler::HandleSSLError)));\n  }\n\n  std::unique_ptr<content::NavigationThrottle> https_upgrade_timing_throttle =\n      TypedNavigationTimingThrottle::MaybeCreateThrottleFor(handle);\n  if (https_upgrade_timing_throttle)\n    throttles.push_back(std::move(https_upgrade_timing_throttle));\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle> devtools_throttle =\n      DevToolsWindow::MaybeCreateNavigationThrottle(handle);\n  if (devtools_throttle)\n    throttles.push_back(std::move(devtools_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> new_tab_page_throttle =\n      NewTabPageNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (new_tab_page_throttle)\n    throttles.push_back(std::move(new_tab_page_throttle));\n#endif\n\n  return throttles;\n}\n\nstd::unique_ptr<content::NavigationUIData>\nChromeContentBrowserClient::GetNavigationUIData(\n    content::NavigationHandle* navigation_handle) {\n  return std::make_unique<ChromeNavigationUIData>(navigation_handle);\n}\n\ncontent::DevToolsManagerDelegate*\nChromeContentBrowserClient::GetDevToolsManagerDelegate() {\n#if defined(OS_ANDROID)\n  return new DevToolsManagerDelegateAndroid();\n#else\n  return new ChromeDevToolsManagerDelegate();\n#endif\n}\n\ncontent::TracingDelegate* ChromeContentBrowserClient::GetTracingDelegate() {\n  return new ChromeTracingDelegate();\n}\n\nbool ChromeContentBrowserClient::IsPluginAllowedToCallRequestOSFileHandle(\n    content::BrowserContext* browser_context,\n    const GURL& url) {\n#if BUILDFLAG(ENABLE_PLUGINS) && BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientPluginsPart::\n      IsPluginAllowedToCallRequestOSFileHandle(browser_context, url,\n                                               allowed_file_handle_origins_);\n#else\n  return false;\n#endif\n}\n\nbool ChromeContentBrowserClient::IsPluginAllowedToUseDevChannelAPIs(\n    content::BrowserContext* browser_context,\n    const GURL& url) {\n#if BUILDFLAG(ENABLE_PLUGINS) && BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientPluginsPart::\n      IsPluginAllowedToUseDevChannelAPIs(browser_context, url,\n                                         allowed_dev_channel_origins_);\n#else\n  return false;\n#endif\n}\n\nvoid ChromeContentBrowserClient::OverridePageVisibilityState(\n    RenderFrameHost* render_frame_host,\n    blink::mojom::PageVisibilityState* visibility_state) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  WebContents* web_contents =\n      WebContents::FromRenderFrameHost(render_frame_host);\n  DCHECK(web_contents);\n\n  prerender::PrerenderManager* prerender_manager =\n      prerender::PrerenderManagerFactory::GetForBrowserContext(\n          web_contents->GetBrowserContext());\n  if (prerender_manager &&\n      prerender_manager->IsWebContentsPrerendering(web_contents, nullptr)) {\n    *visibility_state = blink::mojom::PageVisibilityState::kPrerender;\n  }\n}\n\nvoid ChromeContentBrowserClient::InitWebContextInterfaces() {\n  frame_interfaces_ = std::make_unique<service_manager::BinderRegistry>();\n  frame_interfaces_parameterized_ = std::make_unique<\n      service_manager::BinderRegistryWithArgs<content::RenderFrameHost*>>();\n  worker_interfaces_parameterized_ =\n      std::make_unique<service_manager::BinderRegistryWithArgs<\n          content::RenderProcessHost*, const url::Origin&>>();\n\n  // Register mojo ContentTranslateDriver interface only for main frame.\n  frame_interfaces_parameterized_->AddInterface(base::BindRepeating(\n      &ChromeLanguageDetectionTabHelper::BindContentTranslateDriver));\n\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&autofill::ContentAutofillDriverFactory::BindAutofillDriver));\n\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&password_manager::ContentPasswordManagerDriverFactory::\n                     BindPasswordManagerDriver));\n  frame_interfaces_parameterized_->AddInterface(\n      base::BindRepeating(&ChromePasswordManagerClient::BindCredentialManager));\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&InsecureSensitiveInputDriverFactory::BindDriver));\n\n#if defined(OS_ANDROID)\n  frame_interfaces_parameterized_->AddInterface(base::Bind(\n      &ForwardToJavaFrameRegistry<blink::mojom::InstalledAppProvider>));\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&ForwardToJavaFrameRegistry<payments::mojom::PaymentRequest>));\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&ForwardToJavaFrameRegistry<webauth::mojom::Authenticator>));\n#else\n  if (base::FeatureList::IsEnabled(features::kWebPayments)) {\n    frame_interfaces_parameterized_->AddInterface(\n        base::Bind(&payments::CreatePaymentRequest));\n  }\n#endif\n\n#if defined(OS_ANDROID)\n  frame_interfaces_parameterized_->AddInterface(base::Bind(\n      &ForwardToJavaWebContentsRegistry<blink::mojom::ShareService>));\n#elif defined(OS_LINUX) || defined(OS_WIN)\n  frame_interfaces_->AddInterface(base::Bind(&ShareServiceImpl::Create));\n#endif\n\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&CreateBudgetService));\n\n  worker_interfaces_parameterized_->AddInterface(\n      base::Bind(&BudgetServiceImpl::Create));\n}\n\nvoid ChromeContentBrowserClient::MaybeCopyDisableWebRtcEncryptionSwitch(\n    base::CommandLine* to_command_line,\n    const base::CommandLine& from_command_line,\n    version_info::Channel channel) {\n#if defined(OS_ANDROID)\n  const version_info::Channel kMaxDisableEncryptionChannel =\n      version_info::Channel::BETA;\n#else\n  const version_info::Channel kMaxDisableEncryptionChannel =\n      version_info::Channel::DEV;\n#endif\n  if (channel <= kMaxDisableEncryptionChannel) {\n    static const char* const kWebRtcDevSwitchNames[] = {\n      switches::kDisableWebRtcEncryption,\n    };\n    to_command_line->CopySwitchesFrom(from_command_line,\n                                      kWebRtcDevSwitchNames,\n                                      arraysize(kWebRtcDevSwitchNames));\n  }\n}\n\nstd::unique_ptr<content::MemoryCoordinatorDelegate>\nChromeContentBrowserClient::GetMemoryCoordinatorDelegate() {\n  return memory::ChromeMemoryCoordinatorDelegate::Create();\n}\n\n#if BUILDFLAG(ENABLE_MEDIA_REMOTING)\nvoid ChromeContentBrowserClient::CreateMediaRemoter(\n    content::RenderFrameHost* render_frame_host,\n    media::mojom::RemotingSourcePtr source,\n    media::mojom::RemoterRequest request) {\n  CastRemotingConnector::CreateMediaRemoter(\n      render_frame_host, std::move(source), std::move(request));\n}\n#endif  // BUILDFLAG(ENABLE_MEDIA_REMOTING)\n\nstd::unique_ptr<base::TaskScheduler::InitParams>\nChromeContentBrowserClient::GetTaskSchedulerInitParams() {\n  return task_scheduler_util::GetTaskSchedulerInitParamsForBrowser();\n}\n\nbase::FilePath ChromeContentBrowserClient::GetLoggingFileName(\n    const base::CommandLine& command_line) {\n  return logging::GetLogFileName(command_line);\n}\n\nstd::vector<std::unique_ptr<content::URLLoaderThrottle>>\nChromeContentBrowserClient::CreateURLLoaderThrottles(\n    const network::ResourceRequest& request,\n    content::ResourceContext* resource_context,\n    const base::RepeatingCallback<content::WebContents*()>& wc_getter,\n    content::NavigationUIData* navigation_ui_data,\n    int frame_tree_node_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  bool network_service_enabled =\n      base::FeatureList::IsEnabled(network::features::kNetworkService);\n  std::vector<std::unique_ptr<content::URLLoaderThrottle>> result;\n\n#if defined(SAFE_BROWSING_DB_LOCAL) || defined(SAFE_BROWSING_DB_REMOTE)\n  // Null-check safe_browsing_service_ as in unit tests |resource_context| is a\n  // MockResourceContext and the cast doesn't work.\n  if (safe_browsing_service_) {\n    ProfileIOData* io_data =\n        ProfileIOData::FromResourceContext(resource_context);\n    bool matches_enterprise_whitelist =\n        io_data && safe_browsing::IsURLWhitelistedByPolicy(\n                       request.url, io_data->safe_browsing_whitelist_domains());\n    if (!matches_enterprise_whitelist &&\n        (network_service_enabled ||\n         base::FeatureList::IsEnabled(\n             safe_browsing::kCheckByURLLoaderThrottle))) {\n      auto* delegate = GetSafeBrowsingUrlCheckerDelegate(resource_context);\n      if (delegate && !delegate->ShouldSkipRequestCheck(\n                          resource_context, request.url, frame_tree_node_id,\n                          -1 /* render_process_id */, -1 /* render_frame_id */,\n                          request.originated_from_service_worker)) {\n        auto safe_browsing_throttle =\n            safe_browsing::BrowserURLLoaderThrottle::MaybeCreate(delegate,\n                                                                 wc_getter);\n        if (safe_browsing_throttle)\n          result.push_back(std::move(safe_browsing_throttle));\n      }\n    }\n  }\n#endif  // defined(SAFE_BROWSING_DB_LOCAL) || defined(SAFE_BROWSING_DB_REMOTE)\n\n  if (network_service_enabled) {\n    ChromeNavigationUIData* chrome_navigation_ui_data =\n        static_cast<ChromeNavigationUIData*>(navigation_ui_data);\n    if (chrome_navigation_ui_data &&\n        chrome_navigation_ui_data->prerender_mode() !=\n            prerender::NO_PRERENDER) {\n      result.push_back(std::make_unique<prerender::PrerenderURLLoaderThrottle>(\n          chrome_navigation_ui_data->prerender_mode(),\n          chrome_navigation_ui_data->prerender_histogram_prefix(),\n          base::BindOnce(GetPrerenderCanceller, wc_getter),\n          BrowserThread::GetTaskRunnerForThread(BrowserThread::UI)));\n    }\n\n    ProfileIOData* io_data =\n        ProfileIOData::FromResourceContext(resource_context);\n    bool is_off_the_record = io_data->IsOffTheRecord();\n    bool is_signed_in =\n        !is_off_the_record &&\n        !io_data->google_services_account_id()->GetValue().empty();\n\n    result.push_back(std::make_unique<VariationsHeaderURLLoaderThrottle>(\n        is_off_the_record, is_signed_in));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  if (network_service_enabled) {\n    result.push_back(\n        std::make_unique<PluginResponseInterceptorURLLoaderThrottle>(\n            resource_context, request.resource_type, frame_tree_node_id));\n  }\n#endif\n  return result;\n}\n\nvoid ChromeContentBrowserClient::RegisterNonNetworkNavigationURLLoaderFactories(\n    int frame_tree_node_id,\n    NonNetworkURLLoaderFactoryMap* factories) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  content::WebContents* web_contents =\n      content::WebContents::FromFrameTreeNodeId(frame_tree_node_id);\n  factories->emplace(\n      extensions::kExtensionScheme,\n      extensions::CreateExtensionNavigationURLLoaderFactory(\n          web_contents->GetBrowserContext(),\n          !!extensions::WebViewGuest::FromWebContents(web_contents)));\n#endif\n}\n\nnamespace {\n\n// The FileURLLoaderFactory provided to the extension background pages.\n// Checks with the ChildProcessSecurityPolicy to validate the file access.\nclass FileURLLoaderFactory : public network::mojom::URLLoaderFactory {\n public:\n  explicit FileURLLoaderFactory(int child_id) : child_id_(child_id) {}\n\n private:\n  // network::mojom::URLLoaderFactory:\n  void CreateLoaderAndStart(network::mojom::URLLoaderRequest loader,\n                            int32_t routing_id,\n                            int32_t request_id,\n                            uint32_t options,\n                            const network::ResourceRequest& request,\n                            network::mojom::URLLoaderClientPtr client,\n                            const net::MutableNetworkTrafficAnnotationTag&\n                                traffic_annotation) override {\n    if (!content::ChildProcessSecurityPolicy::GetInstance()->CanRequestURL(\n            child_id_, request.url)) {\n      client->OnComplete(\n          network::URLLoaderCompletionStatus(net::ERR_ACCESS_DENIED));\n      return;\n    }\n    content::CreateFileURLLoader(request, std::move(loader), std::move(client),\n                                 /*observer=*/nullptr);\n  }\n\n  void Clone(network::mojom::URLLoaderFactoryRequest loader) override {\n    bindings_.AddBinding(this, std::move(loader));\n  }\n\n  int child_id_;\n  mojo::BindingSet<network::mojom::URLLoaderFactory> bindings_;\n  DISALLOW_COPY_AND_ASSIGN(FileURLLoaderFactory);\n};\n\n}  // namespace\n\nvoid ChromeContentBrowserClient::\n    RegisterNonNetworkSubresourceURLLoaderFactories(\n        int render_process_id,\n        int render_frame_id,\n        NonNetworkURLLoaderFactoryMap* factories) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  auto factory = extensions::CreateExtensionURLLoaderFactory(render_process_id,\n                                                             render_frame_id);\n  if (factory)\n    factories->emplace(extensions::kExtensionScheme, std::move(factory));\n\n  content::RenderFrameHost* frame_host =\n      RenderFrameHost::FromID(render_process_id, render_frame_id);\n\n  // This logic should match\n  // ChromeExtensionWebContentsObserver::RenderFrameCreated.\n  WebContents* web_contents = WebContents::FromRenderFrameHost(frame_host);\n  if (!web_contents)\n    return;\n\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  InstantService* instant_service =\n      InstantServiceFactory::GetForProfile(profile);\n  // The test below matches what's done by ShouldServiceRequestIOThread in\n  // local_ntp_source.cc.\n  if (instant_service->IsInstantProcess(render_process_id)) {\n    factories->emplace(\n        chrome::kChromeSearchScheme,\n        content::CreateWebUIURLLoader(\n            frame_host, chrome::kChromeSearchScheme,\n            /*allowed_webui_hosts=*/base::flat_set<std::string>()));\n  }\n\n  extensions::ChromeExtensionWebContentsObserver* web_observer =\n      extensions::ChromeExtensionWebContentsObserver::FromWebContents(\n          web_contents);\n\n  // There is nothing to do if no ChromeExtensionWebContentsObserver is attached\n  // to the |web_contents|.\n  if (!web_observer)\n    return;\n\n  const Extension* extension =\n      web_observer->GetExtensionFromFrame(frame_host, false);\n  if (!extension)\n    return;\n\n  // Support for chrome:// scheme if appropriate.\n  if ((extension->is_extension() || extension->is_platform_app()) &&\n      Manifest::IsComponentLocation(extension->location())) {\n    // Components of chrome that are implemented as extensions or platform apps\n    // are allowed to use chrome://resources/ and chrome://theme/ URLs.\n    base::flat_set<std::string> allowed_webui_hosts = {\n        content::kChromeUIResourcesHost, chrome::kChromeUIThemeHost};\n    factories->emplace(\n        content::kChromeUIScheme,\n        content::CreateWebUIURLLoader(frame_host, content::kChromeUIScheme,\n                                      std::move(allowed_webui_hosts)));\n  } else if (extension->is_extension() || extension->is_legacy_packaged_app() ||\n             (extension->is_platform_app() &&\n              Manifest::IsComponentLocation(extension->location()))) {\n    // Extensions, legacy packaged apps, and component platform apps are allowed\n    // to use chrome://favicon/ and chrome://extension-icon/ URLs. Hosted apps\n    // are not allowed because they are served via web servers (and are\n    // generally never given access to Chrome APIs).\n    base::flat_set<std::string> allowed_webui_hosts = {\n        chrome::kChromeUIExtensionIconHost, chrome::kChromeUIFaviconHost};\n    factories->emplace(\n        content::kChromeUIScheme,\n        content::CreateWebUIURLLoader(frame_host, content::kChromeUIScheme,\n                                      std::move(allowed_webui_hosts)));\n  }\n\n  // Extension with a background page get file access that gets approval from\n  // ChildProcessSecurityPolicy.\n  extensions::ExtensionHost* host =\n      extensions::ProcessManager::Get(web_contents->GetBrowserContext())\n          ->GetBackgroundHostForExtension(extension->id());\n  if (host) {\n    factories->emplace(url::kFileScheme, std::make_unique<FileURLLoaderFactory>(\n                                             render_process_id));\n  }\n#endif  // BUILDFLAG(ENABLE_EXTENSIONS)\n}\n\nbool ChromeContentBrowserClient::WillCreateURLLoaderFactory(\n    content::BrowserContext* browser_context,\n    content::RenderFrameHost* frame,\n    bool is_navigation,\n    network::mojom::URLLoaderFactoryRequest* factory_request) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  auto* web_request_api =\n      extensions::BrowserContextKeyedAPIFactory<extensions::WebRequestAPI>::Get(\n          browser_context);\n\n  // NOTE: Some unit test environments do not initialize\n  // BrowserContextKeyedAPI factories for e.g. WebRequest.\n  if (!web_request_api)\n    return false;\n\n  return web_request_api->MaybeProxyURLLoaderFactory(frame, is_navigation,\n                                                     factory_request);\n#else\n  return false;\n#endif\n}\n\nstd::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>>\nChromeContentBrowserClient::WillCreateURLLoaderRequestInterceptors(\n    content::NavigationUIData* navigation_ui_data,\n    int frame_tree_node_id) {\n  std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>>\n      interceptors;\n#if BUILDFLAG(ENABLE_OFFLINE_PAGES)\n  interceptors.push_back(\n      std::make_unique<offline_pages::OfflinePageURLLoaderRequestInterceptor>(\n          navigation_ui_data, frame_tree_node_id));\n#endif\n  return interceptors;\n}\n\nvoid ChromeContentBrowserClient::WillCreateWebSocket(\n    content::RenderFrameHost* frame,\n    network::mojom::WebSocketRequest* request,\n    network::mojom::AuthenticationHandlerPtr* auth_handler) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  auto* web_request_api =\n      extensions::BrowserContextKeyedAPIFactory<extensions::WebRequestAPI>::Get(\n          frame->GetProcess()->GetBrowserContext());\n\n  // NOTE: Some unit test environments do not initialize\n  // BrowserContextKeyedAPI factories for e.g. WebRequest.\n  if (!web_request_api)\n    return;\n\n  web_request_api->MaybeProxyWebSocket(frame, request, auth_handler);\n#endif\n}\n\nvoid ChromeContentBrowserClient::OnNetworkServiceCreated(\n    network::mojom::NetworkService* network_service) {\n  // Need to set up global NetworkService state before anything else uses it.\n  g_browser_process->system_network_context_manager()->OnNetworkServiceCreated(\n      network_service);\n}\n\nnetwork::mojom::NetworkContextPtr\nChromeContentBrowserClient::CreateNetworkContext(\n    content::BrowserContext* context,\n    bool in_memory,\n    const base::FilePath& relative_partition_path) {\n  Profile* profile = Profile::FromBrowserContext(context);\n  // If the relative partition path is empty, this is creating the Profile's\n  // main NetworkContext.\n  if (relative_partition_path.empty()) {\n    // TODO(mmenke): Look into calling ProfileNetworkContextServiceFactory, once\n    // ProfileIOData is removed. Currently, TestProfile (used in unit tests)\n    // needs to be able to bypass ProfileNetworkContextServiceFactory, since\n    // TestProfile bypasses ProfileIOData's URLRequestContext creation logic.\n    return profile->CreateMainNetworkContext();\n  }\n\n  // TODO(mmenke):  Share this with the non-network service code path once\n  // ProfileNetworkContextServiceFactory can create a fully functional\n  // NetworkContext for Apps when the network service is disabled.\n  if (base::FeatureList::IsEnabled(network::features::kNetworkService)) {\n    return ProfileNetworkContextServiceFactory::GetForContext(context)\n        ->CreateNetworkContextForPartition(in_memory, relative_partition_path);\n  }\n\n  return ContentBrowserClient::CreateNetworkContext(context, in_memory,\n                                                    relative_partition_path);\n}\n\nbool ChromeContentBrowserClient::AllowRenderingMhtmlOverHttp(\n    content::NavigationUIData* navigation_ui_data) {\n#if BUILDFLAG(ENABLE_OFFLINE_PAGES)\n  // It is OK to load the saved offline copy, in MHTML format.\n  ChromeNavigationUIData* chrome_navigation_ui_data =\n      static_cast<ChromeNavigationUIData*>(navigation_ui_data);\n  if (!chrome_navigation_ui_data)\n    return false;\n  offline_pages::OfflinePageNavigationUIData* offline_page_data =\n      chrome_navigation_ui_data->GetOfflinePageNavigationUIData();\n  return offline_page_data && offline_page_data->is_offline_page();\n#else\n  return false;\n#endif\n}\n\nbool ChromeContentBrowserClient::ShouldForceDownloadResource(\n    const GURL& url,\n    const std::string& mime_type) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // Special-case user scripts to get downloaded instead of viewed.\n  return extensions::UserScript::IsURLUserScript(url, mime_type);\n#else\n  return false;\n#endif\n}\n\nvoid ChromeContentBrowserClient::CreateUsbDeviceManager(\n    content::RenderFrameHost* render_frame_host,\n    device::mojom::UsbDeviceManagerRequest request) {\n  if (!base::FeatureList::IsEnabled(features::kWebUsb))\n    return;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // WebUSB is not supported in Apps/Extensions. https://crbug.com/770896\n  if (render_frame_host->GetSiteInstance()->GetSiteURL().SchemeIs(\n          extensions::kExtensionScheme)) {\n    return;\n  }\n#endif\n\n  WebContents* web_contents =\n      WebContents::FromRenderFrameHost(render_frame_host);\n  if (!web_contents) {\n    NOTREACHED();\n    return;\n  }\n\n  UsbTabHelper* tab_helper =\n      UsbTabHelper::GetOrCreateForWebContents(web_contents);\n  tab_helper->CreateDeviceManager(render_frame_host, std::move(request));\n}\n\nvoid ChromeContentBrowserClient::CreateUsbChooserService(\n    content::RenderFrameHost* render_frame_host,\n    device::mojom::UsbChooserServiceRequest request) {\n  if (!base::FeatureList::IsEnabled(features::kWebUsb))\n    return;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // WebUSB is not supported in Apps/Extensions. https://crbug.com/770896\n  if (render_frame_host->GetSiteInstance()->GetSiteURL().SchemeIs(\n          extensions::kExtensionScheme)) {\n    return;\n  }\n#endif\n\n  WebContents* web_contents =\n      WebContents::FromRenderFrameHost(render_frame_host);\n  if (!web_contents) {\n    NOTREACHED();\n    return;\n  }\n\n  UsbTabHelper* tab_helper =\n      UsbTabHelper::GetOrCreateForWebContents(web_contents);\n  tab_helper->CreateChooserService(render_frame_host, std::move(request));\n}\n\nstd::unique_ptr<content::AuthenticatorRequestClientDelegate>\nChromeContentBrowserClient::GetWebAuthenticationRequestDelegate(\n    content::RenderFrameHost* render_frame_host) {\n  return AuthenticatorRequestScheduler::CreateRequestDelegate(\n      render_frame_host);\n}\n\nstd::unique_ptr<net::ClientCertStore>\nChromeContentBrowserClient::CreateClientCertStore(\n    content::ResourceContext* resource_context) {\n  if (!resource_context)\n    return nullptr;\n  return ProfileIOData::FromResourceContext(resource_context)\n      ->CreateClientCertStore();\n}\n\nscoped_refptr<content::LoginDelegate>\nChromeContentBrowserClient::CreateLoginDelegate(\n    net::AuthChallengeInfo* auth_info,\n    content::ResourceRequestInfo::WebContentsGetter web_contents_getter,\n    const content::GlobalRequestID& request_id,\n    bool is_request_for_main_frame,\n    const GURL& url,\n    scoped_refptr<net::HttpResponseHeaders> response_headers,\n    bool first_auth_attempt,\n    LoginAuthRequiredCallback auth_required_callback) {\n  return CreateLoginPrompt(\n      auth_info, web_contents_getter, request_id, is_request_for_main_frame,\n      url, std::move(response_headers), std::move(auth_required_callback));\n}\n\nbool ChromeContentBrowserClient::HandleExternalProtocol(\n    const GURL& url,\n    content::ResourceRequestInfo::WebContentsGetter web_contents_getter,\n    int child_id,\n    content::NavigationUIData* navigation_data,\n    bool is_main_frame,\n    ui::PageTransition page_transition,\n    bool has_user_gesture) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  // External protocols are disabled for guests. An exception is made for the\n  // \"mailto\" protocol, so that pages that utilize it work properly in a\n  // WebView.\n  ChromeNavigationUIData* chrome_data =\n      static_cast<ChromeNavigationUIData*>(navigation_data);\n  if ((extensions::WebViewRendererState::GetInstance()->IsGuest(child_id) ||\n       (chrome_data &&\n        chrome_data->GetExtensionNavigationUIData()->is_web_view())) &&\n      !url.SchemeIs(url::kMailToScheme)) {\n    return false;\n  }\n#endif  // BUILDFLAG(ENABLE_EXTENSIONS)\n\n#if defined(OS_ANDROID)\n  // Main frame external protocols are handled by\n  // InterceptNavigationResourceThrottle.\n  if (is_main_frame)\n    return false;\n#endif  // defined(ANDROID)\n\n  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                          base::BindOnce(&LaunchURL, url, web_contents_getter,\n                                         page_transition, has_user_gesture));\n  return true;\n}\n\nstd::unique_ptr<content::OverlayWindow>\nChromeContentBrowserClient::CreateWindowForPictureInPicture(\n    content::PictureInPictureWindowController* controller) {\n#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \\\n    defined(OS_CHROMEOS)\n  // Note: content::OverlayWindow::Create() is defined by platform-specific\n  // implementation in chrome/browser/ui/views. This layering hack, which goes\n  // through //content and ContentBrowserClient, allows us to work around the\n  // dependency constraints that disallow directly calling\n  // chrome/browser/ui/views code either from here or from other code in\n  // chrome/browser.\n  return content::OverlayWindow::Create(controller);\n#else\n  return nullptr;\n#endif\n}\n\n// Static; handles rewriting Web UI URLs.\nbool ChromeContentBrowserClient::HandleWebUI(\n    GURL* url,\n    content::BrowserContext* browser_context) {\n  // Rewrite chrome://help and chrome://chrome to chrome://settings/help.\n  if (url->SchemeIs(content::kChromeUIScheme) &&\n      (url->host() == chrome::kChromeUIHelpHost ||\n       (url->host() == chrome::kChromeUIUberHost &&\n        (url->path().empty() || url->path() == \"/\")))) {\n    *url = ReplaceURLHostAndPath(*url, chrome::kChromeUISettingsHost,\n                                 chrome::kChromeUIHelpHost);\n    return true;  // Return true to update the displayed URL.\n  }\n\n  if (!ChromeWebUIControllerFactory::GetInstance()->UseWebUIForURL(\n          browser_context, *url)) {\n    return false;\n  }\n\n#if defined(OS_CHROMEOS)\n  // Special case : in ChromeOS in Guest mode bookmarks and history are\n  // disabled for security reasons. New tab page explains the reasons, so\n  // we redirect user to new tab page.\n  if (user_manager::UserManager::Get()->IsLoggedInAsGuest()) {\n    if (url->SchemeIs(content::kChromeUIScheme) &&\n        (url->DomainIs(chrome::kChromeUIBookmarksHost) ||\n         url->DomainIs(chrome::kChromeUIHistoryHost))) {\n      // Rewrite with new tab URL\n      *url = GURL(chrome::kChromeUINewTabURL);\n    }\n  }\n#endif\n\n  return true;\n}\n\nbool ChromeContentBrowserClient::ShowPaymentHandlerWindow(\n    content::BrowserContext* browser_context,\n    const GURL& url,\n    base::OnceCallback<void(bool, int, int)> callback) {\n#if defined(OS_ANDROID)\n  return false;\n#else\n  payments::PaymentRequestDisplayManagerFactory::GetInstance()\n      ->GetForBrowserContext(browser_context)\n      ->ShowPaymentHandlerWindow(url, std::move(callback));\n  return true;\n#endif\n}\n\n// Static; reverse URL handler for Web UI. Maps \"chrome://chrome/foo/\" to\n// \"chrome://foo/\".\nbool ChromeContentBrowserClient::HandleWebUIReverse(\n    GURL* url,\n    content::BrowserContext* browser_context) {\n  // No need to actually reverse-rewrite the URL, but return true to update the\n  // displayed URL when rewriting chrome://help to chrome://settings/help.\n  return url->SchemeIs(content::kChromeUIScheme) &&\n         url->host() == chrome::kChromeUISettingsHost;\n}\n\n// static\nvoid ChromeContentBrowserClient::SetDefaultQuotaSettingsForTesting(\n    const storage::QuotaSettings* settings) {\n  g_default_quota_settings = settings;\n}\n\nsafe_browsing::UrlCheckerDelegate*\nChromeContentBrowserClient::GetSafeBrowsingUrlCheckerDelegate(\n    content::ResourceContext* resource_context) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(resource_context);\n  if (!io_data->safe_browsing_enabled()->GetValue())\n    return nullptr;\n\n  // |safe_browsing_service_| may be unavailable in tests.\n  if (safe_browsing_service_ && !safe_browsing_url_checker_delegate_) {\n    safe_browsing_url_checker_delegate_ =\n        base::MakeRefCounted<safe_browsing::UrlCheckerDelegateImpl>(\n            safe_browsing_service_->database_manager(),\n            safe_browsing_service_->ui_manager());\n  }\n\n  return safe_browsing_url_checker_delegate_.get();\n}\n"
        }, 
        "generated": false, 
        "mime_type": "text/plain", 
        "size": "181552", 
        "type": 1, 
        "md5": "e765f21cbbb22098ae82b1149754307f", 
        "codeblock": [
          {
            "child": [
              {
                "name_prefix": "", 
                "type": 9, 
                "name": "g_io_thread_application_locale", 
                "text_range": {
                  "start_line": 518, 
                  "end_line": 519, 
                  "start_column": 1, 
                  "end_column": 64
                }, 
                "signature": ""
              }, 
              {
                "name_prefix": "", 
                "type": 9, 
                "name": "g_default_quota_settings", 
                "text_range": {
                  "start_line": 521, 
                  "end_line": 521, 
                  "start_column": 1, 
                  "end_column": 56
                }, 
                "signature": ""
              }, 
              {
                "name_prefix": "", 
                "type": 9, 
                "name": "kPredefinedAllowedDevChannelOrigins", 
                "text_range": {
                  "start_line": 527, 
                  "end_line": 530, 
                  "start_column": 1, 
                  "end_column": 3
                }, 
                "signature": ""
              }, 
              {
                "name_prefix": "", 
                "type": 9, 
                "name": "kPredefinedAllowedFileHandleOrigins", 
                "text_range": {
                  "start_line": 532, 
                  "end_line": 535, 
                  "start_column": 1, 
                  "end_column": 3
                }, 
                "signature": ""
              }, 
              {
                "name_prefix": "", 
                "type": 9, 
                "name": "kPredefinedAllowedSocketOrigins", 
                "text_range": {
                  "start_line": 537, 
                  "end_line": 560, 
                  "start_column": 1, 
                  "end_column": 3
                }, 
                "signature": ""
              }, 
              {
                "name": "AppLoadedInTabSource", 
                "signature": "", 
                "child": [
                  {
                    "name_prefix": "", 
                    "type": 14, 
                    "name": "APP_LOADED_IN_TAB_SOURCE_APP", 
                    "text_range": {
                      "start_line": 565, 
                      "end_line": 565, 
                      "start_column": 3, 
                      "end_column": 35
                    }, 
                    "signature": ""
                  }, 
                  {
                    "name_prefix": "", 
                    "type": 14, 
                    "name": "APP_LOADED_IN_TAB_SOURCE_BACKGROUND_PAGE", 
                    "text_range": {
                      "start_line": 568, 
                      "end_line": 568, 
                      "start_column": 3, 
                      "end_column": 43
                    }, 
                    "signature": ""
                  }, 
                  {
                    "name_prefix": "", 
                    "type": 14, 
                    "name": "APP_LOADED_IN_TAB_SOURCE_OTHER_EXTENSION", 
                    "text_range": {
                      "start_line": 572, 
                      "end_line": 572, 
                      "start_column": 3, 
                      "end_column": 43
                    }, 
                    "signature": ""
                  }, 
                  {
                    "name_prefix": "", 
                    "type": 14, 
                    "name": "APP_LOADED_IN_TAB_SOURCE_OTHER", 
                    "text_range": {
                      "start_line": 575, 
                      "end_line": 575, 
                      "start_column": 3, 
                      "end_column": 33
                    }, 
                    "signature": ""
                  }, 
                  {
                    "name_prefix": "", 
                    "type": 14, 
                    "name": "APP_LOADED_IN_TAB_SOURCE_MAX", 
                    "text_range": {
                      "start_line": 577, 
                      "end_line": 577, 
                      "start_column": 3, 
                      "end_column": 31
                    }, 
                    "signature": ""
                  }
                ], 
                "name_prefix": "", 
                "type": 4, 
                "text_range": {
                  "start_line": 563, 
                  "end_line": 578, 
                  "start_column": 1, 
                  "end_column": 2
                }
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "ReplaceURLHostAndPath", 
                "text_range": {
                  "start_line": 582, 
                  "end_line": 589, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const GURL& url, const std::string& host, const std::string& path)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "HandleNewTabPageLocationOverride", 
                "text_range": {
                  "start_line": 592, 
                  "end_line": 607, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(GURL* url, content::BrowserContext* browser_context)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "CertMatchesFilter", 
                "text_range": {
                  "start_line": 609, 
                  "end_line": 625, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const net::X509Certificate& cert, const base::DictionaryValue& filter)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "IsURLWhitelisted", 
                "text_range": {
                  "start_line": 629, 
                  "end_line": 645, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const GURL& current_url, const base::Value::ListStorage& whitelisted_urls)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "IsAutoplayAllowedByPolicy", 
                "text_range": {
                  "start_line": 648, 
                  "end_line": 667, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(content::WebContents* contents, PrefService* prefs)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "CreateCrashHandlerHost", 
                "text_range": {
                  "start_line": 671, 
                  "end_line": 683, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const std::string& process_type)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "GetCrashSignalFD", 
                "text_range": {
                  "start_line": 685, 
                  "end_line": 744, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const base::CommandLine& command_line)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "SetApplicationLocaleOnIOThread", 
                "text_range": {
                  "start_line": 747, 
                  "end_line": 750, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const std::string& locale)"
              }, 
              {
                "name": "CertificateReportingServiceCertReporter", 
                "signature": "", 
                "child": [
                  {
                    "modifiers": {
                      "public": true
                    }, 
                    "name": "CertificateReportingServiceCertReporter", 
                    "signature": "(content::WebContents* web_contents)", 
                    "name_prefix": "", 
                    "type": 8, 
                    "text_range": {
                      "start_line": 758, 
                      "end_line": 761, 
                      "start_column": 3, 
                      "end_column": 51
                    }
                  }, 
                  {
                    "modifiers": {
                      "public": true
                    }, 
                    "name": "~CertificateReportingServiceCertReporter", 
                    "signature": "()", 
                    "name_prefix": "", 
                    "type": 8, 
                    "text_range": {
                      "start_line": 762, 
                      "end_line": 762, 
                      "start_column": 3, 
                      "end_column": 57
                    }
                  }, 
                  {
                    "modifiers": {
                      "public": true
                    }, 
                    "name": "ReportInvalidCertificateChain", 
                    "signature": "(const std::string& serialized_report)", 
                    "name_prefix": "", 
                    "type": 8, 
                    "text_range": {
                      "start_line": 765, 
                      "end_line": 768, 
                      "start_column": 3, 
                      "end_column": 4
                    }
                  }, 
                  {
                    "modifiers": {
                      "private": true
                    }, 
                    "name": "service_", 
                    "signature": "", 
                    "name_prefix": "", 
                    "type": 9, 
                    "text_range": {
                      "start_line": 771, 
                      "end_line": 771, 
                      "start_column": 3, 
                      "end_column": 41
                    }
                  }
                ], 
                "name_prefix": "", 
                "type": 1, 
                "text_range": {
                  "start_line": 756, 
                  "end_line": 774, 
                  "start_column": 1, 
                  "end_column": 2
                }
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "GetDeviceScaleAdjustment", 
                "text_range": {
                  "start_line": 777, 
                  "end_line": 794, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "GetGuestViewDefaultContentSettingRules", 
                "text_range": {
                  "start_line": 800, 
                  "end_line": 824, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(bool incognito, RendererContentSettingRules* rules)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "ClassifyAppLoadedInTabSource", 
                "text_range": {
                  "start_line": 826, 
                  "end_line": 846, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const GURL& opener_url, const extensions::Extension* target_platform_app)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "CreateBudgetService", 
                "text_range": {
                  "start_line": 849, 
                  "end_line": 853, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(blink::mojom::BudgetServiceRequest request, content::RenderFrameHost* render_frame_host)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "GetDataSaverEnabledPref", 
                "text_range": {
                  "start_line": 855, 
                  "end_line": 861, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const PrefService* prefs)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "GetWebContents", 
                "text_range": {
                  "start_line": 863, 
                  "end_line": 867, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(int render_process_id, int render_frame_id)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "URLHasExtensionBackgroundPermission", 
                "text_range": {
                  "start_line": 875, 
                  "end_line": 887, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(extensions::ProcessMap* process_map, extensions::ExtensionRegistry* registry, const GURL& url, int opener_render_process_id)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "InvokeCallbackOnThread", 
                "text_range": {
                  "start_line": 889, 
                  "end_line": 894, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(scoped_refptr<base::SequencedTaskRunner> task_runner, base::Callback<void(bool)> callback, bool result)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "GetSystemRequestContextOnUIThread", 
                "text_range": {
                  "start_line": 899, 
                  "end_line": 904, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "GetPrerenderCanceller", 
                "text_range": {
                  "start_line": 906, 
                  "end_line": 914, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const base::Callback<content::WebContents*()>& wc_getter)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "LaunchURL", 
                "text_range": {
                  "start_line": 916, 
                  "end_line": 959, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const GURL& url, const content::ResourceRequestInfo::WebContentsGetter& web_contents_getter, ui::PageTransition page_transition, bool has_user_gesture)"
              }
            ], 
            "type": 11, 
            "name": "", 
            "text_range": {
              "start_line": 514, 
              "end_line": 961, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": ""
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ChromeContentBrowserClient", 
            "text_range": {
              "start_line": 963, 
              "end_line": 995, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(std::unique_ptr<ui::DataPack> data_pack)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "~ChromeContentBrowserClient", 
            "text_range": {
              "start_line": 997, 
              "end_line": 1001, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RegisterLocalStatePrefs", 
            "text_range": {
              "start_line": 1004, 
              "end_line": 1010, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(PrefRegistrySimple* registry)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RegisterProfilePrefs", 
            "text_range": {
              "start_line": 1013, 
              "end_line": 1027, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(user_prefs::PrefRegistrySyncable* registry)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "SetApplicationLocale", 
            "text_range": {
              "start_line": 1030, 
              "end_line": 1047, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const std::string& locale)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateBrowserMainParts", 
            "text_range": {
              "start_line": 1049, 
              "end_line": 1107, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const content::MainFunctionParams& parameters)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "PostAfterStartupTask", 
            "text_range": {
              "start_line": 1109, 
              "end_line": 1114, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const base::Location& from_here, const scoped_refptr<base::TaskRunner>& task_runner, base::OnceClosure task)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsBrowserStartupComplete", 
            "text_range": {
              "start_line": 1116, 
              "end_line": 1118, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "SetBrowserStartupIsCompleteForTesting", 
            "text_range": {
              "start_line": 1120, 
              "end_line": 1122, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetStoragePartitionIdForSite", 
            "text_range": {
              "start_line": 1124, 
              "end_line": 1143, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& site)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsValidStoragePartitionId", 
            "text_range": {
              "start_line": 1145, 
              "end_line": 1153, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const std::string& partition_id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetStoragePartitionConfigForSite", 
            "text_range": {
              "start_line": 1155, 
              "end_line": 1203, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& site, bool can_be_default, std::string* partition_domain, std::string* partition_name, bool* in_memory)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetWebContentsViewDelegate", 
            "text_range": {
              "start_line": 1205, 
              "end_line": 1209, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::WebContents* web_contents)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowGpuLaunchRetryOnIOThread", 
            "text_range": {
              "start_line": 1211, 
              "end_line": 1221, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RenderProcessWillLaunch", 
            "text_range": {
              "start_line": 1223, 
              "end_line": 1297, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderProcessHost* host, service_manager::mojom::ServiceRequest* service_request)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetEffectiveURL", 
            "text_range": {
              "start_line": 1299, 
              "end_line": 1321, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldUseProcessPerSite", 
            "text_range": {
              "start_line": 1323, 
              "end_line": 1345, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& effective_url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldUseSpareRenderProcessHost", 
            "text_range": {
              "start_line": 1347, 
              "end_line": 1369, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& site_url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "DoesSiteRequireDedicatedProcess", 
            "text_range": {
              "start_line": 1371, 
              "end_line": 1381, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& effective_site_url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldLockToOrigin", 
            "text_range": {
              "start_line": 1388, 
              "end_line": 1405, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& effective_site_url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetInitatorSchemeBypassingDocumentBlocking", 
            "text_range": {
              "start_line": 1407, 
              "end_line": 1420, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetAdditionalWebUISchemes", 
            "text_range": {
              "start_line": 1424, 
              "end_line": 1429, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(std::vector<std::string>* additional_schemes)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetAdditionalViewSourceSchemes", 
            "text_range": {
              "start_line": 1431, 
              "end_line": 1438, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(std::vector<std::string>* additional_schemes)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "LogWebUIUrl", 
            "text_range": {
              "start_line": 1440, 
              "end_line": 1442, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& web_ui_url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsHandledURL", 
            "text_range": {
              "start_line": 1444, 
              "end_line": 1446, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CanCommitURL", 
            "text_range": {
              "start_line": 1448, 
              "end_line": 1457, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderProcessHost* process_host, const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldAllowOpenURL", 
            "text_range": {
              "start_line": 1459, 
              "end_line": 1480, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::SiteInstance* site_instance, const GURL& url)"
          }, 
          {
            "child": [
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "IsNTPSiteInstance", 
                "text_range": {
                  "start_line": 1487, 
                  "end_line": 1497, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(SiteInstance* site_instance)"
              }
            ], 
            "type": 11, 
            "name": "", 
            "text_range": {
              "start_line": 1482, 
              "end_line": 1499, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": ""
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "OverrideNavigationParams", 
            "text_range": {
              "start_line": 1501, 
              "end_line": 1524, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(SiteInstance* site_instance, ui::PageTransition* transition, bool* is_renderer_initiated, content::Referrer* referrer)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldFrameShareParentSiteInstanceDespiteTopDocumentIsolation", 
            "text_range": {
              "start_line": 1526, 
              "end_line": 1540, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, content::SiteInstance* parent_site_instance)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldStayInParentProcessForNTP", 
            "text_range": {
              "start_line": 1542, 
              "end_line": 1547, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, SiteInstance* parent_site_instance)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsSuitableHost", 
            "text_range": {
              "start_line": 1549, 
              "end_line": 1580, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderProcessHost* process_host, const GURL& site_url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "MayReuseHost", 
            "text_range": {
              "start_line": 1582, 
              "end_line": 1596, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderProcessHost* process_host)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldTryToUseExistingProcessHost", 
            "text_range": {
              "start_line": 1598, 
              "end_line": 1612, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "SiteInstanceGotProcess", 
            "text_range": {
              "start_line": 1614, 
              "end_line": 1637, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(SiteInstance* site_instance)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "SiteInstanceDeleting", 
            "text_range": {
              "start_line": 1639, 
              "end_line": 1646, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(SiteInstance* site_instance)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldSwapBrowsingInstancesForNavigation", 
            "text_range": {
              "start_line": 1648, 
              "end_line": 1659, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(SiteInstance* site_instance, const GURL& current_url, const GURL& new_url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldIsolateErrorPage", 
            "text_range": {
              "start_line": 1661, 
              "end_line": 1667, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(bool in_main_frame)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldAssignSiteForURL", 
            "text_range": {
              "start_line": 1669, 
              "end_line": 1671, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetOriginsRequiringDedicatedProcess", 
            "text_range": {
              "start_line": 1673, 
              "end_line": 1685, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldEnableStrictSiteIsolation", 
            "text_range": {
              "start_line": 1687, 
              "end_line": 1700, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsFileAccessAllowed", 
            "text_range": {
              "start_line": 1702, 
              "end_line": 1708, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const base::FilePath& path, const base::FilePath& absolute_path, const base::FilePath& profile_path)"
          }, 
          {
            "child": [
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "IsAutoReloadEnabled", 
                "text_range": {
                  "start_line": 1712, 
                  "end_line": 1720, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "IsAutoReloadVisibleOnlyEnabled", 
                "text_range": {
                  "start_line": 1722, 
                  "end_line": 1734, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "()"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "MaybeAppendBlinkSettingsSwitchForFieldTrial", 
                "text_range": {
                  "start_line": 1736, 
                  "end_line": 1790, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(const base::CommandLine& browser_command_line, base::CommandLine* command_line)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "ForwardToJavaFrameRegistry", 
                "text_range": {
                  "start_line": 1794, 
                  "end_line": 1798, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(mojo::InterfaceRequest<Interface> request, content::RenderFrameHost* render_frame_host)"
              }, 
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "ForwardToJavaWebContentsRegistry", 
                "text_range": {
                  "start_line": 1801, 
                  "end_line": 1808, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(mojo::InterfaceRequest<Interface> request, content::RenderFrameHost* render_frame_host)"
              }
            ], 
            "type": 11, 
            "name": "", 
            "text_range": {
              "start_line": 1710, 
              "end_line": 1811, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": ""
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AppendExtraCommandLineSwitches", 
            "text_range": {
              "start_line": 1813, 
              "end_line": 2072, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(base::CommandLine* command_line, int child_process_id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AdjustUtilityServiceProcessCommandLine", 
            "text_range": {
              "start_line": 2074, 
              "end_line": 2110, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const service_manager::Identity& identity, base::CommandLine* command_line)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetApplicationLocale", 
            "text_range": {
              "start_line": 2112, 
              "end_line": 2116, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetAcceptLangs", 
            "text_range": {
              "start_line": 2118, 
              "end_line": 2122, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetDefaultFavicon", 
            "text_range": {
              "start_line": 2124, 
              "end_line": 2127, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsDataSaverEnabled", 
            "text_range": {
              "start_line": 2129, 
              "end_line": 2136, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "NavigationRequestStarted", 
            "text_range": {
              "start_line": 2138, 
              "end_line": 2154, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(int frame_tree_node_id, const GURL& url, std::unique_ptr<net::HttpRequestHeaders>* extra_headers, int* extra_load_flags)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowAppCache", 
            "text_range": {
              "start_line": 2156, 
              "end_line": 2164, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& manifest_url, const GURL& first_party, content::ResourceContext* context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowServiceWorker", 
            "text_range": {
              "start_line": 2166, 
              "end_line": 2211, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& scope, const GURL& first_party_url, content::ResourceContext* context, const base::Callback<content::WebContents*(void)>& wc_getter)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowSharedWorker", 
            "text_range": {
              "start_line": 2213, 
              "end_line": 2232, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& worker_url, const GURL& main_frame_url, const std::string& name, const url::Origin& constructor_origin, content::BrowserContext* context, int render_process_id, int render_frame_id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowGetCookie", 
            "text_range": {
              "start_line": 2234, 
              "end_line": 2253, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, const GURL& first_party, const net::CookieList& cookie_list, content::ResourceContext* context, int render_process_id, int render_frame_id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowSetCookie", 
            "text_range": {
              "start_line": 2255, 
              "end_line": 2276, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, const GURL& first_party, const net::CanonicalCookie& cookie, content::ResourceContext* context, int render_process_id, int render_frame_id, const net::CookieOptions& options)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowWorkerFileSystem", 
            "text_range": {
              "start_line": 2278, 
              "end_line": 2294, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, content::ResourceContext* context, const std::vector<std::pair<int, int> >& render_frames, base::Callback<void(bool)> callback)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GuestPermissionRequestHelper", 
            "text_range": {
              "start_line": 2297, 
              "end_line": 2333, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, const std::vector<std::pair<int, int> >& render_frames, base::Callback<void(bool)> callback, bool allow)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RequestFileSystemPermissionOnUIThread", 
            "text_range": {
              "start_line": 2335, 
              "end_line": 2348, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(int render_process_id, int render_frame_id, const GURL& url, bool allowed_by_default, const base::Callback<void(bool)>& callback)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "FileSystemAccessed", 
            "text_range": {
              "start_line": 2351, 
              "end_line": 2365, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, const std::vector<std::pair<int, int> >& render_frames, base::Callback<void(bool)> callback, bool allow)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowWorkerIndexedDB", 
            "text_range": {
              "start_line": 2367, 
              "end_line": 2388, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, const base::string16& name, content::ResourceContext* context, const std::vector<std::pair<int, int> >& render_frames)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowWebBluetooth", 
            "text_range": {
              "start_line": 2390, 
              "end_line": 2417, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const url::Origin& requesting_origin, const url::Origin& embedding_origin)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetWebBluetoothBlocklist", 
            "text_range": {
              "start_line": 2419, 
              "end_line": 2422, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "OverrideRequestContextForURL", 
            "text_range": {
              "start_line": 2424, 
              "end_line": 2436, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, content::ResourceContext* context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetGeolocationRequestContext", 
            "text_range": {
              "start_line": 2438, 
              "end_line": 2444, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(base::OnceCallback<void(scoped_refptr<net::URLRequestContextGetter>)> callback)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetGeolocationApiKey", 
            "text_range": {
              "start_line": 2446, 
              "end_line": 2448, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldUseGmsCoreGeolocationProvider", 
            "text_range": {
              "start_line": 2451, 
              "end_line": 2454, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateQuotaPermissionContext", 
            "text_range": {
              "start_line": 2457, 
              "end_line": 2460, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetQuotaSettings", 
            "text_range": {
              "start_line": 2462, 
              "end_line": 2473, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* context, content::StoragePartition* partition, storage::OptionalQuotaSettingsCallback callback)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowCertificateError", 
            "text_range": {
              "start_line": 2475, 
              "end_line": 2525, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::WebContents* web_contents, int cert_error, const net::SSLInfo& ssl_info, const GURL& request_url, ResourceType resource_type, bool strict_enforcement, bool expired_previous_decision, const base::Callback<void(content::CertificateRequestResultType)>& callback)"
          }, 
          {
            "child": [
              {
                "name_prefix": "", 
                "type": 8, 
                "name": "AutoSelectCertificate", 
                "text_range": {
                  "start_line": 2532, 
                  "end_line": 2579, 
                  "start_column": 1, 
                  "end_column": 2
                }, 
                "signature": "(Profile* profile, const GURL& requesting_url, net::ClientCertIdentityList& client_certs)"
              }
            ], 
            "type": 11, 
            "name": "", 
            "text_range": {
              "start_line": 2527, 
              "end_line": 2581, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": ""
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "SelectClientCertificate", 
            "text_range": {
              "start_line": 2583, 
              "end_line": 2661, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::WebContents* web_contents, net::SSLCertRequestInfo* cert_request_info, net::ClientCertIdentityList client_certs, std::unique_ptr<content::ClientCertificateDelegate> delegate)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetMediaObserver", 
            "text_range": {
              "start_line": 2663, 
              "end_line": 2665, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetPlatformNotificationService", 
            "text_range": {
              "start_line": 2667, 
              "end_line": 2670, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CanCreateWindow", 
            "text_range": {
              "start_line": 2672, 
              "end_line": 2788, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(RenderFrameHost* opener, const GURL& opener_url, const GURL& opener_top_level_frame_url, const GURL& source_origin, content::mojom::WindowContainerType container_type, const GURL& target_url, const content::Referrer& referrer, const std::string& frame_name, WindowOpenDisposition disposition, const blink::mojom::WindowFeatures& features, bool user_gesture, bool opener_suppressed, bool* no_javascript_access)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ResourceDispatcherHostCreated", 
            "text_range": {
              "start_line": 2790, 
              "end_line": 2799, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateSpeechRecognitionManagerDelegate", 
            "text_range": {
              "start_line": 2801, 
              "end_line": 2804, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetNetLog", 
            "text_range": {
              "start_line": 2806, 
              "end_line": 2808, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "OverrideWebkitPrefs", 
            "text_range": {
              "start_line": 2810, 
              "end_line": 3038, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(RenderViewHost* rvh, WebPreferences* web_prefs)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "BrowserURLHandlerCreated", 
            "text_range": {
              "start_line": 3040, 
              "end_line": 3070, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(BrowserURLHandler* handler)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetDefaultDownloadDirectory", 
            "text_range": {
              "start_line": 3072, 
              "end_line": 3074, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetDefaultDownloadName", 
            "text_range": {
              "start_line": 3076, 
              "end_line": 3078, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetShaderDiskCacheDirectory", 
            "text_range": {
              "start_line": 3080, 
              "end_line": 3085, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "DidCreatePpapiPlugin", 
            "text_range": {
              "start_line": 3087, 
              "end_line": 3092, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserPpapiHost* browser_host)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetExternalBrowserPpapiHost", 
            "text_range": {
              "start_line": 3094, 
              "end_line": 3111, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(int plugin_process_id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowPepperSocketAPI", 
            "text_range": {
              "start_line": 3113, 
              "end_line": 3124, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& url, bool private_api, const content::SocketPermissionRequest* params)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsPepperVpnProviderAPIAllowed", 
            "text_range": {
              "start_line": 3126, 
              "end_line": 3135, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetVpnServiceProxy", 
            "text_range": {
              "start_line": 3137, 
              "end_line": 3146, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateSelectFilePolicy", 
            "text_range": {
              "start_line": 3148, 
              "end_line": 3151, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(WebContents* web_contents)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetAdditionalAllowedSchemesForFileSystem", 
            "text_range": {
              "start_line": 3153, 
              "end_line": 3163, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(std::vector<std::string>* additional_allowed_schemes)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetSchemesBypassingSecureContextCheckWhitelist", 
            "text_range": {
              "start_line": 3165, 
              "end_line": 3168, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(std::set<std::string>* schemes)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetURLRequestAutoMountHandlers", 
            "text_range": {
              "start_line": 3170, 
              "end_line": 3174, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(std::vector<storage::URLRequestAutoMountHandler>* handlers)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetRapporService", 
            "text_range": {
              "start_line": 3176, 
              "end_line": 3178, 
              "start_column": 3, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetAdditionalFileSystemBackends", 
            "text_range": {
              "start_line": 3180, 
              "end_line": 3206, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const base::FilePath& storage_partition_path, std::vector<std::unique_ptr<storage::FileSystemBackend>>* additional_backends)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetAdditionalMappedFilesForChildProcess", 
            "text_range": {
              "start_line": 3209, 
              "end_line": 3243, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const base::CommandLine& command_line, int child_process_id, PosixFileDescriptorInfo* mappings)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetAppContainerSidForSandboxType", 
            "text_range": {
              "start_line": 3247, 
              "end_line": 3292, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(int sandbox_type)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "PreSpawnRenderer", 
            "text_range": {
              "start_line": 3294, 
              "end_line": 3307, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(sandbox::TargetPolicy* policy)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ExposeInterfacesToRenderer", 
            "text_range": {
              "start_line": 3310, 
              "end_line": 3393, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(service_manager::BinderRegistry* registry, blink::AssociatedInterfaceRegistry* associated_registry, content::RenderProcessHost* render_process_host)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ExposeInterfacesToMediaService", 
            "text_range": {
              "start_line": 3395, 
              "end_line": 3408, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(service_manager::BinderRegistry* registry, content::RenderFrameHost* render_frame_host)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "BindInterfaceRequestFromFrame", 
            "text_range": {
              "start_line": 3410, 
              "end_line": 3423, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderFrameHost* render_frame_host, const std::string& interface_name, mojo::ScopedMessagePipeHandle interface_pipe)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "BindInterfaceRequestFromWorker", 
            "text_range": {
              "start_line": 3425, 
              "end_line": 3437, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderProcessHost* render_process_host, const url::Origin& origin, const std::string& interface_name, mojo::ScopedMessagePipeHandle interface_pipe)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "BindInterfaceRequest", 
            "text_range": {
              "start_line": 3439, 
              "end_line": 3445, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const service_manager::BindSourceInfo& source_info, const std::string& interface_name, mojo::ScopedMessagePipeHandle* interface_pipe)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RegisterInProcessServices", 
            "text_range": {
              "start_line": 3447, 
              "end_line": 3483, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(StaticServiceMap* services, content::ServiceManagerConnection* connection)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RegisterOutOfProcessServices", 
            "text_range": {
              "start_line": 3485, 
              "end_line": 3544, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(OutOfProcessServiceMap* services)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldTerminateOnServiceQuit", 
            "text_range": {
              "start_line": 3546, 
              "end_line": 3552, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const service_manager::Identity& id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetServiceManifestOverlay", 
            "text_range": {
              "start_line": 3554, 
              "end_line": 3576, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(base::StringPiece name)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetExtraServiceManifests", 
            "text_range": {
              "start_line": 3578, 
              "end_line": 3593, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "OpenURL", 
            "text_range": {
              "start_line": 3595, 
              "end_line": 3613, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const content::OpenURLParams& params, const base::Callback<void(content::WebContents*)>& callback)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetControllerPresentationServiceDelegate", 
            "text_range": {
              "start_line": 3615, 
              "end_line": 3623, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::WebContents* web_contents)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetReceiverPresentationServiceDelegate", 
            "text_range": {
              "start_line": 3625, 
              "end_line": 3639, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::WebContents* web_contents)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RecordURLMetric", 
            "text_range": {
              "start_line": 3641, 
              "end_line": 3647, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const std::string& metric, const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetMetricSuffixForURL", 
            "text_range": {
              "start_line": 3649, 
              "end_line": 3660, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateThrottlesForNavigation", 
            "text_range": {
              "start_line": 3662, 
              "end_line": 3826, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::NavigationHandle* handle)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetNavigationUIData", 
            "text_range": {
              "start_line": 3828, 
              "end_line": 3832, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::NavigationHandle* navigation_handle)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetDevToolsManagerDelegate", 
            "text_range": {
              "start_line": 3834, 
              "end_line": 3841, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetTracingDelegate", 
            "text_range": {
              "start_line": 3843, 
              "end_line": 3845, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsPluginAllowedToCallRequestOSFileHandle", 
            "text_range": {
              "start_line": 3847, 
              "end_line": 3857, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "IsPluginAllowedToUseDevChannelAPIs", 
            "text_range": {
              "start_line": 3859, 
              "end_line": 3869, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& url)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "OverridePageVisibilityState", 
            "text_range": {
              "start_line": 3871, 
              "end_line": 3887, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(RenderFrameHost* render_frame_host, blink::mojom::PageVisibilityState* visibility_state)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "InitWebContextInterfaces", 
            "text_range": {
              "start_line": 3889, 
              "end_line": 3938, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "MaybeCopyDisableWebRtcEncryptionSwitch", 
            "text_range": {
              "start_line": 3940, 
              "end_line": 3959, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(base::CommandLine* to_command_line, const base::CommandLine& from_command_line, version_info::Channel channel)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetMemoryCoordinatorDelegate", 
            "text_range": {
              "start_line": 3961, 
              "end_line": 3964, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateMediaRemoter", 
            "text_range": {
              "start_line": 3967, 
              "end_line": 3973, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderFrameHost* render_frame_host, media::mojom::RemotingSourcePtr source, media::mojom::RemoterRequest request)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetTaskSchedulerInitParams", 
            "text_range": {
              "start_line": 3976, 
              "end_line": 3979, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "()"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetLoggingFileName", 
            "text_range": {
              "start_line": 3981, 
              "end_line": 3984, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const base::CommandLine& command_line)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateURLLoaderThrottles", 
            "text_range": {
              "start_line": 3986, 
              "end_line": 4059, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const network::ResourceRequest& request, content::ResourceContext* resource_context, const base::RepeatingCallback<content::WebContents*()>& wc_getter, content::NavigationUIData* navigation_ui_data, int frame_tree_node_id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RegisterNonNetworkNavigationURLLoaderFactories", 
            "text_range": {
              "start_line": 4061, 
              "end_line": 4073, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(int frame_tree_node_id, NonNetworkURLLoaderFactoryMap* factories)"
          }, 
          {
            "child": [
              {
                "name": "FileURLLoaderFactory", 
                "signature": "", 
                "child": [
                  {
                    "modifiers": {
                      "public": true
                    }, 
                    "name": "FileURLLoaderFactory", 
                    "signature": "(int child_id)", 
                    "name_prefix": "", 
                    "type": 8, 
                    "text_range": {
                      "start_line": 4081, 
                      "end_line": 4081, 
                      "start_column": 3, 
                      "end_column": 71
                    }
                  }, 
                  {
                    "modifiers": {
                      "private": true
                    }, 
                    "name": "CreateLoaderAndStart", 
                    "signature": "(network::mojom::URLLoaderRequest loader, int32_t routing_id, int32_t request_id, uint32_t options, const network::ResourceRequest& request, network::mojom::URLLoaderClientPtr client, const net::MutableNetworkTrafficAnnotationTag& traffic_annotation)", 
                    "name_prefix": "", 
                    "type": 8, 
                    "text_range": {
                      "start_line": 4085, 
                      "end_line": 4101, 
                      "start_column": 3, 
                      "end_column": 4
                    }
                  }, 
                  {
                    "modifiers": {
                      "private": true
                    }, 
                    "name": "Clone", 
                    "signature": "(network::mojom::URLLoaderFactoryRequest loader)", 
                    "name_prefix": "", 
                    "type": 8, 
                    "text_range": {
                      "start_line": 4103, 
                      "end_line": 4105, 
                      "start_column": 3, 
                      "end_column": 4
                    }
                  }, 
                  {
                    "modifiers": {
                      "private": true
                    }, 
                    "name": "child_id_", 
                    "signature": "", 
                    "name_prefix": "", 
                    "type": 9, 
                    "text_range": {
                      "start_line": 4107, 
                      "end_line": 4107, 
                      "start_column": 3, 
                      "end_column": 17
                    }
                  }, 
                  {
                    "modifiers": {
                      "private": true
                    }, 
                    "name": "bindings_", 
                    "signature": "", 
                    "name_prefix": "", 
                    "type": 9, 
                    "text_range": {
                      "start_line": 4108, 
                      "end_line": 4108, 
                      "start_column": 3, 
                      "end_column": 64
                    }
                  }
                ], 
                "name_prefix": "", 
                "type": 1, 
                "text_range": {
                  "start_line": 4079, 
                  "end_line": 4110, 
                  "start_column": 1, 
                  "end_column": 2
                }
              }
            ], 
            "type": 11, 
            "name": "", 
            "text_range": {
              "start_line": 4075, 
              "end_line": 4112, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": ""
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "RegisterNonNetworkSubresourceURLLoaderFactories", 
            "text_range": {
              "start_line": 4114, 
              "end_line": 4198, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(int render_process_id, int render_frame_id, NonNetworkURLLoaderFactoryMap* factories)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "WillCreateURLLoaderFactory", 
            "text_range": {
              "start_line": 4200, 
              "end_line": 4220, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, content::RenderFrameHost* frame, bool is_navigation, network::mojom::URLLoaderFactoryRequest* factory_request)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "WillCreateURLLoaderRequestInterceptors", 
            "text_range": {
              "start_line": 4222, 
              "end_line": 4234, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::NavigationUIData* navigation_ui_data, int frame_tree_node_id)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "WillCreateWebSocket", 
            "text_range": {
              "start_line": 4236, 
              "end_line": 4252, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderFrameHost* frame, network::mojom::WebSocketRequest* request, network::mojom::AuthenticationHandlerPtr* auth_handler)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "OnNetworkServiceCreated", 
            "text_range": {
              "start_line": 4254, 
              "end_line": 4259, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(network::mojom::NetworkService* network_service)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateNetworkContext", 
            "text_range": {
              "start_line": 4261, 
              "end_line": 4287, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* context, bool in_memory, const base::FilePath& relative_partition_path)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "AllowRenderingMhtmlOverHttp", 
            "text_range": {
              "start_line": 4289, 
              "end_line": 4303, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::NavigationUIData* navigation_ui_data)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShouldForceDownloadResource", 
            "text_range": {
              "start_line": 4305, 
              "end_line": 4314, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, const std::string& mime_type)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateUsbDeviceManager", 
            "text_range": {
              "start_line": 4316, 
              "end_line": 4340, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderFrameHost* render_frame_host, device::mojom::UsbDeviceManagerRequest request)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateUsbChooserService", 
            "text_range": {
              "start_line": 4342, 
              "end_line": 4366, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderFrameHost* render_frame_host, device::mojom::UsbChooserServiceRequest request)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetWebAuthenticationRequestDelegate", 
            "text_range": {
              "start_line": 4368, 
              "end_line": 4373, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::RenderFrameHost* render_frame_host)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateClientCertStore", 
            "text_range": {
              "start_line": 4375, 
              "end_line": 4382, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::ResourceContext* resource_context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateLoginDelegate", 
            "text_range": {
              "start_line": 4384, 
              "end_line": 4397, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(net::AuthChallengeInfo* auth_info, content::ResourceRequestInfo::WebContentsGetter web_contents_getter, const content::GlobalRequestID& request_id, bool is_request_for_main_frame, const GURL& url, scoped_refptr<net::HttpResponseHeaders> response_headers, bool first_auth_attempt, LoginAuthRequiredCallback auth_required_callback)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "HandleExternalProtocol", 
            "text_range": {
              "start_line": 4399, 
              "end_line": 4432, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const GURL& url, content::ResourceRequestInfo::WebContentsGetter web_contents_getter, int child_id, content::NavigationUIData* navigation_data, bool is_main_frame, ui::PageTransition page_transition, bool has_user_gesture)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "CreateWindowForPictureInPicture", 
            "text_range": {
              "start_line": 4434, 
              "end_line": 4449, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::PictureInPictureWindowController* controller)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "HandleWebUI", 
            "text_range": {
              "start_line": 4452, 
              "end_line": 4485, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(GURL* url, content::BrowserContext* browser_context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "ShowPaymentHandlerWindow", 
            "text_range": {
              "start_line": 4487, 
              "end_line": 4499, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::BrowserContext* browser_context, const GURL& url, base::OnceCallback<void(bool, int, int)> callback)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "HandleWebUIReverse", 
            "text_range": {
              "start_line": 4503, 
              "end_line": 4510, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(GURL* url, content::BrowserContext* browser_context)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "SetDefaultQuotaSettingsForTesting", 
            "text_range": {
              "start_line": 4513, 
              "end_line": 4516, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(const storage::QuotaSettings* settings)"
          }, 
          {
            "name_prefix": "ChromeContentBrowserClient::", 
            "type": 8, 
            "name": "GetSafeBrowsingUrlCheckerDelegate", 
            "text_range": {
              "start_line": 4518, 
              "end_line": 4536, 
              "start_column": 1, 
              "end_column": 2
            }, 
            "signature": "(content::ResourceContext* resource_context)"
          }
        ]
      }, 
      "return_code": 1
    }
  ]
}